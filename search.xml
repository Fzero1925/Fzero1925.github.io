<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Java笔记之高并发秒杀API(四)]]></title>
      <url>%2F2017%2F01%2F23%2FJava%E7%AC%94%E8%AE%B0%E4%B9%8B%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A7%92%E6%9D%80API-%E5%9B%9B%2F</url>
      <content type="text"><![CDATA[本篇将完成WEB层的设计与开发，包括： Spring MVC与Spring、MyBatis整合 设计并实现Restful接口 Spring MVC与Spring整合之前Spring与MyBatis已经进行过整合了，当通过DispatcherServlet加载Spring MVC的时候，DispatcherServlet同时会把Spring相关的配置也会整合到Spring MVC中，这样就实现了三个框架的整合，即MyBatis+Spring+Spring MVC 打开web.xml，在Eclipse中位置是src/main/webapp/WEB-INF1234567891011&lt;!-- 配置DispatcherServlet --&gt;&lt;servlet&gt; &lt;servlet-name&gt;seckill-dispatcher&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 配置Spring MVC需要加载的配置文件 --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring/spring-*.xml&lt;/param-value&gt; &lt;/init-param&gt;&lt;/servlet&gt; 首先配置的是Spring MVC中央控制器的Servlet，即DispatcherServlet，所有Spring MVC的请求都由DispatcherServlet来分发 然后配置Spring MVC需要加载的配置文件，所有在spring目录下的xml配置文件都要加载进来，之前完成的配置文件有spring-dao.xml和spring-service.xml 12345&lt;servlet-mapping&gt; &lt;servlet-name&gt;seckill-dispatcher&lt;/servlet-name&gt; &lt;!-- 默认匹配所有请求 --&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 接着是servlet-mapping，默认匹配所有请求，也就是所有请求都会被DispatcherServlet拦截 在src\main\resources\spring下新建spring-web.xml12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;&lt;beans&gt; 把以上内容复制到spring-web.xml 开始配置Spring MVC12&lt;!-- 开启Spring MVC注解模式 --&gt;&lt;mvc:annotation-driven/&gt; 开启Spring MVC注解模式，这一步是一个简化配置，提供了以下功能： 自动注册DefaultAnnotationHandlerMapping，也就是默认地URL到Handler的映射是通过注解的方式 自动注册AnnotationMethodHandlerAdapter，这个是基于注解的Handler适配器 数据绑定 数字和日期的format，也就是转换，例如@NumberFormat，@DataTimeFormat 提供xml，json默认读写支持总而言之，我们可以通过不同的注解来完成以上的功能，当然这些功能不仅可以使用注解，也可以使用额外的xml配置文件甚至是编程的方式，根据项目的不同采用不同的方式 12&lt;!-- 静态资源默认servlet配置 --&gt;&lt;mvc:default-servlet-handler/&gt; 前面配置了servlet-mapping，映射路径为“/”，使用这样配置的话，就需要这个处理方式，有两个作用： 加入对静态资源的处理，即js、png等 允许使用”/“做整体映射 接着配置jsp123456&lt;!-- 配置输出样式为JSP 显示ViewResolver --&gt;&lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;viewClass&quot; value=&quot;org.springframework.web.servlet.view.JstlView&quot;/&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;&lt;/bean&gt; 也就是需要默认的文档输出是jsp和json，不过json不需要我们提供，因为在开始配置Spring MVC注解模式的时候，已经提供了json的读写支持，只要对应到相应的注解就行 因为可能要用到el表达式或者jstl标签，所以配置一个viewClass 还要配置一个识别JSP文件前缀的属性，设置jsp文件存放在/WEB-INF/jsp目录下，再加上后缀 12&lt;!-- 扫描WEB相关的bean --&gt;&lt;context:component-scan base-package=&quot;org.seckill.web&quot;/&gt; 扫描WEB相关的bean 接着按照我粗浅的理解，简单的说一下Spring MVC的运行流程：1、用户发送的请求，所有的请求都会映射到DispatcherServlet，这是一个中央控制器的Servlet，这个Servlet会拦截所有的请求，对应在项目中应该就是web.xml中配置的servlet-mapping标签2、DispatcherServlet默认的会使用DefaultAnnotation HandlerMapping，主要的作用就是映射URL，哪个URL对应哪个handler，对应在项目中就是在spring-web.xml中mvc:annotation-driven，即开启Spring MVC的注解模式3、DispatcherServlet默认的会使用DefaultAnnotation HandlerAdapter，用于做Handler适配，对应在项目中就是在spring-web.xml中mvc:annotation-driven，即开启Spring MVC的注解模式4、DefaultAnnotation HandlerAdapter最终会衔接这次开发的SeckillController，最终的产生就是ModelAndView5、ModelAndView会与中央控制器DispatcherServlet进行交互6、通过第五步的交互，DispatcherServlet会发现应用的是InternalResource ViewResolver，这个其实就是jsp默认的View7、通过第五步的交互，DispatcherServlet也会把Model和list.jsp相结合，8、最终返回给用户实际开发的时候只有蓝色的部分，其他的可以使用默认的注解形式，非常方便地映射URL，去对应到相应的逻辑，同时控制输出数据和对应的页面 设计Restful接口 一种软件架构风格，设计风格而不是标准，只是提供了一组设计原则和约束条件。它主要用于客户端和服务器交互类的软件。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。–百度百科 通过这个项目，我对Restful接口的理解是： 这是一种优雅的URL表达方式，通过这种URL表达式可以明显的感知到这个URL代表的是什么业务场景或者什么的数据、资源 以下是本项目的URL设计： /seckill/list：秒杀列表，GET方式 /seckill/{id}/detail：详情页，GET方式 /seckill/time/now：系统时间，通过系统时间为基准，对秒杀操作进行提前的计时的操作逻辑，GET方式 /seckill/{id}/exposer：暴露秒杀，通过这个URL才能拿到最后要执行秒杀操作的URL，POST方式 /sekcill/{id}/{md5}/execution：执行秒杀，POST方式 使用Spring MVC实现Restful接口在org.seckill包下新建一个web包，用于存放所有的controller，新建一个SeckillController类123@Controller@RequestMapping(&quot;/seckill&quot;)public class SeckillController 标注这个类是一个Controller，使用@Controller注解，目的是将这个类放入Spring容器当中 还要加上一个@RequestMapping注解，代表的是模块，由于我们使用比较规范的URL设计风格，所有的URL应该是：1/模块/资源/&#123;id&#125;/更加细分 要获取列表页，也就是要调用Service12345//实例化日志对象，导入org.slf4j包private final Logger logger = LoggerFactory.getLogger(this.getClass()); @Autowiredprivate SeckillService seckillService; 将Service注入到当前的Controller下，SeckillService在Spring容器中只有一个，Spring容器根据类型匹配，会直接找到bean的实例，然后注入到当前的Controller下 秒杀列表页123456789@RequestMapping(value = &quot;/list&quot;, method = RequestMethod.GET)public String list(Model model)&#123; //获取列表页 List&lt;Seckill&gt; list = seckillService.getSeckillList(); model.addAttribute(&quot;list&quot;, list); return &quot;list&quot;;&#125; 参数model就是用来存放渲染list.jsp的数据 1@RequestMapping(value = &quot;/list&quot;, method = RequestMethod.GET) 这里Spring MVC的注解映射使用的是@RequestMapping注解，其中value的值是二级URL，后面的method属性限制了http请求的方式，这个方法只接收GET方式的http请求，如果是POST请求，Spring MVC将不会做映射 @RequestMapping注解它支持很多种URL映射： 支持标准的URL 支持Ant风格URL，即```等字符123456 - ``` ? ```表示匹配一个字符 - ``` * ```表示匹配任意字符 - ``` ** ```表示匹配任意URL路径- 带&#123;&#125;占位符的URL举个栗子： /user//creation可以匹配/user/aaa/creation、/user/bbb/creation等URL/user/*/creation可以匹配/user/creation、/user/aaa/bbb/creation等URL/user/{userId}可以匹配user/213、user/abc等URL 123、abc可以以参数的方式传入/company/{companyId}/user/{userId}/detail匹配/company/123/user/456/detail等URL12在list方法中，通过实例化的SeckillService调用其中的方法 /** 查询所有秒杀商品记录 @return*/List getSeckillList();//这是SeckillService接口中的方法12345```//获取列表页List&lt;Seckill&gt; list = seckillService.getSeckillList();model.addAttribute(&quot;list&quot;, list);return &quot;list&quot;; model就是用来存放数据的，并把返回的数据通过字符串进行标识，最后返回一个字符串，那么这里为什么返回一个字符串？这个字符串会被怎么处理？ 之前介绍的Spring MVC运行流程HandlerAdapter在对Handler，即SeckillController进行处理之后会返回一个ModelAndView对象，在获得了ModelAndView对象之后，Spring就需要把该View渲染给用户，即返回给浏览器。在这个渲染的过程中，发挥作用的就是ViewResolver和View12345&lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;viewClass&quot; value=&quot;org.springframework.web.servlet.view.JstlView&quot;/&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;&lt;/bean&gt; 在spring-web.xml文件中使用的ViewResolver是InternalResourceViewResolver InternalResourceViewResolver 会把返回的视图名称都解析为 InternalResourceView 对象， InternalResourceView 会把 Controller 处理器方法返回的模型属性都存放到对应的 request 属性中，然后通过 RequestDispatcher 在服务器端把请求 forword 重定向到目标 URL 。比如在 InternalResourceViewResolver 中定义了 prefix=/WEB-INF/ ， suffix=.jsp ，然后请求的 Controller 处理器方法返回的视图名称为 test ，那么这个时候 InternalResourceViewResolver 就会把 test 解析为一个 InternalResourceView 对象，先把返回的模型属性都存放到对应的 HttpServletRequest 属性中，然后利用 RequestDispatcher 在服务器端把请求 forword 到 /WEB-INF/test.jsp 这就是 InternalResourceViewResolver 一个非常重要的特性，我们都知道存放在 /WEB-INF/ 下面的内容是不能直接通过 request 请求的方式请求到的，为了安全性考虑，我们通常会把 jsp 文件放在 WEB-INF 目录下，而 InternalResourceView 在服务器端跳转的方式可以很好的解决这个问题 秒杀详情页1234567891011121314@RequestMapping(value = &quot;/&#123;seckillId&#125;/detail&quot;, method = RequestMethod.GET)public String detail(@PathVariable(&quot;seckillId&quot;) Long seckillId, Model model)&#123; if(seckillId == null)&#123; return &quot;redirect:/seckill/list&quot;; &#125; Seckill seckill = seckillService.getById(seckillId); if(seckill == null)&#123; return &quot;forward:/seckill/list&quot;; &#125; model.addAttribute(&quot;seckill&quot;, seckill); return &quot;detail&quot;; &#125; 之前说过，@RequestMapping注解支持多种URL映射，本项目所设计的URL就有带{}占位符的URL12@RequestMapping(value = &quot;/&#123;seckillId&#125;/detail&quot;, method = RequestMethod.GET)public String detail(@PathVariable(&quot;seckillId&quot;) Long seckillId, Model model) 通过@PathVariable注解绑定后面的参数seckilId，然后对应到URL占位符，当用户传递对应的URL时，@RequestMapping注解中占位符{seckillId}的值会传入detail方法中对应的参数，因为不同的秒杀商品有不同的详情页，所以在二级URL上使用占位符标识不同id的秒杀商品 接着对传进来的seckillId进行判断1234567if(seckillId == null)&#123; return &quot;redirect:/seckill/list&quot;;&#125;Seckill seckill = seckillService.getById(seckillId);if(seckill == null)&#123; return &quot;forward:/seckill/list&quot;;&#125; 先要判断seckillId有没有传进来，如果没有传进来，就请求转发到list页面，会回到列表页；如果传进来的seckillId的值不属于任何秒杀商品，那么仍然会重定向到列表页 这里简单说下请求转发与重定向： 从地址栏显示来说： forward：服务器请求资源，服务器直接访问目标地址的URL，把那个URL的响应内容读取过来，然后把这些内容再发给浏览器，浏览器根本不知道服务器发送的内容从哪里来的，所以它的地址栏还是原来的地址 redirect：服务端根据逻辑，发送一个状态码，告诉浏览器重新去请求那个地址，所以地址栏显示的是新的URL，redirect等于客户端向服务器端发出两次request，同时也接受两次response 从数据共享来说 forward：转发页面和转发到的页面可以共享request里面的数据 redirect：不能共享数据 从运用地方来说 forward：一般用于用户登陆的时候,根据角色转发到相应的模块 redirect：一般用于用户注销登陆时返回主页面和跳转到其它的网站等 从效率来说 forward：高 redirect：低 这里使用redirect和forward没有特别的用意 12model.addAttribute(&quot;seckill&quot;, seckill);return &quot;detail&quot;; 接着就是使用model存储数据，并返回一个字符串 秒杀地址暴露1234567891011121314151617@RequestMapping( value = &quot;/&#123;seckillId&#125;/exposer&quot;, method = RequestMethod.POST, produces = &#123;&quot;application/json;charset=UTF-8&quot;&#125;)@ResponseBodypublic SeckillResult&lt;Exposer&gt; exposer(@PathVariable(&quot;seckillId&quot;) Long seckillId)&#123; SeckillResult&lt;Exposer&gt; result; try &#123; Exposer exposer = seckillService.exportSeckillUrl(seckillId); result = new SeckillResult&lt;Exposer&gt;(true, exposer); &#125; catch (Exception e) &#123; logger.error(e.getMessage(), e); result = new SeckillResult&lt;Exposer&gt;(false, e.getMessage()); &#125; return result;&#125; 同样在方法上使用@RequestMapping注解设置二级URL，限制http请求方式为POST，并且通过produces返回HttpResponse的hanndler，告诉浏览器这是一个application/json,同时设置编码为UTF-8 使用@ResponseBody注解，Spring MVC会把返回的数据封装成json 之前说过有个DTO层，主要是用来封装Service层与WEB层之间的数据，这里在dto包下新建一个SeckillResult类，用于封装数据结果123456789//封装json结果public class SeckillResult&lt;T&gt; &#123; private boolean success;//判断请求是否成功 private T data;//存放数据 private String error;//错误信息&#125; 这个类是一个泛型类型123456789public SeckillResult(boolean success, T data) &#123; this.success = success; this.data = data;&#125;public SeckillResult(boolean success, String error) &#123; this.success = success; this.error = error;&#125; 通过success来判断请求是否成功，成功的话，返回从数据库中取得的数据，如果请求不成功，返回错误信息 再生成get和set方法 12345SeckillResult&lt;Exposer&gt; result; try &#123; Exposer exposer = seckillService.exportSeckillUrl(seckillId); result = new SeckillResult&lt;Exposer&gt;(true, exposer);&#125; 实例化一个SeckillResult对象，调用SeckillService的exportSeckillUrl方法1234567/*** 秒杀开启时输出秒杀接口地址* 否则输出系统时间和秒杀时间* @param seckillId* @return*/Exposer exportSeckillUrl(long seckillId);//SeckillService接口中的方法 可以看到SeckillService的这个方法返回的是Exposer类型，所以实例化SeckillResult对象的时候，泛型中是Exposer类型1234567891011121314151617181920public class Exposer &#123; //是否开启秒杀 private boolean exposed; //加密措施 private String md5; //id private long seckillId; //系统当前时间（毫秒） private long now; //秒杀开启时间 private long start; //秒杀结束时间 private long end;&#125; 从之前定义好的Exposer类中的属性就可以看到，如果开启秒杀的话，页面会返回通过MD5加密过的秒杀的地址，如果没有开启秒杀，则返回系统当前时间及秒杀开启与结束时间，用于倒计时 在SeckillController中，如果秒杀开启，通过调用SeckillService中的exportSeckillUrl方法返回Exposer对象，存放的是MD5及seckillId，然后初始化SeckillResult对象，参数为true，成功返回Exposer对象中的数据 如果这期间出现错误，说明没有请求成功，需要把上面两步try/catch一下12345catch (Exception e) &#123; logger.error(e.getMessage(), e); result = new SeckillResult&lt;Exposer&gt;(false, e.getMessage());&#125;return result; 因为没请求成功，所以需要输出错误信息，同时说明不在秒杀活动期内，同样初始化SeckillResult对象，返回Exposer类中的信息，在Exposer中定义的有系统当前时间以及秒杀开启、结束时间，所以如果没有请求成功，在页面返回的是倒计时或者是秒杀结束等字样 执行秒杀12345678910111213141516171819202122232425262728@RequestMapping( value = &quot;/&#123;seckillId&#125;/&#123;md5&#125;/execution&quot;, method = RequestMethod.POST, produces = &#123;&quot;application/json;charset=UTF-8&quot;&#125;)@ResponseBodypublic SeckillResult&lt;SeckillExecution&gt; execute(@PathVariable(&quot;seckillId&quot;) Long seckillId, @PathVariable(&quot;md5&quot;) String md5, @CookieValue(value = &quot;killPhone&quot;, required = false) Long phone)&#123; if(phone == null)&#123; return new SeckillResult&lt;SeckillExecution&gt;(false, &quot;未注册&quot;); &#125; //SeckillResult&lt;SeckillExecution&gt; result; try &#123; SeckillExecution execution = seckillService.executeSeckill(seckillId, phone, md5); return new SeckillResult&lt;SeckillExecution&gt;(true, execution); &#125; catch (RepeatKillException e) &#123; SeckillExecution execution = new SeckillExecution(seckillId, SeckillStateEnum.REPEAT_KILL); return new SeckillResult&lt;SeckillExecution&gt;(true, execution); &#125; catch (SeckillCloseException e) &#123; SeckillExecution execution = new SeckillExecution(seckillId, SeckillStateEnum.END); return new SeckillResult&lt;SeckillExecution&gt;(true, execution); &#125; catch (Exception e) &#123; logger.error(e.getMessage(), e); SeckillExecution execution = new SeckillExecution(seckillId, SeckillStateEnum.INNER_ERROR); return new SeckillResult&lt;SeckillExecution&gt;(true, execution); &#125;&#125; 方法上的注解就不多说了，和上面一样，所有的ajax请求返回的都是统一的SeckillResult，之前在dto包中已经定义了SeckillException，用于封装秒杀执行后的结果123456789101112131415161718/** * 封装秒杀执行后的结果 * @author Fzero * */public class SeckillExecution &#123; private long seckillId; //秒杀结果执行后的状态 private int state; //状态信息 private String stateInfo; //秒杀成功对象 private SuccessKilled successKilled;&#125; 这里就可以理解DTO作为Service与WEB层之间数据传递 因为所有的秒杀都要有用户的标识，本项目没有做登录模块，所以使用手机号phone作为用户的标识，可以看到@RequestMapping注解中的请求参数中没有phone，这个参数是由用户浏览器的Request请求的cookie中获取到的，这里Spring MVC处理cookie有个小问题，如果不设置required属性为false的时候，当请求的header中没有一个cookie叫killPhone的时候，Spring MVC会报错，所以在@CookieValue注解中将required设置为false 1234567if(phone == null)&#123; return new SeckillResult&lt;SeckillExecution&gt;(false, &quot;未注册&quot;);&#125;try &#123; SeckillExecution execution = seckillService.executeSeckill(seckillId, phone, md5); return new SeckillResult&lt;SeckillExecution&gt;(true, execution);&#125; 这里先使用if简单的判断一下，实际项目中，要验证的参数很多，可以采用Spring MVC的验证信息，所以这里的killPhone不是必须的，验证用户的逻辑放在代码中 对于执行秒杀操作，可能会出现各种异常和错误，所以这里需要try/catch以下，并且有些特定的异常比如重复秒杀、秒杀结束等，之前单独建立了一个exception包，专门存放与业务相关的异常123456789/*** 执行秒杀操作* @param seckillId* @param userPhone* @param md5* @return*/SeckillExecution executeSeckill(long seckillId, long userPhone, String md5) throws SeckillException,RepeatKillException,SeckillCloseException; 这是SeckillService中定义的方法，可以看到抛出了不同的异常，所以对于这些特定的异常，要单独的catch1234catch (RepeatKillException e) &#123; SeckillExecution execution = new SeckillExecution(seckillId, SeckillStateEnum.REPEAT_KILL); return new SeckillResult&lt;SeckillExecution&gt;(true, execution);&#125; 这个是处理重复秒杀的异常，重新初始化SeckillExecution对象，向数据字典传入对象异常的标识，结果是返回初始化的SeckillResult，上面说过SeckillExecution对象是用于封装秒杀执行后的结果，这里的参数为true，因为当初在SeckillResult定义布尔类型的success的时候就说明这是判断请求是否成功，这里的重复秒杀显然是请求成功，所以参数为true 1234catch (SeckillCloseException e) &#123; SeckillExecution execution = new SeckillExecution(seckillId, SeckillStateEnum.END); return new SeckillResult&lt;SeckillExecution&gt;(true, execution);&#125; 秒杀关闭异常 12345catch (Exception e) &#123; logger.error(e.getMessage(), e); SeckillExecution execution = new SeckillExecution(seckillId, SeckillStateEnum.INNER_ERROR); return new SeckillResult&lt;SeckillExecution&gt;(true, execution);&#125; 如果不是上述特定的两个异常，其他的异常都视为inner_error 最后一个方法就是获取系统时间123456@RequestMapping(value = &quot;/time/now&quot;, method = RequestMethod.GET)@ResponseBodypublic SeckillResult&lt;Long&gt; time()&#123; Date now = new Date(); return new SeckillResult&lt;Long&gt;(true, now.getTime());&#125; 至此，WEB层完成了]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java笔记之高并发秒杀API(三)]]></title>
      <url>%2F2017%2F01%2F11%2FJava%E7%AC%94%E8%AE%B0%E4%B9%8B%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A7%92%E6%9D%80API-%E4%B8%89%2F</url>
      <content type="text"><![CDATA[本篇将完成Service层的设计与开发，包括： 秒杀业务接口设计与实现 基于Spring托管Service实现类 配置Spring声明式事务 Service层集成测试 秒杀业务接口设计在org.seckill包下创建Service层需要的包： service：存放Service接口和实现类 exception：存放Service接口所需要的一些自定义异常，比如重复秒杀、秒杀关闭等 dto：数据传输层，和entity有些类似，都是存放表示数据的一些类型，entity关注的是业务上的一些封装，dto关注的是WEB和Service之间的数据传递 接着在service包下新建一个SeckillService接口 首先要做一个列表页的话，就要拿到Seckill的所有属性123456789101112/** * 查询所有秒杀商品记录 * @return */List&lt;Seckill&gt; getSeckillList();/** * 查询单个秒杀商品记录 * @param seckillId * @return */Seckill getById(long seckillId); 这是基本的查询方法，接下来是一些行为的方法 1234567/** * 秒杀开启时输出秒杀接口地址 * 否则输出系统时间和秒杀时间 * @param seckillId * @return */Exposer exportSeckillUrl(long seckillId); 在秒杀活动开始之前，要保证没有人知道秒杀接口的地址，不能让用户通过url规则拼出来秒杀活动的地址，所以这个方法在秒杀活动开启时输出秒杀接口地址，否则输出系统时间和秒杀时间 那么这个方法返回的类型是什么呢？活动期间，这个方法返回的是秒杀接口地址url，不在活动期间，返回的是一些日期，都是和业务部相关的一些数据，所以我们需要一个dto 在dto包下新建一个Exposer类，用来暴露秒杀接口，或者输出日期123456789101112131415161718192021222324252627282930313233343536/** * 暴露秒杀地址DTO * @author Fzero * */public class Exposer &#123; //是否开启秒杀 private boolean exposed; //加密措施 private String md5; //id private long seckillId; //系统当前时间（毫秒） private long now; //秒杀开启时间 private long start; //秒杀结束时间 private long end; @Override public String toString() &#123; return &quot;Exposer [exposed=&quot; + exposed + &quot;, md5=&quot; + md5 + &quot;, seckillId=&quot; + seckillId + &quot;, now=&quot; + now + &quot;, start=&quot; + start + &quot;, end=&quot; + end + &quot;]&quot;; &#125;&#125; 首先是设置一个开关exposerd，判断秒杀接口是否要暴露，对于暴露的接口，还要对接口进行一下改动，加上简单的md5，还有上面说的系统时间和秒杀时间，复写toString方法，使得日志输出的时候方便获取属性值，并生成get和set方法 为了方便初始化，需要设置几个构造方法123456public Exposer(boolean exposed, String md5, long seckillId) &#123; super(); this.exposed = exposed; this.md5 = md5; this.seckillId = seckillId;&#125; 如果在秒杀活动期内，存储MD5，如果不在活动期内，MD5的值为空 12345678public Exposer(boolean exposed, long seckillId, long now, long start, long end) &#123; super(); this.exposed = exposed; this.seckillId = seckillId; this.now = now; this.start = start; this.end = end;&#125; 如果不在秒杀活动期，返回系统时间和秒杀活动开启、关闭时间 12345public Exposer(boolean exposed, long seckillId) &#123; super(); this.exposed = exposed; this.seckillId = seckillId;&#125; 是否开启秒杀，返回seckillId Exposer类完成，返回SeckillService接口 接下来就是执行秒杀操作的方法12345678/** * 执行秒杀操作 * @param seckillId * @param userPhone * @param md5 * @return */SeckillExecution executeSeckill(long seckillId, long userPhone, String md5); 之前说过，唯一确定一个用户的方法是seckillId和phone，seckillId加上自定义的盐值，通过MD5加密，一定程度上能够防止用户通过url规则拼出秒杀接口地址，因为Exposer方法先被调用，里面有MD5的值，传递进来的MD5的值要和内部生成的一个MD5规则进行比较，如果不吻合，说明用户的url被篡改了，不执行秒杀操作，返回的类型还要再封装一个DTO接口，用来封装秒杀执行后的结果，那么秒杀执行后的结果需要什么数据呢？秒杀成功了还是失败了？如果失败了，还要知道为什么失败了 在dto包下新建一个SeckillExecution类1234567891011121314151617181920212223public class SeckillExecution &#123; private long seckillId; //秒杀结果执行后的状态 private int state; //状态信息 private String stateInfo; //秒杀成功对象 private SuccessKilled successKilled; @Override public String toString() &#123; return &quot;SeckillExecution [seckillId=&quot; + &quot;&quot; + seckillId + &quot;, state=&quot; + state + &quot;, stateInfo=&quot; + stateInfo+ &quot;, successKilled=&quot; + successKilled + &quot;]&quot;; &#125;&#125; 这里需要实例化SuccessKilled对象，如果秒杀成功，要能获得成功秒杀商品的用户信息，接着直接生成get和set方法，还要初始化几个构造方法1234567public SeckillExecution(long seckillId, SeckillStateEnum stateEnum, SuccessKilled successKilled) &#123; super(); this.seckillId = seckillId; this.state = stateEnum.getState(); this.stateInfo = stateEnum.getStateString(); this.successKilled = successKilled;&#125; 秒杀成功后，返回所有的属性值 在数据库success_killed表中，有state作为状态标识，不同的数字表示不同的状态，在接下来的代码中，也经常用到这些状态标识，但是这些状态标识和状态信息，应该是输出给前端的，这个是属于数据字典中的，没必要在代码中频繁出现，像这种常量，建议使用枚举表示，所以在org.seckill包下新建一个枚举包enums，新建一个枚举类型的文件SeckillStateEnum1234567891011121314151617public enum SeckillStateEnum &#123; SUCCESS(1, &quot;秒杀成功&quot;), END(0, &quot;秒杀结束&quot;), REPEAT_KILL(-1, &quot;重复秒杀&quot;), INNER_ERROR(-2, &quot;系统异常&quot;), DATA_REWRITE(-2, &quot;数据篡改&quot;); private int state; private String stateString; private SeckillStateEnum(int state, String stateString) &#123; this.state = state; this.stateString = stateString; &#125;&#125; 初始化一个构造方法，并生成get方法 接着创建一个方法12345678public static SeckillStateEnum stateOf(int index)&#123; for(SeckillStateEnum state : values())&#123; if(state.getState() == index)&#123; return state; &#125; &#125; return null;&#125; 返回state状态标识，可以通过状态标识获得相应的状态信息，本项目的数据字典已经完成了 在dto包下的SeckillExecution类还要再初始化一个构造方法123456public SeckillExecution(long seckillId, SeckillStateEnum stateEnum) &#123; super(); this.seckillId = seckillId; this.state = stateEnum.getState(); this.stateInfo = stateEnum.getStateString();&#125; 秒杀失败后返回相应的状态信息 这时还有个小问题，就是当执行异常的时候，要告知接口使用方这个方法可能会输出什么样的异常，因为跟业务相关的异常可以利用起来 在存放异常的exception包下新建一个SeckillException类，异常一般是作为通用的接口或类，解决某一层面的问题123456789101112131415161718/** * 秒杀业务相关异常 * @author Fzero * */public class SeckillException extends RuntimeException &#123; public SeckillException(String message, Throwable cause) &#123; super(message, cause); // TODO Auto-generated constructor stub &#125; public SeckillException(String message) &#123; super(message); // TODO Auto-generated constructor stub &#125;&#125; 继承与RuntimeException，初始化两个构造方法 这个异常本质上是一个运行期异常，运行期异常不需要手动的try/catch，使用运行期异常还有个重要的原因，就是 Spring的声明式事务，它只接收运行期异常回滚策略，也就是当抛出一个非运行期异常，Spring的声明式事务不会帮我们做回滚的 接着可以定义一些业务中比较常见的异常，可以单独捕捉或处理 新建一个RepeatKillException类，从名字可以看出，处理的是重复秒杀的异常123456789101112131415161718/** * 重复秒杀异常（运行期异常） * @author Fzero * */public class RepeatKillException extends SeckillException &#123; public RepeatKillException(String message, Throwable cause) &#123; super(message, cause); // TODO Auto-generated constructor stub &#125; public RepeatKillException(String message) &#123; super(message); // TODO Auto-generated constructor stub &#125;&#125; 再新建一个SeckillCloseException类，秒杀关闭异常123456789101112131415161718/** * 秒杀关闭异常 * @author Fzero * */public class SeckillCloseException extends SeckillException &#123; public SeckillCloseException(String message, Throwable cause) &#123; super(message, cause); // TODO Auto-generated constructor stub &#125; public SeckillCloseException(String message) &#123; super(message); // TODO Auto-generated constructor stub &#125;&#125; 秒杀活动关闭后，秒杀的执行不能被允许，比如时间到了，或者库存消耗光了 秒杀接口实现在service包下新建一个impl包，用于存放实现Service接口的实现类，新建一个SeckillService接口的实现类SeckillServiceImpl，然后复写SeckillService的四个方法12345678910111213141516171819public class SeckillServiceImpl implements SeckillService &#123; private Logger logger = LoggerFactory.getLogger(this.getClass()); private SeckillDao seckillDao; private SuccessKilledDao successKilledDao; //MD5盐值字符串，用户混淆MD5 private final String slat = &quot;sldjflsjdfwiejfwjefi$&amp;**(&amp;*&amp;&quot;; public List&lt;Seckill&gt; getSeckillList() &#123; return seckillDao.queryAll(0, 4); &#125; public Seckill getById(long seckillId) &#123; return seckillDao.queryById(seckillId); &#125;&#125; 这里要用DAO中的接口，把之前设计的两个接口实例化并生成get方法，但不初始化，因为所有DAO接口的实现类都在Spring容器当中，然后是实例化日志对象，导入org.slf4j包，接着修改复写的方法 1234567891011121314public Exposer exportSeckillUrl(long seckillId) &#123; Seckill seckill = seckillDao.queryById(seckillId); if(seckill == null)&#123; return new Exposer(false, seckillId); &#125; Date startTime = seckill.getStartTime(); Date endTime = seckill.getEndTime(); Date nowTime = new Date();//系统当前时间 if(nowTime.getTime() &lt; startTime.getTime() || nowTime.getTime() &gt; endTime.getTime())&#123; return new Exposer(false, seckillId, nowTime.getTime(), startTime.getTime(), endTime.getTime()); &#125; String md5 = getMD5(seckillId); return new Exposer(true, md5, seckillId);&#125; 这个方法就是用于显示秒杀接口的地址，首先要进行一个判断，如果seckill为空，就返回一个Exposer，使用Exposer中的构造方法，如果不为空，但是不在秒杀活动期内，就返回秒杀活动的开始时间、结束时间和系统时间，最后既然都判断完了，时间在秒杀活动内，就要返回秒杀开启的一些信息，通过返回的MD5才能与用户输入的地址是否正确 为了不让用户猜到返回值，前面已经定义了一个用于混淆的值slat，越复杂越好，然后创建一个方法，生成MD512345private String getMD5(long seckillId)&#123; String base = seckillId + &quot;/&quot; + slat; String md5 = DigestUtils.md5DigestAsHex(base.getBytes()); return md5;&#125; 如果只使用id进行MD5加密的话，实际上用户是可以通过算法跑出来的，如果加上混淆的字符串，几乎是不可能的 最后要完成的是执行秒杀方法的实现12345678910111213141516171819202122232425262728293031323334public SeckillExecution executeSeckill(long seckillId, long userPhone, String md5) &#123; if(md5 == null || !md5.equals(getMD5(seckillId)))&#123; throw new SeckillException(&quot;seckill data rewrite&quot;); &#125; //执行秒杀逻辑：减库存 + 记录购买行为 Date nowTime = new Date(); try &#123; //减库存 int updateCount = seckillDao.reduceNumber(seckillId, nowTime); if(updateCount &lt;= 0)&#123; //没有更新记录，即秒杀活动结束 throw new SeckillCloseException(&quot;seckill is closed&quot;); &#125; else &#123; //记录购买行为 int insertCount = successKilledDao.insertSuccessKilled(seckillId, userPhone); if(insertCount &lt;= 0)&#123; //重复秒杀 throw new RepeatKillException(&quot;seckill repeated&quot;); &#125; else &#123; //秒杀成功 SuccessKilled successKilled = successKilledDao.queryByIdWithSeckill(seckillId, userPhone); return new SeckillExecution(seckillId, SeckillStateEnum.SUCCESS, successKilled); &#125; &#125; &#125; catch(SeckillCloseException e1) &#123; throw e1; &#125; catch(RepeatKillException e2)&#123; throw e2; &#125; catch (Exception e) &#123; logger.error(e.getMessage(), e); //所有编译期异常转化为运行期异常 throw new SeckillException(&quot;seckill inner error: &quot; + e.getMessage()); &#125;&#125; 首先要判断用户传递过来的MD5是否和我们设置的MD5的值是否相同，不相同或是空的话，抛出一个SeckillException异常 成功秒杀后，就要执行秒杀逻辑，即减库存+记录购买行为，以系统当前时间为秒杀时间，reduceNumber方法还能判断秒杀时间是否在活动时间内，如果返回的值小于等于0，说明没有更新记录，即秒杀活动结束了 成功减库存后，就要记录购买行为了，同样进行判断，如果返回值小于等于0 说明重复秒杀，insert语句不执行，如果秒杀成功，返回SuccessKilled对象 最后，整个逻辑要try/catch，因为可能会有其他的异常，比如超时、链接断开等，并抛出业务异常，因为SeckillException继承自RuntimeException，所以这里就把编译期异常，转化为运行期异常，这样Spring的声明式事务可以帮我们做回滚操作，因为之前方法中会可能有指定的异常，比如重复秒杀，秒杀关闭等，所以在SeckillException父类异常之前catch住，然后抛出 至此，Service层接口的实现类完成了 基于Spring管理Service依赖管理Service，本质上是通过Spring IOC功能，即依赖注入对于Spring IOC，首先会有一个创建对象的过程，也就是对象工厂，这个工厂可以创建SeckillService的实现 而SeckillService也需要众多依赖，比如DAO层的依赖，所以Spring IOC不但帮我们创建SeckillDAO和SuccessKilledDAO的实现，还要创建Service层的实现，并且把这些实现组成依赖，最终提供一个一直的访问接口，通过这个接口，我们可以访问工厂当中任意的实例 SeckillService依赖DAO层的两个接口，DAO的接口依赖于SqlSessionFactory，而SqlSessionFactory也需要数据源等一些依赖，整个这个初始化过程，都是由Spring自动组装好，最后给我们的是一个SeckillService，一个完整的实例 在resources/spring包下新建一个spring-service.xml，可以把spring-dao.xml中beans标签中的内容复制过来，当然，在这基础场在添加三行内容，关于tx的命名空间12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt;&lt;beans&gt; 首先配置的是扫描service包下所有使用注解的类型12&lt;!-- 扫描service包下所有使用注解的依赖 --&gt;&lt;context:component-scan base-package=&quot;org.seckill.service&quot;/&gt; 扫描后会初始化这些类型，然后放到Spring容器当中，如果这些类型中有其他的依赖，比如SeckillServiceImpl类中有SeckillDao和SuccessKilledDao的依赖，这个配置也会初始化这些依赖 那么是哪些注解？首先是@Component，代表所有的组件，当不清楚这个类或者属性是属于DAO或者是Service的时候，可以使用这个,当然还有@Service、@Dao、@Conroller等 对于SeckillServiceImpl，很明显，在类上添加@Service注解12@Servicepublic class SeckillServiceImpl implements SeckillService 同样，在SeckillServiceImpl方法中，对于seckillDao属性和successKillDao属性123456//注入Service依赖@Autowiredprivate SeckillDao seckillDao;@Autowiredprivate SuccessKilledDao successKilledDao; MyBatis和Spring整合之后，MyBatis下所有的DAO接口都会使用mapper的方式初始化好，然后放到Spring容器当中，要在Spring容器中获取DAO的实例，并注入到Service中，可以使用Spring提供的注解@Autowired，使用之后，它就会在Spring容器中查找SeckillDao的实例，因为之前MyBatis的mapper已经初始化好并放在Spring容器中，所以就会注入到Service的属性中，不需要手动的new一个 Spring声明式事务声明式事务的基本流程，先是开启事务，然后修改SQL语句，最后再提交或回滚事务 由于 Spring只有在抛出运行期异常（RuntimeException)时才会执行回滚操作 ，所以在代码中要小心使用try/catch，当异常被捕捉到的时候，Spring接收不到异常，就不会执行回滚操作 打开spring-service.xml，开始配置Spring声明式事务12345&lt;!-- 配置事务管理器 --&gt;&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;!-- 注入数据库连接池 --&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;&lt;/bean&gt; 只要用到事务，首先配置的就是事务管理器，MyBatis默认的是jdbc的事务管理器，接着注入数据库连接池 然后配置基于注解的声明式事务，这个配置的作用就是默认使用注解来管理事务行为12&lt;!-- 配置基于注解的声明式事务:默认使用注解来管理事务行为 --&gt;&lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&gt; 打开SeckillServiceImpl类，在executeSeckill方法上添加@Transactional注解12@Transactionalpublic SeckillExecution executeSeckill(long seckillId, long userPhone, String md5) 不是所有的方法都要在事务的控制之下，比如只读，所以只在会对数据库进行更新操作的方法上添加Spring的声明式事务注解，这样就可以保证该方法运行在事务的控制之下，防止数据被错误的修改 五、Service层集成测试对SeckillService类生成相应的测试类，选中所有的方法，同样在类上加上@RunWith和@ContextConfiguration注解123456@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(&#123; &quot;classpath:spring/spring-dao.xml&quot;, &quot;classpath:spring/spring-service.xml&quot;&#125;)public class SeckillServiceTest 然后通过Spring依赖注入的方式，将测试类的属性注入到当前测试类下,在测试之前，先把日志的输出定义一下，导入org.slf4j包1234private final Logger logger = LoggerFactory.getLogger(this.getClass());@Autowiredprivate SeckillService seckillService; 不过slf4j只是接口，要实现日志需要logback，在resources目录下新建一个logback.xml文件，然后打开logback官网，找到相关配置示例，复制过来 先测试两个获取Seckill数据的方法123456789101112@Testpublic void testGetSeckillList() &#123; List&lt;Seckill&gt; list = seckillService.getSeckillList(); logger.info(&quot;list=&#123;&#125;&quot;, list);&#125;@Testpublic void testGetById() &#123; long id = 1000; Seckill seckill = seckillService.getById(id); logger.info(&quot;seckill=&#123;&#125;&quot;, seckill);&#125; 可以看到最下面拿到了List 接着测试exportSeckillUrl方法，用于显示秒杀接口地址或者是日期123456@Testpublic void testExportSeckillUrl() &#123; long id = 1000; Exposer exposer = seckillService.exportSeckillUrl(id); logger.info(&quot;exposer=&#123;&#125;&quot;, exposer);&#125; 最下面显示了MD5的值，如果返回的MD5为null，说明不在秒杀活动期内，想看到MD5的话，在控制台进入MySQL，把seckill表中的start_time/end_time改一下 最后是executeSeckill方法1234567891011121314@Testpublic void testExecuteSeckill() &#123; long id = 1000; long userPhone = 13587456321L; String md5 = &quot;f540e8a6bf6016cea1d929ca265dfed3&quot;; try &#123; SeckillExecution execution = seckillService.executeSeckill(id, userPhone, md5); logger.info(&quot;result=&#123;&#125;&quot;, execution); &#125; catch (RepeatKillException e) &#123; logger.error(e.getMessage()); &#125; catch (SeckillCloseException e) &#123; logger.error(e.getMessage()); &#125;&#125; 第一条是之前测试的数据 方法中的MD5的值是上个方法测试后日志输出时的数据 当然，最后两个方法可以放在一个测试方法中，免得要手动复制MD51234567891011121314151617181920@Testpublic void testSeckillLogic() &#123; long id = 1001; Exposer exposer = seckillService.exportSeckillUrl(id); if(exposer.isExposed())&#123; logger.info(&quot;exposer=&#123;&#125;&quot;, exposer); long userPhone = 13587456321L; String md5 = exposer.getMd5(); try &#123; SeckillExecution execution = seckillService.executeSeckill(id, userPhone, md5); logger.info(&quot;result=&#123;&#125;&quot;, execution); &#125; catch (RepeatKillException e) &#123; logger.error(e.getMessage()); &#125; catch (SeckillCloseException e) &#123; logger.error(e.getMessage()); &#125; &#125; else &#123; //秒杀未开启 logger.warn(&quot;exposer=&#123;&#125;&quot;, exposer); &#125; 这里的try/catch其实是为了保证测试类的通过，因为像重复秒杀异常(RepeatKillException)、秒杀关闭异常(SeckillCloseException)都是自定义的异常，这些异常报错，也说明测试通过了，所以为了统一，把这些用于测试的异常也catch住并打印 至此，Service层接口的设计与实现完成了]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java笔记之高并发秒杀API(二)]]></title>
      <url>%2F2017%2F01%2F05%2FJava%E7%AC%94%E8%AE%B0%E4%B9%8B%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A7%92%E6%9D%80API-%E4%BA%8C%2F</url>
      <content type="text"><![CDATA[本篇将完成DAO层的设计与开发，包括： 数据库、DAO实体与接口设计与编码 基于MyBatis实现DAO编程 MyBatis与Spring整合 DAO层单元测试 数据库设计与编码打开Eclipse，在src\main下建立一个文件夹sql，用于存放建表语句，新建一个SQL文件schema.sql，先创建一个秒杀商品的库存表 123456789101112131415161718192021-- 数据库初始化脚本-- 创建数据库CREATE DATABASE seckill;-- 使用数据库USE seckill;--创建秒杀库存表CREATE TABLE seckill(`seckill_id` bigint NOT NULL AUTO_INCREMENT COMMENT &apos;商品库存id&apos;,`name` varchar(120) NOT NULL COMMENT &apos;商品名称&apos;,`number` int NOT NULL COMMENT &apos;库存数量&apos;,`start_time` timestamp NOT NULL COMMENT &apos;秒杀开始时间&apos;,`end_time` timestamp NOT NULL COMMENT &apos;秒杀结束时间&apos;,`create_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &apos;创建时间&apos;,PRIMARY KEY (seckill_id),key idx_start_time(start_time),key idx_end_time(end_time),key idx_create_time(create_time))ENGINE=InnoDB AUTO_INCREMENT=1000 DEFAULT CHARSET=utf8 COMMENT=&apos;秒杀库存表&apos;; 主键为seckill_id，再单独对start_time、end_time、create_time三列单独建立索引，最后显式的设置MySQL引擎为InnoDB、自增主键初始值设置为1000、编码方式为utf8，并添加注释 MySQL默认的有很多引擎，只有InnoDB支持事务 可以插入几条数据12345678-- 初始化数据INSERT INTO seckill(name,number,start_time,end_time)VALUES (&apos;1000秒杀iPhone6S&apos;,100,&apos;2017-01-01 00:00:00&apos;,&apos;2017-01-02 00:00:00&apos;), (&apos;500秒杀MBP&apos;,200,&apos;2017-01-01 00:00:00&apos;,&apos;2017-01-02 00:00:00&apos;), (&apos;300秒杀iPad&apos;,100,&apos;2017-01-01 00:00:00&apos;,&apos;2017-01-02 00:00:00&apos;), (&apos;200秒杀小米MIX&apos;,300,&apos;2017-01-01 00:00:00&apos;,&apos;2017-01-02 00:00:00&apos;); 建立秒杀成功明细表，记录秒杀成功的用户信息和商品信息12345678910-- 秒杀成功明细表-- 用户登录认证相关的信息CREATE TABLE success_killed(`seckill_id` bigint NOT NULL COMMENT &apos;秒杀商品id&apos;,`user_phone` bigint NOT NULL COMMENT &apos;用户手机号&apos;,`state` tinyint NOT NULL DEFAULT -1 COMMENT &apos;状态标识: -1:无效 0:成功 1:已付款 2:已发货&apos;,`create_time` timestamp NOT NULL COMMENT &apos;创建时间&apos;,PRIMARY KEY(seckill_id,user_phone),/*联合主键 防止用户重复秒杀*/key idx_create_time(create_time))ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT=&apos;秒杀成功明细表&apos;; create_time就是秒杀成功的时间 因为id和phone可以唯一确定一个用户，所以这里要用到联合主键，防止用户重复秒杀一个商品，当然以后也可以为此做过滤 数据库的设计完成了，可以在控制台或者数据库管理工具输入上述SQL语句 DAO层相关接口编码先在java目录下建立两个包： org.seckill.entity：数据库对应的实体包 org.seckill.dao：DAO层接口包 在org.seckill.entity包下新建实体类Seckill，对应数据库中的seckill表12345678910111213141516171819202122232425public class Seckill &#123; private long seckillId; private String name; private int number; private Date startTime; private Date endTime; private Date createTime;@Override public String toString() &#123; return &quot;Seckill [seckillId=&quot; + seckillId + &quot;, name=&quot; + name + &quot;, number=&quot; + number + &quot;, startTime=&quot; + startTime+ &quot;, endTime=&quot; + endTime + &quot;, createTime=&quot; + createTime + &quot;]&quot;; &#125;&#125; 然后直接生成getter和setter方法，并复写toString方法 同样在org.seckill.entity包下新建实体类SuccessKilled，对应数据库中的success_killed表123456789101112131415161718192021public class SuccessKilled &#123; private long seckillId; private long userPhone; private short state; private Date createTime; private Seckill seckill;@Override public String toString() &#123; return &quot;SuccessKilled [seckillId=&quot; + seckillId + &quot;, userPhone=&quot; + userPhone + &quot;, state=&quot; + state + &quot;, createTime=&quot; + createTime + &quot;]&quot;; &#125;&#125; 直接生成getter和setter方法，并复写toString方法1private Seckill seckill; 这里实例化了一个Seckill类的对象，因为当用户成功秒杀一个商品时，可能需要完全拿到Seckill的实体 接着在org.seckill.dao包下新建接口SeckillDao，因为在数据库中seckill表记录的是秒杀商品的库存，所以当用户秒杀成功时，应该对数据库进行操作，也就是减库存1234567 /** * 减库存 * @param seckillId * @param killTime * @return 返回受影响的行数 */int reduceNumber(long seckillId, Date killTime); 还可以查询秒杀库存表的信息1234567891011121314 /** * 根据id查询秒杀对象 * @param seckillId 秒杀商品id * @return */Seckill queryById(long seckillId);/** * 根据偏移量查询秒杀商品列表 * @param offset 初始位置 * @param limit 查询个数 * @return */List&lt;Seckill&gt; queryAll(int offset, int limit); 偏移量就是用户可以设置初始位置offset，查询limit个数据 在org.seckill.dao包下新建接口SuccessKilledDao，当有一个用户在规定时间内成功秒杀一个商品时，进行记录，并且可以根据id查询相应的信息1234567891011121314/** * 插入购买明细，可过滤重复 * @param seckillId * @param userPhone * @return 返回受影响的行数，返回0表示没有插入数据 */int insertSuccessKilled(long seckillId, long userPhone);/** * 根据id查询SuccessKilled并携带Seckill实体 * @param seckill * @return */SuccessKilled queryByIdWithSeckill(long seckillId); 对于insertSuccessKilled方法，因为id和phone能唯一确定一个用户，所以当有重复出现时，不满足条件，insert语句不执行，返回0 如何设置条件，体现在SQL语句的书写，SQL语句写在下面要用到的MyBatis的xml文件中 至此，数据库对应的实体类以及DAO层的接口完成了，而且不用写接口的实现类，因为MyBatis把这些工作都承担了 那么这里就可以对DAO层有个初步的了解： DAO层提供了一些接口，这些接口是数据库对应的实体类(即Seckill类和SuccessKilled类)对数据库各种操作(例如:减库存、记录用户信息等)而封装的接口 基于MyBatis实现DAO层接口数据库与项目之间的映射之前已经实现了，数据库中的表对应org.seckill.entity包下的实体类，数据库中的列对应这些类中的属性，而这些对象要操作数据库，需要中间的映射过程，jdbc、MyBatis、Hibernate等都是工作在这一层，把数据库中的数据映射到对象中，并通过方法，操作数据库 在DAO层，我们已经写好了接口和方法，但是没有实现类，如果使用jdbc，就要手动的拿到数据库的连接，也要有实现接口的实现类，所以使用成熟的框架可以减少工作量，后期容易维护等许多好处 这里使用MyBatis，MyBatis对实现DAO层接口提供了两种方法： MyBatis内部有一个Mapper机制来自动实现DAO层接口 通过API编程的方式，MyBatis提供了很多API 显而易见，大部分都是选择自动实现DAO层接口，这种方法只需设计接口，不需要写实现类，通过配置MyBatis的xml文件，写好SQL语句，其他的工作MyBatis都会自动完成 MyBatis全局配置先在src\main\resources下建立一个MyBatis全局的配置文件mybatis-conf.xml，再新建一个mapper目录，用于存放MyBatis的SQL映射 打开MyBatis全局配置文件mybatis-conf.xml123&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt; 将这些内容复制到xml文件中，这些示例都可以在MyBatis官网上的参考文档中找到 然后配置一些属性123456789101112131415&lt;configuration&gt; &lt;!-- 配置全局属性 --&gt; &lt;settings&gt; &lt;!-- 使用jdbc的getGenerateKeys获取数据库自增主键值 --&gt; &lt;setting name=&quot;useGeneratedKeys&quot; value=&quot;true&quot;/&gt; &lt;!-- 使用列别名替换列名 默认为true --&gt; &lt;setting name=&quot;useColumnLabel&quot; value=&quot;true&quot;/&gt; &lt;!-- 开启驼峰命名转换:Table(create_time) -&gt; Entity(createTime) --&gt; &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt; &lt;/settings&gt;&lt;/configuration&gt; 使用列别名替换列名，MyBatis默认为true，MyBatis会自动的识别出列别名对应哪个列名，并赋值到entity实体属性中 前面提到，要实现DAO层的接口可以使用MyBatis的mapper机制，为DAO接口方法提供SQL语句配置，所以在mapper文件夹下创建相应接口的配置文件SeckillDao.xml和SuccessKilledDao.xml123&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt; 同样，这些内容都要添加到xml文件中 SeckillDao接口SQL语句配置打开SeckillDao.xml12345678910111213141516171819202122232425262728&lt;!-- 目的:为DAO接口方法提供SQL语句配置 --&gt;&lt;mapper namespace=&quot;org.seckill.dao.SeckillDao&quot;&gt; &lt;update id=&quot;reduceNumber&quot; &gt; update seckill set number = number - 1 where seckill_id = #&#123;seckillId&#125; and start_time &lt;![CDATA[ &lt;= ]]&gt; #&#123;startTime&#125; and end_time &gt;= #&#123;endTime&#125; and number &gt; 0; &lt;/update&gt; &lt;select id=&quot;queryById&quot; parameterType=&quot;long&quot; resultType=&quot;Seckill&quot;&gt; select seckill_id,name,number,start_time,end_time,create_time from seckill where seckill_id = #&#123;seckillId&#125; &lt;/select&gt; &lt;select id=&quot;queryAll&quot; resultType=&quot;Seckill&quot;&gt; select seckill_id,name,number,start_time,end_time,create_time from seckill order by create_time desc limit #&#123;offset&#125;,#&#123;limit&#125; &lt;/select&gt; &lt;/mapper&gt; 首先是mapper标签中的属性，namespace是对这个mapper的命名，也就是对这个xml文件的命名，这个命名必须在mapper目录下唯一，因为真正的项目中，mapper下的xml文件有很多，如果命名不唯一，MyBatis就不知道要调用哪个xml文件了，一般都是包名.接口名 接着逐个分析SQL语句12345678910 &lt;update id=&quot;reduceNumber&quot; &gt; update seckill set number = number - 1 where seckill_id = #&#123;seckillId&#125; and start_time &lt;![CDATA[ &lt;= ]]&gt; #&#123;killTime&#125; and end_time &gt;= #&#123;killTime&#125; and number &gt; 0;&lt;/update&gt; 因为要实现SeckillDao接口中的减库存的方法，所以使用update语句，id必须在该xml文件下唯一，一般为方法名1int reduceNumber(long seckillId, Date killTime);//SeckillDao接口中定义的方法 update标签中还有parameterType属性，这里可以不用写，MyBatis可以自动识别where后面有些限制条件，秒杀成功的时间要在规定时间内，要晚于开始时间，早于结束时间，否则update语句不会执行，当库存小于等于0时，也不执行update语句，数据返回类型为int，表示受影响的行数 至于下面这句1and start_time &lt;![CDATA[ &lt;= ]]&gt; #&#123;killTime&#125; 在w3school上有详细介绍： 术语 CDATA 指的是不应由 XML 解析器进行解析的文本数据（Unparsed Character Data）。在 XML 元素中，”&lt;” 和 “&amp;” 是非法的。“&lt;” 会产生错误，因为解析器会把该字符解释为新元素的开始。“&amp;” 也会产生错误，因为解析器会把该字符解释为字符实体的开始。某些文本，比如 JavaScript 代码，包含大量 “&lt;” 或 “&amp;” 字符。为了避免错误，可以将脚本代码定义为 CDATA。CDATA 部分中的所有内容都会被解析器忽略。CDATA 部分由 “&lt;![CDATA[“ 开始，由 “]]&gt;” 结束： 如果xml文件中仅有”&lt;”和”&amp;”，还是建议把它们替换为实体引用 接着写完实现其他方法的SQL语句12345&lt;select id=&quot;queryById&quot; parameterType=&quot;long&quot; resultType=&quot;Seckill&quot;&gt; select seckill_id,name,number,start_time,end_time,create_time from seckill where seckill_id = #&#123;seckillId&#125;&lt;/select&gt; queryById方法实质上是select查询语句，resultType返回的类型是Seckill类，因为自定义的类不在java.lang包下，所以一般是包名.类名，但是后面有方法可以省略包名，这里就只写类名 1Seckill queryById(long seckillId);//SeckillDao接口中定义的方法 parameterType为long类型，因为已经开启了驼峰转换，所以可以不适用as进行列名转换 最后是queryAll方法123456&lt;select id=&quot;queryAll&quot; resultType=&quot;Seckill&quot;&gt; select seckill_id,name,number,start_time,end_time,create_time from seckill order by create_time desc limit #&#123;offset&#125;,#&#123;limit&#125;&lt;/select&gt; 多个参数的话，可以不用给parameterType，结果按降序排列 1List&lt;Seckill&gt; queryAll(int offset, int limit);//SeckillDao接口中定义的方法 对于resultType，无论返回的是List还是Map，只要给出里面的类型就可以 SuccessKilledDao接口SQL语句配置打开SuccessKilledDao.xml123456789101112131415161718192021222324252627&lt;mapper namespace=&quot;org.seckill.dao.SuccessKilledDao&quot;&gt; &lt;insert id=&quot;insertSuccessKilled&quot;&gt; &lt;!-- 主键冲突:使用ignore忽略报错 insert不执行 返回0 --&gt; insert ignore into success_killed(seckill_id,user_phone) values (#&#123;seckillId&#125;,#&#123;userPhone&#125;) &lt;/insert&gt; &lt;select id=&quot;queryByIdWithSeckill&quot; resultType=&quot;SuccessKilled&quot;&gt; &lt;!-- 根据id查询SuccessKilled并携带Seckill实体 --&gt; &lt;!-- 如何告诉Mybatis把结果映射到SuccessKilled同时映射Seckill属性 --&gt; select sk.seckill_id, sk.user_phone, sk.create_time, sk.state, s.seckill_id &quot;seckill.seckill_id&quot;, s.name &quot;seckill.name&quot;, s.start_time &quot;seckill.start_time&quot;, s.end_time &quot;seckill.end_time&quot;, s.create_time &quot;seckill.create_time&quot; from success_killed sk inner join seckill s on sk.seckill_id = s.seckill_id where sk.seckill_id = #&#123;seckillId&#125; &lt;/select&gt; &lt;/mapper&gt; 简单说下insertSuccessKilled方法，在src\main\sql目录下有个schema.sql文件，里面是建表语句，在建立success_killed表的时候设置了一个联合主键，是防止用户重复秒杀的1PRIMARY KEY(seckill_id,user_phone) 所以id和phone只要有一个重复，insert语句就会报错，对于这种错误，其实只要不执行insert即可，不需要每次都报错，所以使用ignore关键字，当有主键冲突时，忽略报错，insert语句不会执行，结果返回0，说明没有插入数据 对于queryByIdWithSeckill方法1234567891011121314151617&lt;select id=&quot;queryByIdWithSeckill&quot; resultType=&quot;SuccessKilled&quot;&gt; &lt;!-- 根据id查询SuccessKilled并携带Seckill实体 --&gt; &lt;!-- 如何告诉Mybatis把结果映射到SuccessKilled同时映射Seckill属性 --&gt; select sk.seckill_id, sk.user_phone, sk.create_time, sk.state, s.seckill_id &quot;seckill.seckill_id&quot;, s.name &quot;seckill.name&quot;, s.start_time &quot;seckill.start_time&quot;, s.end_time &quot;seckill.end_time&quot;, s.create_time &quot;seckill.create_time&quot; from success_killed sk inner join seckill s on sk.seckill_id = s.seckill_id where sk.seckill_id = #&#123;seckillId&#125;&lt;/select&gt; 首先要明确的是这个方法的作用，是根据id查询SuccessKilled并携带Seckill实体 1SuccessKilled queryByIdWithSeckill(long seckillId);//SuccessKilledDao接口中定义的方法 返回SuccessKilled类型，在这个类中，实例化了Seckill类 123from success_killed skinner join seckill s on sk.seckill_id = s.seckill_idwhere sk.seckill_id = #&#123;seckillId&#125; from success_killed表，再使用内连接的方式使seckill表加入进来，on后面表示两个表通过相同的id进行连接，id的值为传进来的参数seckillId的值在MyBatis中可以忽略as关键字 那么如何告诉Mybatis把结果映射到SuccessKilled同时映射Seckill属性，首先可以得到sk表即success_killed表中的内容1234sk.seckill_id,sk.user_phone,sk.create_time,sk.state, sk.seckill_id虽然使用了别名， 但是MyBatis会忽略别名 ，所以MyBatis视为从sk表中的seckill_id列取数据，再返回数据到Java， 因为在MyBatis全局配置文件中开启了驼峰命名转换 ，所以seckill_id就变成了seckillId，赋值给相应的变量，这就是使用框架的好处 取到了数据，映射到了SuccessKilled中，又怎么同时映射Seckill属性呢？在SuccessKilled类中， 直接实例化了Seckill类 ，并生成了getter和setter方法success_killed和seckill两个表又通过内连接的方式进行了连接，所以可以直接在select后面这样写12345s.seckill_id &quot;seckill.seckill_id&quot;,s.name &quot;seckill.name&quot;,s.start_time &quot;seckill.start_time&quot;,s.end_time &quot;seckill.end_time&quot;,s.create_time &quot;seckill.create_time&quot; 前面说过，MyBatis会忽略别名，所以这里要在后面表明，这些列是来自哪个表的，这种写法实际是OGNL表达式，据说在Struts上很常见，但是在MyBatis的xml文件中也经常用到，所以还是要多了解下 到这里，MyBatis实现DAO层接口完成了 MyBatis与Spring整合在src\main\resources\spring\下新建一个xml文件spring-dao.xml，所有的DAO层配置都放在该文件中，关于配置文件的一些信息 在Spring官网上可以找在Spring Projects下面可以找到Spring Framework，选择版本，我在pom.xml文件中配置的MyBatis是4.3.5， 点击Reference，使用Ctrl+F搜索容器相关的点击7.2.Container overview，找到相关配置文件的示例，把beans标签内的所有内容复制到项目的spring-dao.xml中 然后开始配置整合Mybatis 配置数据库相关参数在src\main\resources\新建一个jdbc的配置文件jdbc.properties1234db.driver=com.mysql.jdbc.Driverdb.url=jdbc:mysql:///seckill?useUnicode=true&amp;characterEncoding=utf8db.user=rootdb.password= 在练习的项目中可以使用数据库的root用户，实际工作中不建议使用，我的数据库没有设置密码，所以password为空 这是获取数据库的一些配置，在url中1jdbc:mysql:///seckill 等价于 jdbc:mysql://127.0.0.1:3306/seckill 数据库默认的端口是3306，可写可不写，最后跟的是数据库的名字 至于后面的一些参数1useUnicode=true&amp;characterEncoding=utf8 使用Unicode编码，编码方式为utf8 有些版本的MySQL需要加密数据通道，同时需要检查服务器认证证书，在实际的工作中，这些根据实际情况配置，为了数据安全应该是尽可能的开启，作为练习的项目，就可以不用了1234Establishing SSL connection without server&apos;s identity verification is not recommended. According to MySQL 5.5.45+, 5.6.26+ and 5.7.6+ requirements SSL connection must be established by default if explicit option isn&apos;t set. For compliance with existing applications not using SSL the verifyServerCertificate property is set to &apos;false&apos;. You need either to explicitly disable SSL by setting useSSL=false, or set useSSL=true and provide truststore for server certificate verification. 如果有关于数据通道的加密和认证证书的问题，可以把下面的参数添加到jdbc的url后面12useSSL=true&amp;verifyServerCertificate=false在xml配置文件中配置数据库url时，要使用&amp;的转义字符也就是&amp; 然后打开spring-dao.xml文件，添加下面一行12&lt;!-- 配置数据库相关参数 --&gt;&lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt; 这时，如果你的IDE跟我的Eclipse一样不靠谱的话，还要自己手动添加几行内容，从Spring上找的xml配置只是最基本的，这次用到了context标签的内容，就要把下面的内容添加到beans的标签内12345678&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; 最终的内容就是这些，跟从Spring官网上复制的相比，这次多了三条关于context的配置 配置数据库连接池123456789101112131415161718&lt;!-- 配置数据库连接池 --&gt;&lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;!-- 配置连接池属性 --&gt; &lt;property name=&quot;driverClass&quot; value=&quot;$&#123;db.driver&#125;&quot;/&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;$&#123;db.url&#125;&quot;/&gt; &lt;property name=&quot;user&quot; value=&quot;$&#123;db.user&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;db.password&#125;&quot;/&gt; &lt;!-- 配置c3p0连接池的私有属性 --&gt; &lt;property name=&quot;maxPoolSize&quot; value=&quot;30&quot;/&gt; &lt;property name=&quot;minPoolSize&quot; value=&quot;10&quot;/&gt; &lt;!-- 关闭连接后不自动commit --&gt; &lt;property name=&quot;autoCommitOnClose&quot; value=&quot;false&quot;/&gt; &lt;!-- 获取连接超时时间 --&gt; &lt;property name=&quot;checkoutTimeout&quot; value=&quot;1000&quot;/&gt; &lt;!-- 获取连接失败重试次数 --&gt; &lt;property name=&quot;acquireRetryAttempts&quot; value=&quot;2&quot;/&gt;&lt;/bean&gt; 配置连接池的属性，结合jdbc.properties来写关于#{}与${}的区别，#{}在MyBatis的SQL语句配置中有着预编译的效果MyBatis会先把#{}视为“？”，等到执行预编译语句的时候就会换成对应的参数，这些MyBatis都自动实现了，而${}是没有预编译效果，在spring-dao的配置中参数要拿来就能用，不需要预编译，所以这里用${} 关于c3p0的私有属性，这就是根据实际情况设置的，还有很多，这里就简单的设置几条 12&lt;property name=&quot;maxPoolSize&quot; value=&quot;30&quot;/&gt;&lt;property name=&quot;minPoolSize&quot; value=&quot;10&quot;/&gt; 这是设置连接池中连接个数的最大值和最小值，默认最大值为15、最小值为3 12&lt;!-- 关闭连接后不自动commit --&gt; &lt;property name=&quot;autoCommitOnClose&quot; value=&quot;false&quot;/&gt; 对于autoCommitOnClose这个属性，就是当连接池的connection变为close的时候，实际是把连接对象放到池子当中，这个过程当中连接池会做相应的清理工作，如果把autoCommitOnClose设置为true，当我们调用close的时候会连接池会自动commit，不过本来这个属性c3p0默认为false，这里只是强调一下 1234&lt;!-- 获取连接超时时间 --&gt; &lt;property name=&quot;checkoutTimeout&quot; value=&quot;1000&quot;/&gt; &lt;!-- 获取连接失败重试次数 --&gt;&lt;property name=&quot;acquireRetryAttempts&quot; value=&quot;2&quot;/&gt; 对于连接超时的设置，在实际项目中很有必要，但是自己练习的时候可有可无，后面单元测试的时候，如果长时间都拿不到数据，每次都超时的时候，可以把这个属性注释掉，先测试程序能否正常运行 配置SqlSessionFactory对象1234567891011&lt;!-- 配置SqlSessionFactory对象 --&gt;&lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;!-- 注入数据库连接池 --&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;!-- 配置Mybatis全局配置文件 即mybatis-config.xml --&gt; &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;/&gt; &lt;!-- 扫描entity包 使用别名 省略包名 --&gt; &lt;property name=&quot;typeAliasesPackage&quot; value=&quot;org.seckill.entity&quot;/&gt; &lt;!-- 扫描SQL配置文件 即mapper目录下的xml文件 --&gt; &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:mapper/*.xml&quot;/&gt;&lt;/bean&gt; 前面两步，基本上每个项目都一样，从这开始，是MyBatis的配置，或者使用别的框架，对框架相应的配置使用typeAliasesPackage可以扫描指定的包，之前说到的resultType可以直接使用类名，就是因为这个属性，如果有多个包要扫描的话，使用分号隔开 对于使用classpath引入配置文件在java和resources目录下都是classpath的范围 配置扫描DAO接口包1234567&lt;!-- 配置扫描DAO接口包 动态实现DAO接口并注入到Spring容器中 --&gt;&lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt; &lt;!-- 注入sqlSessionFactory --&gt; &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot;/&gt; &lt;!-- 扫描DAO层下的接口 --&gt; &lt;property name=&quot;basePackage&quot; value=&quot;org.seckill.dao&quot;/&gt;&lt;/bean&gt; 在这个bean中，没有id，因为其他配置不会调用这个bean 对于注入sqlSessionFactory12&lt;!-- 注入sqlSessionFactory --&gt; &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot;/&gt; 为什么使用BeanName的方法？当MapperScannerConfigurer启动的时候，如果还没有加载jdbc.properties配置文件，这样拿到的dataSource就是错误的，因为#{}中的属性值还没有被替换，所以通过BeanName后处理的方式，当使用MyBatis的时候，才回去找对应的SQLSessionFactory对象，为了防止MapperScannerConfigurer提前初始化SQLSessionFactory 至此，所有的Mybatis和Spring整合的过程完成了 DAO层单元测试SeckillDao接口测试不同的IDE建立测试类的方式大同小异，下面是Eclipse的过程在项目列表中，右键SeckillDao.java文件，选择New-&gt;Other，搜索junit，选择JUnit Test Case，点击Next 最上面可以选择junit版本，这里使用junit4 紧接着改动的是Source folder，点击右边的按钮默认的是在sec/main/java目录下，应该改为src/test/java目录下，之前说过，单元测试的内容都在test目录下，点击Ok 先不要着急点Finish，点击Next，要测试所有的方法，点击Select All-&gt;Finish点击OK此时可以看到，单元测试已经添加成功 测试类建好后，先要配置Spring和junit整合，为了是junit启动时加载SpringIOC容器1234//Spring与junit整合@RunWith(SpringJUnit4ClassRunner.class)//告诉junit Spring配置文件的位置@ContextConfiguration(&#123;&quot;classpath:spring/spring-dao.xml&quot;&#125;) 在SeckillDaoTest方法上添加两个注解，Spring提供了一个RunWith接口 是在runner下面的，使用RunWith就实现了junit启动时加载SpringIOC容器还要告诉junit Spring配置文件的位置，使用ContextConfiguration注解，在加载SpringIOC容器的时候同时加载spring-dao.xml文件，验证Spring与MyBatis整合，数据库连接池是否OK等配置 要测试SeckillDao接口，就要先注入SeckillDao，直接实例化12//注入DAO实现类依赖@Autowiredprivate SeckillDao seckillDao; 视频上使用的是@Resource注解，会报错，找不到这个类，我也折腾了半天，索性直接用@Autowired注解 先测试queryById方法1234567891011121314151617181920212223242526272829//Spring与junit整合@RunWith(SpringJUnit4ClassRunner.class)//告诉junit Spring配置文件的位置@ContextConfiguration(&#123;&quot;classpath:spring/spring-dao.xml&quot;&#125;)public class SeckillDaoTest &#123; //注入DAO实现类依赖 @Autowired private SeckillDao seckillDao; @Test public void testReduceNumber() throws Exception &#123; fail(&quot;Not yet implemented&quot;); &#125; @Test public void testQueryById() throws Exception &#123; long id = 1000; Seckill seckill = seckillDao.queryById(id); System.out.println(seckill.getName()); System.out.println(seckill); &#125; @Test public void testQueryAll() throws Exception &#123; fail(&quot;Not yet implemented&quot;); &#125;&#125; 刚开始因为@Resource注解的问题一直找不到解决的方法，同时还有别的报错信息 12Class not found org.seckill.dao.SeckillDaoTestjava.lang.ClassNotFoundException: org.seckill.dao.SeckillDaoTest 一时间找不到头绪，看到有人说可能是maven的配置问题，有些依赖没配置上，我就按照给出的信息显示哪个jar包有问题，就删哪个，然后让maven自己下载，但是删了一个又报错另一个，加上下载速度慢，又是大半天浪费了 然后脑子一抽，索性把apache-maven-3.3.9.m2\repository目录下的依赖全删了，就这样删了又下，改版本，下了又删，两天时间就这样过去了 最后快崩溃了，决定还是按照视频中的版本来，毕竟对新版本的特性不熟悉，万一再出些幺蛾子，就该摔电脑了 然后一切又恢复到两天前的样子，@Resource依旧报错，把@Resource替换成@Autowired就没有报错，然后开始测试12345678严重: Caught exception while allowing TestExecutionListener [org.springframework.test.context.support.DependencyInjectionTestExecutionListener@105fece7] to prepare test instance [org.seckill.dao.SeckillDaoTest@52045dbe]java.lang.IllegalStateException: Failed to load ApplicationContextCaused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name &apos;sqlSessionFactory&apos; defined in class path resource [spring/spring-dao.xml]: Error setting property values; nested exception is org.springframework.beans.PropertyBatchUpdateException; nested PropertyAccessExceptions (1) are:PropertyAccessException 1: org.springframework.beans.MethodInvocationException: Property &apos;dataSource&apos; threw exception; nested exception is java.lang.NoClassDefFoundError: org/springframework/jdbc/datasource/TransactionAwareDataSourceProxyCaused by: org.springframework.beans.PropertyBatchUpdateException; nested PropertyAccessExceptions (1) are:PropertyAccessException 1: org.springframework.beans.MethodInvocationException: Property &apos;dataSource&apos; threw exception; nested exception is java.lang.NoClassDefFoundError: org/springframework/jdbc/datasource/TransactionAwareDataSourceProxy 眼看着文件中没有红叉，但就是测试不通过，打断点都不行，显然是加载的时候就有问题，这里面不断提到找不到一个类1java.lang.NoClassDefFoundError: org/springframework/jdbc/datasource/TransactionAwareDataSourceProxy 上网找了半天，都说在pom.xml中没有引入spring-jdbc的依赖，要是错误都这么显而易见，都皆大欢喜了，于是针对spring-jdbc，又是循环上面的过程，删了又下，下了又删，因为要和其他Spring配置版本相同，就没改版本，查了半天，下载了半天，依旧是找不到这个类 然后脑子又一抽，既然这个版本找不到，换个版本试试，也不能一下子就跳到新版本，万一与其他依赖不兼容就崩溃了，所以选择了4.1.7.RELEASE下个版本的最新版本4.2.9.RELEASE 结果就看到 快速的点开控制台看到id为1000的数据输出了，两天半的时间，快被玩的就要砸电脑了… 接下来测试queryAll方法1234567@Testpublic void testQueryAll() throws Exception &#123; List&lt;Seckill&gt; seckills = seckillDao.queryAll(0, 100); for(Seckill seckill : seckills)&#123; System.out.println(seckill); System.out.println();&#125; 然后就看到熟悉的junit红色进度条和错误信息1Caused by: org.apache.ibatis.binding.BindingException: Parameter &apos;offset&apos; not found. Available parameters are [0, 1, param1, param2] 参数到SQL语句绑定的时候出了问题，找不到参数offset，可以回顾下在mapper目录下的SQL语句配置文件SeckillDao.xml中的SQL是怎么写的123456&lt;select id=&quot;queryAll&quot; resultType=&quot;Seckill&quot;&gt; select seckill_id,name,number,start_time,end_time,create_time from seckill order by create_time desc limit #&#123;offset&#125;,#&#123;limit&#125;&lt;/select&gt; 对比着接口中的方法定义1List&lt;Seckill&gt; queryAll(int offset, int limit);//SeckillDao接口中方法的定义 既然接口中和SQL语句中都写的和明确，但是为什么绑定不了参数？原因就是 Java没有保存形参的记录 ，意味着在Java运行过程中1queryAll(int offset, int limit);等价于queryAll(arg0, arg1); 如果方法只有一个参数的话，就没关系，比如上面的queryById方法，所以当有多个参数的时候，就要告诉MyBatis，哪个参数对应在哪个位置，这时就要对接口中的方法做些改动，MyBatis提供了一个注解@Param1List&lt;Seckill&gt; queryAll(@Param(&quot;offset&quot;) int offset, @Param(&quot;limit&quot;) int limit); 使用注解的方式，告诉MyBatis，第一个参数叫offset，对应SQL语句中#{offset}，然后再测试queryAll方法 接着测试最后一个方法reduceNumber，先看一下接口中方法的定义1int reduceNumber(long seckillId, Date killTime); 传递两个参数，一个是long类型，一个是Date类型，返回int123456@Testpublic void testReduceNumber() throws Exception &#123; Date killTime = new Date(); int updateCount = seckillDao.reduceNumber(1000L, killTime); System.out.println(&quot;updateCount = &quot; + updateCount);&#125; 右键测试依然是上面的错误，修改接口中的方法即可可以看看控制台的输出，有利于理解整个运行过程1234DEBUG o.m.s.t.SpringManagedTransaction - JDBC Connection [com.mchange.v2.c3p0.impl.NewProxyConnection@75201592] will not be managed by SpringDEBUG o.s.dao.SeckillDao.reduceNumber - ==&gt; Preparing: update seckill set number = number - 1 where seckill_id = ? and start_time &lt;= ? and end_time &gt;= ? and number &gt; 0; DEBUG o.s.dao.SeckillDao.reduceNumber - ==&gt; Parameters: 1000(Long), 2017-01-06 21:12:04.444(Timestamp), 2017-01-06 21:12:04.444(Timestamp)DEBUG o.s.dao.SeckillDao.reduceNumber - &lt;== Updates: 0 首先是jdbc通过c3p0连接池拿到了数据库的连接，但是这个jdbc连接没有被Spring所托管，是从c3p0拿到的 然后控制台还输出了SQL语句1update seckill set number = number - 1 where seckill_id = ? and start_time &lt;= ? and end_time &gt;= ? and number &gt; 0; 之前写的#{}都被MyBatis视为占位符“？”，这就是因为#{}具有预编译的功能接着显示的是传递过去的参数，最后输出结果是0，为什么没有进行减库存的操作呢？因为早在创建数据库，插入数据的时候，就已经设置了秒杀时间段12345678-- 初始化数据INSERT INTO seckill(name,number,start_time,end_time)VALUES (&apos;1000秒杀iPhone6S&apos;,100,&apos;2017-01-01 00:00:00&apos;,&apos;2017-01-02 00:00:00&apos;), (&apos;500秒杀MBP&apos;,200,&apos;2017-01-01 00:00:00&apos;,&apos;2017-01-02 00:00:00&apos;), (&apos;300秒杀iPad&apos;,100,&apos;2017-01-01 00:00:00&apos;,&apos;2017-01-02 00:00:00&apos;), (&apos;200秒杀小米MIX&apos;,300,&apos;2017-01-01 00:00:00&apos;,&apos;2017-01-02 00:00:00&apos;); 秒杀活动从1号开始，2号结束，被maven的依赖折腾后，已经是6号了，所以不在秒杀时间段内，没有执行update语句 SeckillDao接口的测试就完成了 SuccessKilledDao接口测试使用Eclipse，根据上面的步骤，建立SuccessKilledDao接口的测试类123@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(&#123;&quot;classpath:spring/spring-dao.xml&quot;&#125;)public class SuccessKilledDaoTest 同样在类上面添加两个注解，Spring和junit整合的注解，然后是告诉Spring配置文件的位置 给这个测试类注入SuccessKilledDao12@Autowiredprivate SuccessKilledDao successKilledDao; 首先是insertSuccessKilled方法，先看看接口中方法的定义1int insertSuccessKilled(@Param(&quot;seckillId&quot;) long seckillId, @Param(&quot;userPhone&quot;) long userPhone); 传递的是多个参数，所以依旧需要改动，使用MyBatis的@Param注解 根据方法的定义，就可以写测试类了1234567@Testpublic void testInsertSuccessKilled() &#123; long id = 1000L; long phone = 13512345678L; int insertCount = successKilledDao.insertSuccessKilled(id, phone); System.out.println(&quot;insertCount = &quot; + insertCount);&#125; 返回1，说明成功插入信息之前说过，这个方法可以防止用户重复秒杀，所以可以不改变参数，再执行一次可以看到返回值是0，说明没有执行insert语句 这里还有点小问题1`state` tinyint NOT NULL DEFAULT -1 COMMENT &apos;状态标识: -1:无效 0:成功 1:已付款 2:已发货&apos;, 在开始的建表语句的时候，定义了state属性，是状态标识，既然能成功执行insertSuccessKilled方法，说明可以插入数据，那么state应该是0，所以要改动一下SQL语句12345&lt;insert id=&quot;insertSuccessKilled&quot;&gt; &lt;!-- 主键冲突:使用ignore忽略报错 insert不执行 返回0 --&gt; insert ignore into success_killed(seckill_id,user_phone,state) values (#&#123;seckillId&#125;,#&#123;userPhone&#125;,0)&lt;/insert&gt; 这样，再插入的数据的state就是0了 然后是queryByIdWithSeckill方法，先看方法的定义1SuccessKilled queryByIdWithSeckill(long seckillId); 由于之前考虑的不周到，这条语句还要有些改动 因为Seckill与SuccessKilled是一对多的关系，一个秒杀商品对应多个成功秒杀记录，那么想要查询某个人的秒杀记录的时候，上面的语句就行不通了，所以要添加一个参数1SuccessKilled queryByIdWithSeckill(@Param(&quot;seckillId&quot;) long seckillId, @Param(&quot;userPhone&quot;) long userPhone); 多了一个参数，所以还要加上@Param注解，同时，还要改动的地方是mapper目录下SuccessKilledDao.xml文件，找到与方法名相同的id1where sk.seckill_id = #&#123;seckillId&#125; and sk.user_phone = #&#123;userPhone&#125; 前面已经插入过一条成功秒杀的信息，所以还是用前面的数据12345678@Testpublic void testQueryByIdWithSeckill() &#123; long id = 1000L; long phone = 13512345678L; SuccessKilled successKilled = successKilledDao.queryByIdWithSeckill(id, phone); System.out.println(successKilled); System.out.println(successKilled.getSeckillId());&#125; 因为在SuccessKilled类中已经实例化了Seckill类，并生成了getter和setter方法，所以这里也可以取到Seckill对象 终于，所有的DAO层的工作已经完成了 DAO层编码后的一些思考回顾从最初的创建数据库开始，到设计接口、编写SQL语句、各种配置文件，中间没有写一行逻辑代码，DAO层的工作实际上演变为了 接口设计+SQL编写+配置文件 ，好处就是源代码和SQL进行了分离，方便Review，而DAO拼接等逻辑在Service层完成]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java笔记之高并发秒杀API(一)]]></title>
      <url>%2F2017%2F01%2F01%2FJava%E7%AC%94%E8%AE%B0%E4%B9%8B%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A7%92%E6%9D%80API-%E4%B8%80%2F</url>
      <content type="text"><![CDATA[本次系列的Java笔记是通过学习慕课网上的高并发秒杀API的视频而总结的，只是想通过写博客的过程能让自己梳理学习的过程，顺便时刻提醒自己。 本次秒杀API的项目的整体框架是Spring+Spring MVC+Mybatis，数据库为MySQL。 创建项目使用maven构建项目，因为使用命令行下载太慢，直接在Eclipse上使用maven来创建项目 如图： archetypeArtifactId: maven-archetype-webapp gtoupId: org.seckill artifactId: seckill 打开src\main\webapp\WEB-INF\web.xml 默认的Servlet版本是2.3，但是该版本下JSP的EL表达式是不工作的，这里需要更改版本 打开apache-tomcat-8.5.9\webapps\examples\WEB-INF\web.xml， 这是Tomcat的示例配置文件，将web-app标签内的内容覆盖到项目中的web.xml的web-app标签 Tomcat8.5.9给的示例文件显示使用的Servlet版本是3.1 依赖配置首先是补全文件，在src/main下添加两个文件夹java、test java： 存放java的源文件 test： 用于单元测试 也可以直接在Eclipse中右键项目名，点击Build Path-&gt;Order and Export 把需要的都选上，然后点击Apply，引入相关文件 接着打开pom.xml，配置依赖首先的改动是junit的版本，Eclipse自动生成的pom.xml的junit版本是3.8.1，这里改为4.11 因为junit3.0的版本是默认使用编程的方式运行的， 而4.0的版本是默认通过注解的方式来运行junit的接着就是补全项目的依赖 日志相关依赖本次项目采用slf4j+logback的组合 123456789101112131415161718&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;1.7.12&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-core&lt;/artifactId&gt; &lt;version&gt;1.1.1&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 实现slf4j接口并整合 --&gt;&lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.1.1&lt;/version&gt;&lt;/dependency&gt; logback的依赖有两个： logback-core、logback-classic logback-core： 实现logback核心的功能 logback-calssic： 实现slf4j接口并整合 数据库相关依赖包括数据库驱动，数据库连接池c3p0 12345678910111213&lt;!-- 数据库相关依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.35&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;c3p0&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.1.2&lt;/version&gt;&lt;/dependency&gt; DAO框架相关依赖——即Mybatis依赖Mybatis依赖主要有两个，一个是Mybatis自身的依赖，二是Mybatis和Spring整合的依赖 12345678910111213&lt;!-- DAO框架:Mybatis相关依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.3.0&lt;/version&gt;&lt;/dependency&gt;&lt;!-- Mybatis自身实现Spring的整合依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt;&lt;/dependency&gt; Servlet WEB相关依赖一些相关的标签、jstl、jackson等 123456789101112131415161718192021222324&lt;!-- Servlet Web相关依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;taglibs&lt;/groupId&gt; &lt;artifactId&gt;standard&lt;/artifactId&gt; &lt;version&gt;1.1.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.5.4&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt;&lt;/dependency&gt; Spring相关依赖Spring核心依赖包括spring-beans相关的依赖， 一些spring扩展依赖如:spring-context 123456789101112131415161718&lt;!-- Spring核心依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;4.1.7.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;4.1.7.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;4.1.7.RELEASE&lt;/version&gt;&lt;/dependency&gt; Spring Dao层的依赖 spring-jdbc： jdbc提供数据库相关的事务管理器 spring-tx： Spring的声明式事务 123456789101112&lt;!-- Spring Dao层的依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;4.1.7.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;4.1.7.RELEASE&lt;/version&gt;&lt;/dependency&gt; Spring WEB相关的依赖包括与Spring MVC相关的依赖 123456789101112&lt;!-- Spring WEB相关的依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;4.1.7.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;4.1.7.RELEASE&lt;/version&gt;&lt;/dependency&gt; Spring test相关的依赖123456789101112&lt;!-- Spring WEB相关的依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;4.1.7.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;4.1.7.RELEASE&lt;/version&gt;&lt;/dependency&gt; 虽然以上有些依赖版本相对有些老旧，但毕竟是练习，在不是特别熟悉这些框架和服务时，尽量按照视频中的版本来，不然等到测试时，会有各种玄学的问题，比较麻烦。在实际工作中应该前期就把要采用的服务的版本特性了解清楚。 业务分析 秒杀业务的核心就是对库存的处理，而难点主要是竞争 当n个用户同时竞争一个秒杀商品时，为了保证数据准确，没有出现数据的脏读、幻读等；保证商家没有出现超卖或者少卖的现象，就必然会用到事务+行级锁 至此，准备工作完成]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2016%2F12%2F30%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
  
  
</search>
