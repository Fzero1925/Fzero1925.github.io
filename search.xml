<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Java笔记之高并发秒杀API(二)]]></title>
      <url>%2F2017%2F01%2F05%2FJava%E7%AC%94%E8%AE%B0%E4%B9%8B%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A7%92%E6%9D%80API-%E4%BA%8C%2F</url>
      <content type="text"><![CDATA[本篇将完成DAO层的设计与开发，包括： 数据库、DAO实体与接口设计与编码 基于MyBatis实现DAO编程 MyBatis与Spring整合 DAO层单元测试 数据库设计与编码打开Eclipse，在src\main下建立一个文件夹sql，用于存放建表语句，新建一个SQL文件schema.sql，先创建一个秒杀商品的库存表 123456789101112131415161718192021-- 数据库初始化脚本-- 创建数据库CREATE DATABASE seckill;-- 使用数据库USE seckill;--创建秒杀库存表CREATE TABLE seckill(`seckill_id` bigint NOT NULL AUTO_INCREMENT COMMENT &apos;商品库存id&apos;,`name` varchar(120) NOT NULL COMMENT &apos;商品名称&apos;,`number` int NOT NULL COMMENT &apos;库存数量&apos;,`start_time` timestamp NOT NULL COMMENT &apos;秒杀开始时间&apos;,`end_time` timestamp NOT NULL COMMENT &apos;秒杀结束时间&apos;,`create_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &apos;创建时间&apos;,PRIMARY KEY (seckill_id),key idx_start_time(start_time),key idx_end_time(end_time),key idx_create_time(create_time))ENGINE=InnoDB AUTO_INCREMENT=1000 DEFAULT CHARSET=utf8 COMMENT=&apos;秒杀库存表&apos;; 主键为seckill_id，再单独对start_time、end_time、create_time三列单独建立索引，最后显式的设置MySQL引擎为InnoDB、自增主键初始值设置为1000、编码方式为utf8，并添加注释 MySQL默认的有很多引擎，只有InnoDB支持事务 可以插入几条数据12345678-- 初始化数据INSERT INTO seckill(name,number,start_time,end_time)VALUES (&apos;1000秒杀iPhone6S&apos;,100,&apos;2017-01-01 00:00:00&apos;,&apos;2017-01-02 00:00:00&apos;), (&apos;500秒杀MBP&apos;,200,&apos;2017-01-01 00:00:00&apos;,&apos;2017-01-02 00:00:00&apos;), (&apos;300秒杀iPad&apos;,100,&apos;2017-01-01 00:00:00&apos;,&apos;2017-01-02 00:00:00&apos;), (&apos;200秒杀小米MIX&apos;,300,&apos;2017-01-01 00:00:00&apos;,&apos;2017-01-02 00:00:00&apos;); 建立秒杀成功明细表，记录秒杀成功的用户信息和商品信息12345678910-- 秒杀成功明细表-- 用户登录认证相关的信息CREATE TABLE success_killed(`seckill_id` bigint NOT NULL COMMENT &apos;秒杀商品id&apos;,`user_phone` bigint NOT NULL COMMENT &apos;用户手机号&apos;,`state` tinyint NOT NULL DEFAULT -1 COMMENT &apos;状态标识: -1:无效 0:成功 1:已付款 2:已发货&apos;,`create_time` timestamp NOT NULL COMMENT &apos;创建时间&apos;,PRIMARY KEY(seckill_id,user_phone),/*联合主键 防止用户重复秒杀*/key idx_create_time(create_time))ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT=&apos;秒杀成功明细表&apos;; create_time就是秒杀成功的时间 因为id和phone可以唯一确定一个用户，所以这里要用到联合主键，防止用户重复秒杀一个商品，当然以后也可以为此做过滤 数据库的设计完成了，可以在控制台或者数据库管理工具输入上述SQL语句 DAO层相关接口编码先在java目录下建立两个包： org.seckill.entity：数据库对应的实体包 org.seckill.dao：DAO层接口包 在org.seckill.entity包下新建实体类Seckill，对应数据库中的seckill表12345678910111213141516171819202122232425public class Seckill &#123; private long seckillId; private String name; private int number; private Date startTime; private Date endTime; private Date createTime;@Override public String toString() &#123; return &quot;Seckill [seckillId=&quot; + seckillId + &quot;, name=&quot; + name + &quot;, number=&quot; + number + &quot;, startTime=&quot; + startTime+ &quot;, endTime=&quot; + endTime + &quot;, createTime=&quot; + createTime + &quot;]&quot;; &#125;&#125; 然后直接生成getter和setter方法，并复写toString方法 同样在org.seckill.entity包下新建实体类SuccessKilled，对应数据库中的success_killed表123456789101112131415161718192021public class SuccessKilled &#123; private long seckillId; private long userPhone; private short state; private Date createTime; private Seckill seckill;@Override public String toString() &#123; return &quot;SuccessKilled [seckillId=&quot; + seckillId + &quot;, userPhone=&quot; + userPhone + &quot;, state=&quot; + state + &quot;, createTime=&quot; + createTime + &quot;]&quot;; &#125;&#125; 直接生成getter和setter方法，并复写toString方法1private Seckill seckill; 这里实例化了一个Seckill类的对象，因为当用户成功秒杀一个商品时，可能需要完全拿到Seckill的实体 接着在org.seckill.dao包下新建接口SeckillDao，因为在数据库中seckill表记录的是秒杀商品的库存，所以当用户秒杀成功时，应该对数据库进行操作，也就是减库存1234567 /** * 减库存 * @param seckillId * @param killTime * @return 返回受影响的行数 */int reduceNumber(long seckillId, Date killTime); 还可以查询秒杀库存表的信息1234567891011121314 /** * 根据id查询秒杀对象 * @param seckillId 秒杀商品id * @return */Seckill queryById(long seckillId);/** * 根据偏移量查询秒杀商品列表 * @param offset 初始位置 * @param limit 查询个数 * @return */List&lt;Seckill&gt; queryAll(int offset, int limit); 偏移量就是用户可以设置初始位置offset，查询limit个数据 在org.seckill.dao包下新建接口SuccessKilledDao，当有一个用户在规定时间内成功秒杀一个商品时，进行记录，并且可以根据id查询相应的信息1234567891011121314/** * 插入购买明细，可过滤重复 * @param seckillId * @param userPhone * @return 返回受影响的行数，返回0表示没有插入数据 */int insertSuccessKilled(long seckillId, long userPhone);/** * 根据id查询SuccessKilled并携带Seckill实体 * @param seckill * @return */SuccessKilled queryByIdWithSeckill(long seckillId); 对于insertSuccessKilled方法，因为id和phone能唯一确定一个用户，所以当有重复出现时，不满足条件，insert语句不执行，返回0 如何设置条件，体现在SQL语句的书写，SQL语句写在下面要用到的MyBatis的xml文件中 至此，数据库对应的实体类以及DAO层的接口完成了，而且不用写接口的实现类，因为MyBatis把这些工作都承担了 那么这里就可以对DAO层有个初步的了解： DAO层提供了一些接口，这些接口是数据库对应的实体类(即Seckill类和SuccessKilled类)对数据库各种操作(例如:减库存、记录用户信息等)而封装的接口 基于MyBatis实现DAO层接口数据库与项目之间的映射之前已经实现了，数据库中的表对应org.seckill.entity包下的实体类，数据库中的列对应这些类中的属性，而这些对象要操作数据库，需要中间的映射过程，jdbc、MyBatis、Hibernate等都是工作在这一层，把数据库中的数据映射到对象中，并通过方法，操作数据库 在DAO层，我们已经写好了接口和方法，但是没有实现类，如果使用jdbc，就要手动的拿到数据库的连接，也要有实现接口的实现类，所以使用成熟的框架可以减少工作量，后期容易维护等许多好处 这里使用MyBatis，MyBatis对实现DAO层接口提供了两种方法： MyBatis内部有一个Mapper机制来自动实现DAO层接口 通过API编程的方式，MyBatis提供了很多API 显而易见，大部分都是选择自动实现DAO层接口，这种方法只需设计接口，不需要写实现类，通过配置MyBatis的xml文件，写好SQL语句，其他的工作MyBatis都会自动完成 MyBatis全局配置先在src\main\resources下建立一个MyBatis全局的配置文件mybatis-conf.xml，再新建一个mapper目录，用于存放MyBatis的SQL映射 打开MyBatis全局配置文件mybatis-conf.xml123&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt; 将这些内容复制到xml文件中，这些示例都可以在MyBatis官网上的参考文档中找到 然后配置一些属性123456789101112131415&lt;configuration&gt; &lt;!-- 配置全局属性 --&gt; &lt;settings&gt; &lt;!-- 使用jdbc的getGenerateKeys获取数据库自增主键值 --&gt; &lt;setting name=&quot;useGeneratedKeys&quot; value=&quot;true&quot;/&gt; &lt;!-- 使用列别名替换列名 默认为true --&gt; &lt;setting name=&quot;useColumnLabel&quot; value=&quot;true&quot;/&gt; &lt;!-- 开启驼峰命名转换:Table(create_time) -&gt; Entity(createTime) --&gt; &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt; &lt;/settings&gt;&lt;/configuration&gt; 使用列别名替换列名，MyBatis默认为true，MyBatis会自动的识别出列别名对应哪个列名，并赋值到entity实体属性中 前面提到，要实现DAO层的接口可以使用MyBatis的mapper机制，为DAO接口方法提供SQL语句配置，所以在mapper文件夹下创建相应接口的配置文件SeckillDao.xml和SuccessKilledDao.xml123&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt; 同样，这些内容都要添加到xml文件中 SeckillDao接口SQL语句配置打开SeckillDao.xml12345678910111213141516171819202122232425262728&lt;!-- 目的:为DAO接口方法提供SQL语句配置 --&gt;&lt;mapper namespace=&quot;org.seckill.dao.SeckillDao&quot;&gt; &lt;update id=&quot;reduceNumber&quot; &gt; update seckill set number = number - 1 where seckill_id = #&#123;seckillId&#125; and start_time &lt;![CDATA[ &lt;= ]]&gt; #&#123;startTime&#125; and end_time &gt;= #&#123;endTime&#125; and number &gt; 0; &lt;/update&gt; &lt;select id=&quot;queryById&quot; parameterType=&quot;long&quot; resultType=&quot;Seckill&quot;&gt; select seckill_id,name,number,start_time,end_time,create_time from seckill where seckill_id = #&#123;seckillId&#125; &lt;/select&gt; &lt;select id=&quot;queryAll&quot; resultType=&quot;Seckill&quot;&gt; select seckill_id,name,number,start_time,end_time,create_time from seckill order by create_time desc limit #&#123;offset&#125;,#&#123;limit&#125; &lt;/select&gt; &lt;/mapper&gt; 首先是mapper标签中的属性，namespace是对这个mapper的命名，也就是对这个xml文件的命名，这个命名必须在mapper目录下唯一，因为真正的项目中，mapper下的xml文件有很多，如果命名不唯一，MyBatis就不知道要调用哪个xml文件了，一般都是包名.接口名 接着逐个分析SQL语句12345678910 &lt;update id=&quot;reduceNumber&quot; &gt; update seckill set number = number - 1 where seckill_id = #&#123;seckillId&#125; and start_time &lt;![CDATA[ &lt;= ]]&gt; #&#123;killTime&#125; and end_time &gt;= #&#123;killTime&#125; and number &gt; 0;&lt;/update&gt; 因为要实现SeckillDao接口中的减库存的方法，所以使用update语句，id必须在该xml文件下唯一，一般为方法名1int reduceNumber(long seckillId, Date killTime);//SeckillDao接口中定义的方法 update标签中还有parameterType属性，这里可以不用写，MyBatis可以自动识别where后面有些限制条件，秒杀成功的时间要在规定时间内，要晚于开始时间，早于结束时间，否则update语句不会执行，当库存小于等于0时，也不执行update语句，数据返回类型为int，表示受影响的行数 至于下面这句1and start_time &lt;![CDATA[ &lt;= ]]&gt; #&#123;killTime&#125; 在w3school上有详细介绍： 术语 CDATA 指的是不应由 XML 解析器进行解析的文本数据（Unparsed Character Data）。在 XML 元素中，”&lt;” 和 “&amp;” 是非法的。“&lt;” 会产生错误，因为解析器会把该字符解释为新元素的开始。“&amp;” 也会产生错误，因为解析器会把该字符解释为字符实体的开始。某些文本，比如 JavaScript 代码，包含大量 “&lt;” 或 “&amp;” 字符。为了避免错误，可以将脚本代码定义为 CDATA。CDATA 部分中的所有内容都会被解析器忽略。CDATA 部分由 “&lt;![CDATA[“ 开始，由 “]]&gt;” 结束： 如果xml文件中仅有”&lt;”和”&amp;”，还是建议把它们替换为实体引用 接着写完实现其他方法的SQL语句12345&lt;select id=&quot;queryById&quot; parameterType=&quot;long&quot; resultType=&quot;Seckill&quot;&gt; select seckill_id,name,number,start_time,end_time,create_time from seckill where seckill_id = #&#123;seckillId&#125;&lt;/select&gt; queryById方法实质上是select查询语句，resultType返回的类型是Seckill类，因为自定义的类不在java.lang包下，所以一般是包名.类名，但是后面有方法可以省略包名，这里就只写类名 1Seckill queryById(long seckillId);//SeckillDao接口中定义的方法 parameterType为long类型，因为已经开启了驼峰转换，所以可以不适用as进行列名转换 最后是queryAll方法123456&lt;select id=&quot;queryAll&quot; resultType=&quot;Seckill&quot;&gt; select seckill_id,name,number,start_time,end_time,create_time from seckill order by create_time desc limit #&#123;offset&#125;,#&#123;limit&#125;&lt;/select&gt; 多个参数的话，可以不用给parameterType，结果按降序排列 1List&lt;Seckill&gt; queryAll(int offset, int limit);//SeckillDao接口中定义的方法 对于resultType，无论返回的是List还是Map，只要给出里面的类型就可以 SuccessKilledDao接口SQL语句配置打开SuccessKilledDao.xml123456789101112131415161718192021222324252627&lt;mapper namespace=&quot;org.seckill.dao.SuccessKilledDao&quot;&gt; &lt;insert id=&quot;insertSuccessKilled&quot;&gt; &lt;!-- 主键冲突:使用ignore忽略报错 insert不执行 返回0 --&gt; insert ignore into success_killed(seckill_id,user_phone) values (#&#123;seckillId&#125;,#&#123;userPhone&#125;) &lt;/insert&gt; &lt;select id=&quot;queryByIdWithSeckill&quot; resultType=&quot;SuccessKilled&quot;&gt; &lt;!-- 根据id查询SuccessKilled并携带Seckill实体 --&gt; &lt;!-- 如何告诉Mybatis把结果映射到SuccessKilled同时映射Seckill属性 --&gt; select sk.seckill_id, sk.user_phone, sk.create_time, sk.state, s.seckill_id &quot;seckill.seckill_id&quot;, s.name &quot;seckill.name&quot;, s.start_time &quot;seckill.start_time&quot;, s.end_time &quot;seckill.end_time&quot;, s.create_time &quot;seckill.create_time&quot; from success_killed sk inner join seckill s on sk.seckill_id = s.seckill_id where sk.seckill_id = #&#123;seckillId&#125; &lt;/select&gt; &lt;/mapper&gt; 简单说下insertSuccessKilled方法，在src\main\sql目录下有个schema.sql文件，里面是建表语句，在建立success_killed表的时候设置了一个联合主键，是防止用户重复秒杀的1PRIMARY KEY(seckill_id,user_phone) 所以id和phone只要有一个重复，insert语句就会报错，对于这种错误，其实只要不执行insert即可，不需要每次都报错，所以使用ignore关键字，当有主键冲突时，忽略报错，insert语句不会执行，结果返回0，说明没有插入数据 对于queryByIdWithSeckill方法1234567891011121314151617&lt;select id=&quot;queryByIdWithSeckill&quot; resultType=&quot;SuccessKilled&quot;&gt; &lt;!-- 根据id查询SuccessKilled并携带Seckill实体 --&gt; &lt;!-- 如何告诉Mybatis把结果映射到SuccessKilled同时映射Seckill属性 --&gt; select sk.seckill_id, sk.user_phone, sk.create_time, sk.state, s.seckill_id &quot;seckill.seckill_id&quot;, s.name &quot;seckill.name&quot;, s.start_time &quot;seckill.start_time&quot;, s.end_time &quot;seckill.end_time&quot;, s.create_time &quot;seckill.create_time&quot; from success_killed sk inner join seckill s on sk.seckill_id = s.seckill_id where sk.seckill_id = #&#123;seckillId&#125;&lt;/select&gt; 首先要明确的是这个方法的作用，是根据id查询SuccessKilled并携带Seckill实体 1SuccessKilled queryByIdWithSeckill(long seckillId);//SuccessKilledDao接口中定义的方法 返回SuccessKilled类型，在这个类中，实例化了Seckill类 123from success_killed skinner join seckill s on sk.seckill_id = s.seckill_idwhere sk.seckill_id = #&#123;seckillId&#125; from success_killed表，再使用内连接的方式使seckill表加入进来，on后面表示两个表通过相同的id进行连接，id的值为传进来的参数seckillId的值在MyBatis中可以忽略as关键字 那么如何告诉Mybatis把结果映射到SuccessKilled同时映射Seckill属性，首先可以得到sk表即success_killed表中的内容1234sk.seckill_id,sk.user_phone,sk.create_time,sk.state, sk.seckill_id虽然使用了别名， 但是MyBatis会忽略别名 ，所以MyBatis视为从sk表中的seckill_id列取数据，再返回数据到Java， 因为在MyBatis全局配置文件中开启了驼峰命名转换 ，所以seckill_id就变成了seckillId，赋值给相应的变量，这就是使用框架的好处 取到了数据，映射到了SuccessKilled中，又怎么同时映射Seckill属性呢？在SuccessKilled类中， 直接实例化了Seckill类 ，并生成了getter和setter方法success_killed和seckill两个表又通过内连接的方式进行了连接，所以可以直接在select后面这样写12345s.seckill_id &quot;seckill.seckill_id&quot;,s.name &quot;seckill.name&quot;,s.start_time &quot;seckill.start_time&quot;,s.end_time &quot;seckill.end_time&quot;,s.create_time &quot;seckill.create_time&quot; 前面说过，MyBatis会忽略别名，所以这里要在后面表明，这些列是来自哪个表的，这种写法实际是OGNL表达式，据说在Struts上很常见，但是在MyBatis的xml文件中也经常用到，所以还是要多了解下 到这里，MyBatis实现DAO层接口完成了 MyBatis与Spring整合在src\main\resources\spring\下新建一个xml文件spring-dao.xml，所有的DAO层配置都放在该文件中，关于配置文件的一些信息 在Spring官网上可以找在Spring Projects下面可以找到Spring Framework，选择版本，我在pom.xml文件中配置的MyBatis是4.3.5， 点击Reference，使用Ctrl+F搜索容器相关的点击7.2.Container overview，找到相关配置文件的示例，把beans标签内的所有内容复制到项目的spring-dao.xml中 然后开始配置整合Mybatis 配置数据库相关参数在src\main\resources\新建一个jdbc的配置文件jdbc.properties1234db.driver=com.mysql.jdbc.Driverdb.url=jdbc:mysql:///seckill?useUnicode=true&amp;characterEncoding=utf8db.user=rootdb.password= 在练习的项目中可以使用数据库的root用户，实际工作中不建议使用，我的数据库没有设置密码，所以password为空 这是获取数据库的一些配置，在url中1jdbc:mysql:///seckill 等价于 jdbc:mysql://127.0.0.1:3306/seckill 数据库默认的端口是3306，可写可不写，最后跟的是数据库的名字 至于后面的一些参数1useUnicode=true&amp;characterEncoding=utf8 使用Unicode编码，编码方式为utf8 有些版本的MySQL需要加密数据通道，同时需要检查服务器认证证书，在实际的工作中，这些根据实际情况配置，为了数据安全应该是尽可能的开启，作为练习的项目，就可以不用了1234Establishing SSL connection without server&apos;s identity verification is not recommended. According to MySQL 5.5.45+, 5.6.26+ and 5.7.6+ requirements SSL connection must be established by default if explicit option isn&apos;t set. For compliance with existing applications not using SSL the verifyServerCertificate property is set to &apos;false&apos;. You need either to explicitly disable SSL by setting useSSL=false, or set useSSL=true and provide truststore for server certificate verification. 如果有关于数据通道的加密和认证证书的问题，可以把下面的参数添加到jdbc的url后面12useSSL=true&amp;verifyServerCertificate=false在xml配置文件中配置数据库url时，要使用&amp;的转义字符也就是&amp; 然后打开spring-dao.xml文件，添加下面一行12&lt;!-- 配置数据库相关参数 --&gt;&lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt; 这时，如果你的IDE跟我的Eclipse一样不靠谱的话，还要自己手动添加几行内容，从Spring上找的xml配置只是最基本的，这次用到了context标签的内容，就要把下面的内容添加到beans的标签内12345678&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; 最终的内容就是这些，跟从Spring官网上复制的相比，这次多了三条关于context的配置 配置数据库连接池123456789101112131415161718&lt;!-- 配置数据库连接池 --&gt;&lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;!-- 配置连接池属性 --&gt; &lt;property name=&quot;driverClass&quot; value=&quot;$&#123;db.driver&#125;&quot;/&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;$&#123;db.url&#125;&quot;/&gt; &lt;property name=&quot;user&quot; value=&quot;$&#123;db.user&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;db.password&#125;&quot;/&gt; &lt;!-- 配置c3p0连接池的私有属性 --&gt; &lt;property name=&quot;maxPoolSize&quot; value=&quot;30&quot;/&gt; &lt;property name=&quot;minPoolSize&quot; value=&quot;10&quot;/&gt; &lt;!-- 关闭连接后不自动commit --&gt; &lt;property name=&quot;autoCommitOnClose&quot; value=&quot;false&quot;/&gt; &lt;!-- 获取连接超时时间 --&gt; &lt;property name=&quot;checkoutTimeout&quot; value=&quot;1000&quot;/&gt; &lt;!-- 获取连接失败重试次数 --&gt; &lt;property name=&quot;acquireRetryAttempts&quot; value=&quot;2&quot;/&gt;&lt;/bean&gt; 配置连接池的属性，结合jdbc.properties来写关于#{}与${}的区别，#{}在MyBatis的SQL语句配置中有着预编译的效果MyBatis会先把#{}视为“？”，等到执行预编译语句的时候就会换成对应的参数，这些MyBatis都自动实现了，而${}是没有预编译效果，在spring-dao的配置中参数要拿来就能用，不需要预编译，所以这里用${} 关于c3p0的私有属性，这就是根据实际情况设置的，还有很多，这里就简单的设置几条 12&lt;property name=&quot;maxPoolSize&quot; value=&quot;30&quot;/&gt;&lt;property name=&quot;minPoolSize&quot; value=&quot;10&quot;/&gt; 这是设置连接池中连接个数的最大值和最小值，默认最大值为15、最小值为3 12&lt;!-- 关闭连接后不自动commit --&gt; &lt;property name=&quot;autoCommitOnClose&quot; value=&quot;false&quot;/&gt; 对于autoCommitOnClose这个属性，就是当连接池的connection变为close的时候，实际是把连接对象放到池子当中，这个过程当中连接池会做相应的清理工作，如果把autoCommitOnClose设置为true，当我们调用close的时候会连接池会自动commit，不过本来这个属性c3p0默认为false，这里只是强调一下 1234&lt;!-- 获取连接超时时间 --&gt; &lt;property name=&quot;checkoutTimeout&quot; value=&quot;1000&quot;/&gt; &lt;!-- 获取连接失败重试次数 --&gt;&lt;property name=&quot;acquireRetryAttempts&quot; value=&quot;2&quot;/&gt; 对于连接超时的设置，在实际项目中很有必要，但是自己练习的时候可有可无，后面单元测试的时候，如果长时间都拿不到数据，每次都超时的时候，可以把这个属性注释掉，先测试程序能否正常运行 配置SqlSessionFactory对象1234567891011&lt;!-- 配置SqlSessionFactory对象 --&gt;&lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;!-- 注入数据库连接池 --&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;!-- 配置Mybatis全局配置文件 即mybatis-config.xml --&gt; &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;/&gt; &lt;!-- 扫描entity包 使用别名 省略包名 --&gt; &lt;property name=&quot;typeAliasesPackage&quot; value=&quot;org.seckill.entity&quot;/&gt; &lt;!-- 扫描SQL配置文件 即mapper目录下的xml文件 --&gt; &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:mapper/*.xml&quot;/&gt;&lt;/bean&gt; 前面两步，基本上每个项目都一样，从这开始，是MyBatis的配置，或者使用别的框架，对框架相应的配置使用typeAliasesPackage可以扫描指定的包，之前说到的resultType可以直接使用类名，就是因为这个属性，如果有多个包要扫描的话，使用分号隔开 对于使用classpath引入配置文件在java和resources目录下都是classpath的范围 配置扫描DAO接口包1234567&lt;!-- 配置扫描DAO接口包 动态实现DAO接口并注入到Spring容器中 --&gt;&lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt; &lt;!-- 注入sqlSessionFactory --&gt; &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot;/&gt; &lt;!-- 扫描DAO层下的接口 --&gt; &lt;property name=&quot;basePackage&quot; value=&quot;org.seckill.dao&quot;/&gt;&lt;/bean&gt; 在这个bean中，没有id，因为其他配置不会调用这个bean 对于注入sqlSessionFactory12&lt;!-- 注入sqlSessionFactory --&gt; &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot;/&gt; 为什么使用BeanName的方法？当MapperScannerConfigurer启动的时候，如果还没有加载jdbc.properties配置文件，这样拿到的dataSource就是错误的，因为#{}中的属性值还没有被替换，所以通过BeanName后处理的方式，当使用MyBatis的时候，才回去找对应的SQLSessionFactory对象，为了防止MapperScannerConfigurer提前初始化SQLSessionFactory 至此，所有的Mybatis和Spring整合的过程完成了 DAO层单元测试SeckillDao接口测试不同的IDE建立测试类的方式大同小异，下面是Eclipse的过程在项目列表中，右键SeckillDao.java文件，选择New-&gt;Other，搜索junit，选择JUnit Test Case，点击Next 最上面可以选择junit版本，这里使用junit4 紧接着改动的是Source folder，点击右边的按钮默认的是在sec/main/java目录下，应该改为src/test/java目录下，之前说过，单元测试的内容都在test目录下，点击Ok 先不要着急点Finish，点击Next，要测试所有的方法，点击Select All-&gt;Finish点击OK此时可以看到，单元测试已经添加成功 测试类建好后，先要配置Spring和junit整合，为了是junit启动时加载SpringIOC容器1234//Spring与junit整合@RunWith(SpringJUnit4ClassRunner.class)//告诉junit Spring配置文件的位置@ContextConfiguration(&#123;&quot;classpath:spring/spring-dao.xml&quot;&#125;) 在SeckillDaoTest方法上添加两个注解，Spring提供了一个RunWith接口 是在runner下面的，使用RunWith就实现了junit启动时加载SpringIOC容器还要告诉junit Spring配置文件的位置，使用ContextConfiguration注解，在加载SpringIOC容器的时候同时加载spring-dao.xml文件，验证Spring与MyBatis整合，数据库连接池是否OK等配置 要测试SeckillDao接口，就要先注入SeckillDao，直接实例化12//注入DAO实现类依赖@Autowiredprivate SeckillDao seckillDao; 视频上使用的是@Resource注解，会报错，找不到这个类，我也折腾了半天，索性直接用@Autowired注解 先测试queryById方法1234567891011121314151617181920212223242526272829//Spring与junit整合@RunWith(SpringJUnit4ClassRunner.class)//告诉junit Spring配置文件的位置@ContextConfiguration(&#123;&quot;classpath:spring/spring-dao.xml&quot;&#125;)public class SeckillDaoTest &#123; //注入DAO实现类依赖 @Autowired private SeckillDao seckillDao; @Test public void testReduceNumber() throws Exception &#123; fail(&quot;Not yet implemented&quot;); &#125; @Test public void testQueryById() throws Exception &#123; long id = 1000; Seckill seckill = seckillDao.queryById(id); System.out.println(seckill.getName()); System.out.println(seckill); &#125; @Test public void testQueryAll() throws Exception &#123; fail(&quot;Not yet implemented&quot;); &#125;&#125; 刚开始因为@Resource注解的问题一直找不到解决的方法，同时还有别的报错信息 12Class not found org.seckill.dao.SeckillDaoTestjava.lang.ClassNotFoundException: org.seckill.dao.SeckillDaoTest 一时间找不到头绪，看到有人说可能是maven的配置问题，有些依赖没配置上，我就按照给出的信息显示哪个jar包有问题，就删哪个，然后让maven自己下载，但是删了一个又报错另一个，加上下载速度慢，又是大半天浪费了 然后脑子一抽，索性把apache-maven-3.3.9.m2\repository目录下的依赖全删了，就这样删了又下，改版本，下了又删，两天时间就这样过去了 最后快崩溃了，决定还是按照视频中的版本来，毕竟对新版本的特性不熟悉，万一再出些幺蛾子，就该摔电脑了 然后一切又恢复到两天前的样子，@Resource依旧报错，把@Resource替换成@Autowired就没有报错，然后开始测试12345678严重: Caught exception while allowing TestExecutionListener [org.springframework.test.context.support.DependencyInjectionTestExecutionListener@105fece7] to prepare test instance [org.seckill.dao.SeckillDaoTest@52045dbe]java.lang.IllegalStateException: Failed to load ApplicationContextCaused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name &apos;sqlSessionFactory&apos; defined in class path resource [spring/spring-dao.xml]: Error setting property values; nested exception is org.springframework.beans.PropertyBatchUpdateException; nested PropertyAccessExceptions (1) are:PropertyAccessException 1: org.springframework.beans.MethodInvocationException: Property &apos;dataSource&apos; threw exception; nested exception is java.lang.NoClassDefFoundError: org/springframework/jdbc/datasource/TransactionAwareDataSourceProxyCaused by: org.springframework.beans.PropertyBatchUpdateException; nested PropertyAccessExceptions (1) are:PropertyAccessException 1: org.springframework.beans.MethodInvocationException: Property &apos;dataSource&apos; threw exception; nested exception is java.lang.NoClassDefFoundError: org/springframework/jdbc/datasource/TransactionAwareDataSourceProxy 眼看着文件中没有红叉，但就是测试不通过，打断点都不行，显然是加载的时候就有问题，这里面不断提到找不到一个类1java.lang.NoClassDefFoundError: org/springframework/jdbc/datasource/TransactionAwareDataSourceProxy 上网找了半天，都说在pom.xml中没有引入spring-jdbc的依赖，要是错误都这么显而易见，都皆大欢喜了，于是针对spring-jdbc，又是循环上面的过程，删了又下，下了又删，因为要和其他Spring配置版本相同，就没改版本，查了半天，下载了半天，依旧是找不到这个类 然后脑子又一抽，既然这个版本找不到，换个版本试试，也不能一下子就跳到新版本，万一与其他依赖不兼容就崩溃了，所以选择了4.1.7.RELEASE下个版本的最新版本4.2.9.RELEASE 结果就看到 快速的点开控制台看到id为1000的数据输出了，两天半的时间，快被玩的就要砸电脑了… 接下来测试queryAll方法1234567@Testpublic void testQueryAll() throws Exception &#123; List&lt;Seckill&gt; seckills = seckillDao.queryAll(0, 100); for(Seckill seckill : seckills)&#123; System.out.println(seckill); System.out.println();&#125; 然后就看到熟悉的junit红色进度条和错误信息1Caused by: org.apache.ibatis.binding.BindingException: Parameter &apos;offset&apos; not found. Available parameters are [0, 1, param1, param2] 参数到SQL语句绑定的时候出了问题，找不到参数offset，可以回顾下在mapper目录下的SQL语句配置文件SeckillDao.xml中的SQL是怎么写的123456&lt;select id=&quot;queryAll&quot; resultType=&quot;Seckill&quot;&gt; select seckill_id,name,number,start_time,end_time,create_time from seckill order by create_time desc limit #&#123;offset&#125;,#&#123;limit&#125;&lt;/select&gt; 对比着接口中的方法定义1List&lt;Seckill&gt; queryAll(int offset, int limit);//SeckillDao接口中方法的定义 既然接口中和SQL语句中都写的和明确，但是为什么绑定不了参数？原因就是 Java没有保存形参的记录 ，意味着在Java运行过程中1queryAll(int offset, int limit);等价于queryAll(arg0, arg1); 如果方法只有一个参数的话，就没关系，比如上面的queryById方法，所以当有多个参数的时候，就要告诉MyBatis，哪个参数对应在哪个位置，这时就要对接口中的方法做些改动，MyBatis提供了一个注解@Param1List&lt;Seckill&gt; queryAll(@Param(&quot;offset&quot;) int offset, @Param(&quot;limit&quot;) int limit); 使用注解的方式，告诉MyBatis，第一个参数叫offset，对应SQL语句中#{offset}，然后再测试queryAll方法 接着测试最后一个方法reduceNumber，先看一下接口中方法的定义1int reduceNumber(long seckillId, Date killTime); 传递两个参数，一个是long类型，一个是Date类型，返回int123456@Testpublic void testReduceNumber() throws Exception &#123; Date killTime = new Date(); int updateCount = seckillDao.reduceNumber(1000L, killTime); System.out.println(&quot;updateCount = &quot; + updateCount);&#125; 右键测试依然是上面的错误，修改接口中的方法即可可以看看控制台的输出，有利于理解整个运行过程1234DEBUG o.m.s.t.SpringManagedTransaction - JDBC Connection [com.mchange.v2.c3p0.impl.NewProxyConnection@75201592] will not be managed by SpringDEBUG o.s.dao.SeckillDao.reduceNumber - ==&gt; Preparing: update seckill set number = number - 1 where seckill_id = ? and start_time &lt;= ? and end_time &gt;= ? and number &gt; 0; DEBUG o.s.dao.SeckillDao.reduceNumber - ==&gt; Parameters: 1000(Long), 2017-01-06 21:12:04.444(Timestamp), 2017-01-06 21:12:04.444(Timestamp)DEBUG o.s.dao.SeckillDao.reduceNumber - &lt;== Updates: 0 首先是jdbc通过c3p0连接池拿到了数据库的连接，但是这个jdbc连接没有被Spring所托管，是从c3p0拿到的 然后控制台还输出了SQL语句1update seckill set number = number - 1 where seckill_id = ? and start_time &lt;= ? and end_time &gt;= ? and number &gt; 0; 之前写的#{}都被MyBatis视为占位符“？”，这就是因为#{}具有预编译的功能接着显示的是传递过去的参数，最后输出结果是0，为什么没有进行减库存的操作呢？因为早在创建数据库，插入数据的时候，就已经设置了秒杀时间段12345678-- 初始化数据INSERT INTO seckill(name,number,start_time,end_time)VALUES (&apos;1000秒杀iPhone6S&apos;,100,&apos;2017-01-01 00:00:00&apos;,&apos;2017-01-02 00:00:00&apos;), (&apos;500秒杀MBP&apos;,200,&apos;2017-01-01 00:00:00&apos;,&apos;2017-01-02 00:00:00&apos;), (&apos;300秒杀iPad&apos;,100,&apos;2017-01-01 00:00:00&apos;,&apos;2017-01-02 00:00:00&apos;), (&apos;200秒杀小米MIX&apos;,300,&apos;2017-01-01 00:00:00&apos;,&apos;2017-01-02 00:00:00&apos;); 秒杀活动从1号开始，2号结束，被maven的依赖折腾后，已经是6号了，所以不在秒杀时间段内，没有执行update语句 SeckillDao接口的测试就完成了 SuccessKilledDao接口测试使用Eclipse，根据上面的步骤，建立SuccessKilledDao接口的测试类123@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(&#123;&quot;classpath:spring/spring-dao.xml&quot;&#125;)public class SuccessKilledDaoTest 同样在类上面添加两个注解，Spring和junit整合的注解，然后是告诉Spring配置文件的位置 给这个测试类注入SuccessKilledDao12@Autowiredprivate SuccessKilledDao successKilledDao; 首先是insertSuccessKilled方法，先看看接口中方法的定义1int insertSuccessKilled(@Param(&quot;seckillId&quot;) long seckillId, @Param(&quot;userPhone&quot;) long userPhone); 传递的是多个参数，所以依旧需要改动，使用MyBatis的@Param注解 根据方法的定义，就可以写测试类了1234567@Testpublic void testInsertSuccessKilled() &#123; long id = 1000L; long phone = 13512345678L; int insertCount = successKilledDao.insertSuccessKilled(id, phone); System.out.println(&quot;insertCount = &quot; + insertCount);&#125; 返回1，说明成功插入信息之前说过，这个方法可以防止用户重复秒杀，所以可以不改变参数，再执行一次可以看到返回值是0，说明没有执行insert语句 这里还有点小问题1`state` tinyint NOT NULL DEFAULT -1 COMMENT &apos;状态标识: -1:无效 0:成功 1:已付款 2:已发货&apos;, 在开始的建表语句的时候，定义了state属性，是状态标识，既然能成功执行insertSuccessKilled方法，说明可以插入数据，那么state应该是0，所以要改动一下SQL语句12345&lt;insert id=&quot;insertSuccessKilled&quot;&gt; &lt;!-- 主键冲突:使用ignore忽略报错 insert不执行 返回0 --&gt; insert ignore into success_killed(seckill_id,user_phone,state) values (#&#123;seckillId&#125;,#&#123;userPhone&#125;,0)&lt;/insert&gt; 这样，再插入的数据的state就是0了 然后是queryByIdWithSeckill方法，先看方法的定义1SuccessKilled queryByIdWithSeckill(long seckillId); 由于之前考虑的不周到，这条语句还要有些改动 因为Seckill与SuccessKilled是一对多的关系，一个秒杀商品对应多个成功秒杀记录，那么想要查询某个人的秒杀记录的时候，上面的语句就行不通了，所以要添加一个参数1SuccessKilled queryByIdWithSeckill(@Param(&quot;seckillId&quot;) long seckillId, @Param(&quot;userPhone&quot;) long userPhone); 多了一个参数，所以还要加上@Param注解，同时，还要改动的地方是mapper目录下SuccessKilledDao.xml文件，找到与方法名相同的id1where sk.seckill_id = #&#123;seckillId&#125; and sk.user_phone = #&#123;userPhone&#125; 前面已经插入过一条成功秒杀的信息，所以还是用前面的数据12345678@Testpublic void testQueryByIdWithSeckill() &#123; long id = 1000L; long phone = 13512345678L; SuccessKilled successKilled = successKilledDao.queryByIdWithSeckill(id, phone); System.out.println(successKilled); System.out.println(successKilled.getSeckillId());&#125; 因为在SuccessKilled类中已经实例化了Seckill类，并生成了getter和setter方法，所以这里也可以取到Seckill对象 终于，所有的DAO层的工作已经完成了]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java笔记之高并发秒杀API(一)]]></title>
      <url>%2F2017%2F01%2F01%2FJava%E7%AC%94%E8%AE%B0%E4%B9%8B%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A7%92%E6%9D%80API-%E4%B8%80%2F</url>
      <content type="text"><![CDATA[本次系列的Java笔记是通过学习慕课网上的高并发秒杀API的视频而总结的，只是想通过写博客的过程能让自己梳理学习的过程，顺便时刻提醒自己。 本次秒杀API的项目的整体框架是Spring+Spring MVC+Mybatis，数据库为MySQL。 创建项目使用maven构建项目，因为使用命令行下载太慢，直接在Eclipse上使用maven来创建项目 如图： archetypeArtifactId: maven-archetype-webapp gtoupId: org.seckill artifactId: seckill 打开src\main\webapp\WEB-INF\web.xml 默认的Servlet版本是2.3，但是该版本下JSP的EL表达式是不工作的，这里需要更改版本 打开apache-tomcat-8.5.9\webapps\examples\WEB-INF\web.xml， 这是Tomcat的示例配置文件，将web-app标签内的内容覆盖到项目中的web.xml的web-app标签 Tomcat8.5.9给的示例文件显示使用的Servlet版本是3.1 依赖配置首先是补全文件，在src/main下添加两个文件夹java、test java： 存放java的源文件 test： 用于单元测试 也可以直接在Eclipse中右键项目名，点击Build Path-&gt;Order and Export 把需要的都选上，然后点击Apply，引入相关文件 接着打开pom.xml，配置依赖首先的改动是junit的版本，Eclipse自动生成的pom.xml的junit版本是3.8.1，这里改为4.11 因为junit3.0的版本是默认使用编程的方式运行的， 而4.0的版本是默认通过注解的方式来运行junit的接着就是补全项目的依赖 日志相关依赖本次项目采用slf4j+logback的组合 123456789101112131415161718&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;1.7.12&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-core&lt;/artifactId&gt; &lt;version&gt;1.1.1&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 实现slf4j接口并整合 --&gt;&lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.1.1&lt;/version&gt;&lt;/dependency&gt; logback的依赖有两个： logback-core、logback-classic logback-core： 实现logback核心的功能 logback-calssic： 实现slf4j接口并整合 数据库相关依赖包括数据库驱动，数据库连接池c3p0 12345678910111213&lt;!-- 数据库相关依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.35&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;c3p0&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.1.2&lt;/version&gt;&lt;/dependency&gt; DAO框架相关依赖——即Mybatis依赖Mybatis依赖主要有两个，一个是Mybatis自身的依赖，二是Mybatis和Spring整合的依赖 12345678910111213&lt;!-- DAO框架:Mybatis相关依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.3.0&lt;/version&gt;&lt;/dependency&gt;&lt;!-- Mybatis自身实现Spring的整合依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt;&lt;/dependency&gt; Servlet WEB相关依赖一些相关的标签、jstl、jackson等 123456789101112131415161718192021222324&lt;!-- Servlet Web相关依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;taglibs&lt;/groupId&gt; &lt;artifactId&gt;standard&lt;/artifactId&gt; &lt;version&gt;1.1.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.5.4&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt;&lt;/dependency&gt; Spring相关依赖Spring核心依赖包括spring-beans相关的依赖， 一些spring扩展依赖如:spring-context 123456789101112131415161718&lt;!-- Spring核心依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;4.1.7.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;4.1.7.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;4.1.7.RELEASE&lt;/version&gt;&lt;/dependency&gt; Spring Dao层的依赖 spring-jdbc： jdbc提供数据库相关的事务管理器 spring-tx： Spring的声明式事务 123456789101112&lt;!-- Spring Dao层的依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;4.1.7.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;4.1.7.RELEASE&lt;/version&gt;&lt;/dependency&gt; Spring WEB相关的依赖包括与Spring MVC相关的依赖 123456789101112&lt;!-- Spring WEB相关的依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;4.1.7.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;4.1.7.RELEASE&lt;/version&gt;&lt;/dependency&gt; Spring test相关的依赖123456789101112&lt;!-- Spring WEB相关的依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;4.1.7.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;4.1.7.RELEASE&lt;/version&gt;&lt;/dependency&gt; 虽然以上有些依赖版本相对有些老旧，但毕竟是练习，在不是特别熟悉这些框架和服务时，尽量按照视频中的版本来，不然等到测试时，会有各种玄学的问题，比较麻烦。在实际工作中应该前期就把要采用的服务的版本特性了解清楚。 业务分析 秒杀业务的核心就是对库存的处理，而难点主要是竞争 当n个用户同时竞争一个秒杀商品时，为了保证数据准确，没有出现数据的脏读、幻读等；保证商家没有出现超卖或者少卖的现象，就必然会用到事务+行级锁 至此，准备工作完成]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2016%2F12%2F30%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
  
  
</search>
