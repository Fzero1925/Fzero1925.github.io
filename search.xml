<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Java笔记之高并发秒杀API(二)]]></title>
      <url>%2F2017%2F01%2F05%2FJava%E7%AC%94%E8%AE%B0%E4%B9%8B%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A7%92%E6%9D%80API-%E4%BA%8C%2F</url>
      <content type="text"><![CDATA[本篇将完成DAO层的设计与开发，包括： 数据库、DAO实体与接口设计与编码 基于MyBatis实现DAO编程 MyBatis与Spring整合 DAO层单元测试 一、数据库设计与编码打开Eclipse，在src\main下建立一个文件夹sql，用于存放建表语句，新建一个SQL文件schema.sql，先创建一个秒杀商品的库存表 123456789101112131415161718192021-- 数据库初始化脚本-- 创建数据库CREATE DATABASE seckill;-- 使用数据库USE seckill;--创建秒杀库存表CREATE TABLE seckill(`seckill_id` bigint NOT NULL AUTO_INCREMENT COMMENT &apos;商品库存id&apos;,`name` varchar(120) NOT NULL COMMENT &apos;商品名称&apos;,`number` int NOT NULL COMMENT &apos;库存数量&apos;,`start_time` timestamp NOT NULL COMMENT &apos;秒杀开始时间&apos;,`end_time` timestamp NOT NULL COMMENT &apos;秒杀结束时间&apos;,`create_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &apos;创建时间&apos;,PRIMARY KEY (seckill_id),key idx_start_time(start_time),key idx_end_time(end_time),key idx_create_time(create_time))ENGINE=InnoDB AUTO_INCREMENT=1000 DEFAULT CHARSET=utf8 COMMENT=&apos;秒杀库存表&apos;; 主键为seckill_id，再单独对start_time、end_time、create_time三列单独建立索引，最后显式的设置MySQL引擎为InnoDB、自增主键初始值设置为1000、编码方式为utf8，并添加注释 MySQL默认的有很多引擎，只有InnoDB支持事务 可以插入几条数据12345678-- 初始化数据INSERT INTO seckill(name,number,start_time,end_time)VALUES (&apos;1000秒杀iPhone6S&apos;,100,&apos;2017-01-01 00:00:00&apos;,&apos;2017-01-02 00:00:00&apos;), (&apos;500秒杀MBP&apos;,200,&apos;2017-01-01 00:00:00&apos;,&apos;2017-01-02 00:00:00&apos;), (&apos;300秒杀iPad&apos;,100,&apos;2017-01-01 00:00:00&apos;,&apos;2017-01-02 00:00:00&apos;), (&apos;200秒杀小米MIX&apos;,300,&apos;2017-01-01 00:00:00&apos;,&apos;2017-01-02 00:00:00&apos;); 建立秒杀成功明细表，记录秒杀成功的用户信息和商品信息12345678910-- 秒杀成功明细表-- 用户登录认证相关的信息CREATE TABLE success_killed(`seckill_id` bigint NOT NULL COMMENT &apos;秒杀商品id&apos;,`user_phone` bigint NOT NULL COMMENT &apos;用户手机号&apos;,`state` tinyint NOT NULL DEFAULT -1 COMMENT &apos;状态标识: -1:无效 0:成功 1:已付款 2:已发货&apos;,`create_time` timestamp NOT NULL COMMENT &apos;创建时间&apos;,PRIMARY KEY(seckill_id,user_phone),/*联合主键 防止用户重复秒杀*/key idx_create_time(create_time))ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT=&apos;秒杀成功明细表&apos;; create_time就是秒杀成功的时间因为id和phone可以唯一确定一个用户，所以这里要用到联合主键，防止用户重复秒杀一个商品，当然以后也可以为此做过滤数据库的设计完成了，可以在控制台或者数据库管理工具输入上述SQL语句 二、DAO层相关接口编码先在java目录下建立两个包： org.seckill.entity：数据库对应的实体包 org.seckill.dao：DAO层接口包 在org.seckill.entity包下新建实体类Seckill，对应数据库中的seckill表12345678910111213141516171819202122232425public class Seckill &#123; private long seckillId; private String name; private int number; private Date startTime; private Date endTime; private Date createTime;@Override public String toString() &#123; return &quot;Seckill [seckillId=&quot; + seckillId + &quot;, name=&quot; + name + &quot;, number=&quot; + number + &quot;, startTime=&quot; + startTime+ &quot;, endTime=&quot; + endTime + &quot;, createTime=&quot; + createTime + &quot;]&quot;; &#125;&#125; 然后直接生成getter和setter方法，并复写toString方法 同样在org.seckill.entity包下新建实体类SuccessKilled，对应数据库中的success_killed表123456789101112131415161718192021public class SuccessKilled &#123; private long seckillId; private long userPhone; private short state; private Date createTime; private Seckill seckill;@Override public String toString() &#123; return &quot;SuccessKilled [seckillId=&quot; + seckillId + &quot;, userPhone=&quot; + userPhone + &quot;, state=&quot; + state + &quot;, createTime=&quot; + createTime + &quot;]&quot;; &#125;&#125; 直接生成getter和setter方法，并复写toString方法1private Seckill seckill; 这里实例化了一个Seckill类的对象，因为当用户成功秒杀一个商品时，可能需要完全拿到Seckill的实体 接着在org.seckill.dao包下新建接口SeckillDao，因为在数据库中seckill表记录的是秒杀商品的库存，所以当用户秒杀成功时，应该对数据库进行操作，也就是减库存1234567 /** * 减库存 * @param seckillId * @param killTime * @return 返回受影响的行数 */int reduceNumber(long seckillId, Date killTime); 还可以查询秒杀库存表的信息1234567891011121314 /** * 根据id查询秒杀对象 * @param seckillId 秒杀商品id * @return */Seckill queryById(long seckillId);/** * 根据偏移量查询秒杀商品列表 * @param offset 初始位置 * @param limit 查询个数 * @return */List&lt;Seckill&gt; queryAll(int offset, int limit); 偏移量就是用户可以设置初始位置offset，查询limit个数据 在org.seckill.dao包下新建接口SuccessKilledDao，当有一个用户在规定时间内成功秒杀一个商品时，进行记录，并且可以根据id查询相应的信息1234567891011121314/** * 插入购买明细，可过滤重复 * @param seckillId * @param userPhone * @return 返回受影响的行数，返回0表示没有插入数据 */int insertSuccessKilled(long seckillId, long userPhone);/** * 根据id查询SuccessKilled并携带Seckill实体 * @param seckill * @return */SuccessKilled queryByIdWithSeckill(long seckillId); 对于insertSuccessKilled方法，因为id和phone能唯一确定一个用户，所以当有重复出现时，不满足条件，insert语句不执行，返回0 如何设置条件，体现在SQL语句的书写，SQL语句写在下面要用到的MyBatis的xml文件中 至此，数据库对应的实体类以及DAO层的接口完成了，而且不用写接口的实现类，因为MyBatis把这些工作都承担了那么这里就可以对DAO层有个初步的了解： DAO层提供了一些接口，这些接口是数据库对应的实体类(即Seckill类和SuccessKilled类)对数据库各种操作(例如:减库存、记录用户信息等)而封装的接口 三、基于MyBatis实现DAO层接口数据库与项目之间的映射之前已经实现了，数据库中的表对应org.seckill.entity包下的实体类，数据库中的列对应这些类中的属性，而这些对象要操作数据库，需要中间的映射过程，jdbc、MyBatis、Hibernate等都是工作在这一层，把数据库中的数据映射到对象中，并通过方法，操作数据库 在DAO层，我们已经写好了接口和方法，但是没有实现类，如果使用jdbc，就要手动的拿到数据库的连接，也要有实现接口的实现类，所以使用成熟的框架可以减少工作量，后期容易维护等许多好处 这里使用MyBatis，MyBatis对实现DAO层接口提供了两种方法： MyBatis内部有一个Mapper机制来自动实现DAO层接口 通过API编程的方式，MyBatis提供了很多API 显而易见，大部分都是选择自动实现DAO层接口，这种方法只需设计接口，不需要写实现类，通过配置MyBatis的xml文件，写好SQL语句，其他的工作MyBatis都会自动完成 1.MyBatis全局配置先在src\main\resources下建立一个MyBatis全局的配置文件mybatis-conf.xml，再新建一个mapper目录，用于存放MyBatis的SQL映射 打开MyBatis全局配置文件mybatis-conf.xml123&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt; 将这些内容复制到xml文件中，这些示例都可以在MyBatis官网上的参考文档中找到 然后配置一些属性123456789101112131415&lt;configuration&gt; &lt;!-- 配置全局属性 --&gt; &lt;settings&gt; &lt;!-- 使用jdbc的getGenerateKeys获取数据库自增主键值 --&gt; &lt;setting name=&quot;useGeneratedKeys&quot; value=&quot;true&quot;/&gt; &lt;!-- 使用列别名替换列名 默认为true --&gt; &lt;setting name=&quot;useColumnLabel&quot; value=&quot;true&quot;/&gt; &lt;!-- 开启驼峰命名转换:Table(create_time) -&gt; Entity(createTime) --&gt; &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt; &lt;/settings&gt;&lt;/configuration&gt; 使用列别名替换列名，MyBatis默认为true，MyBatis会自动的识别出列别名对应哪个列名，并赋值到entity实体属性中 前面提到，要实现DAO层的接口可以使用MyBatis的mapper机制，为DAO接口方法提供SQL语句配置，所以在mapper文件夹下创建相应接口的配置文件SeckillDao.xml和SuccessKilledDao.xml123&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt; 同样，这些内容都要添加到xml文件中 2.SeckillDao接口SQL语句配置打开SeckillDao.xml12345678910111213141516171819202122232425262728&lt;!-- 目的:为DAO接口方法提供SQL语句配置 --&gt;&lt;mapper namespace=&quot;org.seckill.dao.SeckillDao&quot;&gt; &lt;update id=&quot;reduceNumber&quot; &gt; update seckill set number = number - 1 where seckill_id = #&#123;seckillId&#125; and start_time &lt;![CDATA[ &lt;= ]]&gt; #&#123;startTime&#125; and end_time &gt;= #&#123;endTime&#125; and number &gt; 0; &lt;/update&gt; &lt;select id=&quot;queryById&quot; parameterType=&quot;long&quot; resultType=&quot;Seckill&quot;&gt; select seckill_id,name,number,start_time,end_time,create_time from seckill where seckill_id = #&#123;seckillId&#125; &lt;/select&gt; &lt;select id=&quot;queryAll&quot; resultType=&quot;Seckill&quot;&gt; select seckill_id,name,number,start_time,end_time,create_time from seckill order by create_time desc limit #&#123;offset&#125;,#&#123;limit&#125; &lt;/select&gt; &lt;/mapper&gt; 首先是mapper标签中的属性，namespace是对这个mapper的命名，也就是对这个xml文件的命名，这个命名必须在mapper目录下唯一，因为真正的项目中，mapper下的xml文件有很多，如果命名不唯一，MyBatis就不知道要调用哪个xml文件了，一般都是包名.接口名 接着逐个分析SQL语句12345678910 &lt;update id=&quot;reduceNumber&quot; &gt; update seckill set number = number - 1 where seckill_id = #&#123;seckillId&#125; and start_time &lt;![CDATA[ &lt;= ]]&gt; #&#123;killTime&#125; and end_time &gt;= #&#123;killTime&#125; and number &gt; 0;&lt;/update&gt; 因为要实现SeckillDao接口中的减库存的方法，所以使用update语句，id必须在该xml文件下唯一，一般为方法名1int reduceNumber(long seckillId, Date killTime);//SeckillDao接口中定义的方法 update标签中还有parameterType属性，这里可以不用写，MyBatis可以自动识别where后面有些限制条件，秒杀成功的时间要在规定时间内，要晚于开始时间，早于结束时间，否则update语句不会执行，当库存小于等于0时，也不执行update语句，数据返回类型为int，表示受影响的行数 至于下面这句1and start_time &lt;![CDATA[ &lt;= ]]&gt; #&#123;killTime&#125; 在w3school上有详细介绍： 术语 CDATA 指的是不应由 XML 解析器进行解析的文本数据（Unparsed Character Data）。在 XML 元素中，”&lt;” 和 “&amp;” 是非法的。“&lt;” 会产生错误，因为解析器会把该字符解释为新元素的开始。“&amp;” 也会产生错误，因为解析器会把该字符解释为字符实体的开始。某些文本，比如 JavaScript 代码，包含大量 “&lt;” 或 “&amp;” 字符。为了避免错误，可以将脚本代码定义为 CDATA。CDATA 部分中的所有内容都会被解析器忽略。CDATA 部分由 “&lt;![CDATA[“ 开始，由 “]]&gt;” 结束： 如果xml文件中仅有”&lt;”和”&amp;”，还是建议把它们替换为实体引用 接着写完实现其他方法的SQL语句12345 &lt;select id=&quot;queryById&quot; parameterType=&quot;long&quot; resultType=&quot;Seckill&quot;&gt; select seckill_id,name,number,start_time,end_time,create_time from seckill where seckill_id = #&#123;seckillId&#125;&lt;/select&gt; queryById方法实质上是select查询语句，resultType返回的类型是Seckill类，因为自定义的类不在java.lang包下，所以一般是包名.类名，但是后面有方法可以省略包名，这里就只写类名 1Seckill queryById(long seckillId);//SeckillDao接口中定义的方法 parameterType为long类型，因为已经开启了驼峰转换，所以可以不适用as进行列名转换 最后是queryAll方法123456 &lt;select id=&quot;queryAll&quot; resultType=&quot;Seckill&quot;&gt; select seckill_id,name,number,start_time,end_time,create_time from seckill order by create_time desc limit #&#123;offset&#125;,#&#123;limit&#125;&lt;/select&gt; 多个参数的话，可以不用给parameterType，结果按降序排列 1List&lt;Seckill&gt; queryAll(int offset, int limit);//SeckillDao接口中定义的方法 对于resultType，无论返回的是List还是Map，只要给出里面的类型就可以 3.SuccessKilledDao接口SQL语句配置打开SuccessKilledDao.xml123456789101112131415161718192021222324252627&lt;mapper namespace=&quot;org.seckill.dao.SuccessKilledDao&quot;&gt; &lt;insert id=&quot;insertSuccessKilled&quot;&gt; &lt;!-- 主键冲突:使用ignore忽略报错 insert不执行 返回0 --&gt; insert ignore into success_killed(seckill_id,user_phone) values (#&#123;seckillId&#125;,#&#123;userPhone&#125;) &lt;/insert&gt; &lt;select id=&quot;queryByIdWithSeckill&quot; resultType=&quot;SuccessKilled&quot;&gt; &lt;!-- 根据id查询SuccessKilled并携带Seckill实体 --&gt; &lt;!-- 如何告诉Mybatis把结果映射到SuccessKilled同时映射Seckill属性 --&gt; select sk.seckill_id, sk.user_phone, sk.create_time, sk.state, s.seckill_id &quot;seckill.seckill_id&quot;, s.name &quot;seckill.name&quot;, s.start_time &quot;seckill.start_time&quot;, s.end_time &quot;seckill.end_time&quot;, s.create_time &quot;seckill.create_time&quot; from success_killed sk inner join seckill s on sk.seckill_id = s.seckill_id where sk.seckill_id = #&#123;seckillId&#125; &lt;/select&gt; &lt;/mapper&gt; 简单说下insertSuccessKilled方法，在src\main\sql目录下有个schema.sql文件，里面是建表语句，在建立success_killed表的时候设置了一个联合主键，是防止用户重复秒杀的1PRIMARY KEY(seckill_id,user_phone) 所以id和phone只要有一个重复，insert语句就会报错，对于这种错误，其实只要不执行insert即可，不需要每次都报错，所以使用ignore关键字，当有主键冲突时，忽略报错，insert语句不会执行，结果返回0，说明没有插入数据 对于queryByIdWithSeckill方法1234567891011121314151617 &lt;select id=&quot;queryByIdWithSeckill&quot; resultType=&quot;SuccessKilled&quot;&gt; &lt;!-- 根据id查询SuccessKilled并携带Seckill实体 --&gt; &lt;!-- 如何告诉Mybatis把结果映射到SuccessKilled同时映射Seckill属性 --&gt; select sk.seckill_id, sk.user_phone, sk.create_time, sk.state, s.seckill_id &quot;seckill.seckill_id&quot;, s.name &quot;seckill.name&quot;, s.start_time &quot;seckill.start_time&quot;, s.end_time &quot;seckill.end_time&quot;, s.create_time &quot;seckill.create_time&quot; from success_killed sk inner join seckill s on sk.seckill_id = s.seckill_id where sk.seckill_id = #&#123;seckillId&#125;&lt;/select&gt; 首先要明确的是这个方法的作用，是根据id查询SuccessKilled并携带Seckill实体 1SuccessKilled queryByIdWithSeckill(long seckillId);//SuccessKilledDao接口中定义的方法 返回SuccessKilled类型，在这个类中，实例化了Seckill类 123from success_killed skinner join seckill s on sk.seckill_id = s.seckill_idwhere sk.seckill_id = #&#123;seckillId&#125; from success_killed表，再使用内连接的方式使seckill表加入进来，on后面表示两个表通过相同的id进行连接，id的值为传进来的参数seckillId的值在MyBatis中可以忽略as关键字 那么如何告诉Mybatis把结果映射到SuccessKilled同时映射Seckill属性，首先可以得到sk表即success_killed表中的内容1234sk.seckill_id,sk.user_phone,sk.create_time,sk.state, sk.seckill_id虽然使用了别名，但是MyBatis会忽略别名，所以MyBatis视为从sk表中的seckill_id列取数据，再返回数据到Java，又因为在MyBatis全局配置文件中开启了驼峰命名转换，所以seckill_id就变成了seckillId，赋值给相应的变量，这就是使用框架的好处 取到了数据，映射到了SuccessKilled中，又怎么同时映射Seckill属性呢？在SuccessKilled类中，直接实例化了Seckill类，并生成了getter和setter方法success_killed和seckill两个表又通过内连接的方式进行了连接，所以可以直接在select后面这样写12345s.seckill_id &quot;seckill.seckill_id&quot;,s.name &quot;seckill.name&quot;,s.start_time &quot;seckill.start_time&quot;,s.end_time &quot;seckill.end_time&quot;,s.create_time &quot;seckill.create_time&quot; 前面说过，MyBatis会忽略别名，所以这里要在后面表明，这些列是来自哪个表的，这种写法实际是OGNL表达式，据说在Struts上很常见，但是在MyBatis的xml文件中也经常用到，所以还是要多了解下 到这里，MyBatis实现DAO层接口完成了 四、MyBatis与Spring整合]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java笔记之高并发秒杀API(一)]]></title>
      <url>%2F2017%2F01%2F01%2FJava%E7%AC%94%E8%AE%B0%E4%B9%8B%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A7%92%E6%9D%80API-%E4%B8%80%2F</url>
      <content type="text"><![CDATA[本次系列的Java笔记是通过学习慕课网上的高并发秒杀API的视频而总结的，只是想通过写博客的过程能让自己梳理学习的过程，顺便时刻提醒自己。 本次秒杀API的项目的整体框架是Spring+Spring MVC+Mybatis，数据库为MySQL。 创建项目使用maven构建项目，因为使用命令行下载太慢，直接在Eclipse上使用maven来创建项目 如图： archetypeArtifactId: maven-archetype-webapp gtoupId: org.seckill artifactId: seckill 打开src\main\webapp\WEB-INF\web.xml 默认的Servlet版本是2.3，但是该版本下JSP的EL表达式是不工作的，这里需要更改版本 打开apache-tomcat-8.5.9\webapps\examples\WEB-INF\web.xml， 这是Tomcat的示例配置文件，将web-app标签内的内容覆盖到项目中的web.xml的web-app标签 Tomcat8.5.9给的示例文件显示使用的Servlet版本是3.1 依赖配置首先是补全文件，在src/main下添加两个文件夹java、test java： 存放java的源文件 test： 用于单元测试 也可以直接在Eclipse中右键项目名，点击Build Path-&gt;Order and Export 把需要的都选上，然后点击Apply，引入相关文件 接着打开pom.xml，配置依赖首先的改动是junit的版本，Eclipse自动生成的pom.xml的junit版本是3.8.1，这里改为4.11 因为junit3.0的版本是默认使用编程的方式运行的， 而4.0的版本是默认通过注解的方式来运行junit的接着就是补全项目的依赖 日志相关依赖本次项目采用slf4j+logback的组合 123456789101112131415161718&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;1.7.12&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-core&lt;/artifactId&gt; &lt;version&gt;1.1.1&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 实现slf4j接口并整合 --&gt;&lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.1.1&lt;/version&gt;&lt;/dependency&gt; logback的依赖有两个： logback-core、logback-classic logback-core： 实现logback核心的功能 logback-calssic： 实现slf4j接口并整合 数据库相关依赖包括数据库驱动，数据库连接池c3p0 12345678910111213&lt;!-- 数据库相关依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.35&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;c3p0&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.1.2&lt;/version&gt;&lt;/dependency&gt; DAO框架相关依赖——即Mybatis依赖Mybatis依赖主要有两个，一个是Mybatis自身的依赖，二是Mybatis和Spring整合的依赖 12345678910111213&lt;!-- DAO框架:Mybatis相关依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.3.0&lt;/version&gt;&lt;/dependency&gt;&lt;!-- Mybatis自身实现Spring的整合依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt;&lt;/dependency&gt; Servlet WEB相关依赖一些相关的标签、jstl、jackson等 123456789101112131415161718192021222324&lt;!-- Servlet Web相关依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;taglibs&lt;/groupId&gt; &lt;artifactId&gt;standard&lt;/artifactId&gt; &lt;version&gt;1.1.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.5.4&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt;&lt;/dependency&gt; Spring相关依赖Spring核心依赖包括spring-beans相关的依赖， 一些spring扩展依赖如:spring-context 123456789101112131415161718&lt;!-- Spring核心依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;4.1.7.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;4.1.7.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;4.1.7.RELEASE&lt;/version&gt;&lt;/dependency&gt; Spring Dao层的依赖 spring-jdbc： jdbc提供数据库相关的事务管理器 spring-tx： Spring的声明式事务 123456789101112&lt;!-- Spring Dao层的依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;4.1.7.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;4.1.7.RELEASE&lt;/version&gt;&lt;/dependency&gt; Spring WEB相关的依赖包括与Spring MVC相关的依赖 123456789101112&lt;!-- Spring WEB相关的依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;4.1.7.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;4.1.7.RELEASE&lt;/version&gt;&lt;/dependency&gt; Spring test相关的依赖123456789101112&lt;!-- Spring WEB相关的依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;4.1.7.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;4.1.7.RELEASE&lt;/version&gt;&lt;/dependency&gt; 虽然以上有些依赖版本相对有些老旧，但毕竟是练习，在不是特别熟悉这些框架和服务时，尽量按照视频中的版本来，不然等到测试时，会有各种玄学的问题，比较麻烦。在实际工作中应该前期就把要采用的服务的版本特性了解清楚。 业务分析 秒杀业务的核心就是对库存的处理，而难点主要是竞争 当n个用户同时竞争一个秒杀商品时，为了保证数据准确，没有出现数据的脏读、幻读等；保证商家没有出现超卖或者少卖的现象，就必然会用到事务+行级锁 至此，准备工作完成]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2016%2F12%2F30%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
  
  
</search>
