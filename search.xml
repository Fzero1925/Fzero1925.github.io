<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Java笔记之人员管理模块(六)]]></title>
      <url>%2F2017%2F03%2F19%2FJava%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%BA%BA%E5%91%98%E7%AE%A1%E7%90%86%E6%A8%A1%E5%9D%97-%E5%85%AD%2F</url>
      <content type="text"><![CDATA[本篇将完成基于Struts2拦截器的权限管理 页面设计既然有登录用户权限的区别，所以在列表页也要有显示登录用户的信息和退出登录的操作 1234567891011121314151617181920212223242526272829&lt;thead&gt; &lt;tr&gt; &lt;th&gt;&lt;/th&gt;&lt;th&gt;&lt;/th&gt;&lt;th&gt;&lt;/th&gt;&lt;th&gt;&lt;/th&gt;&lt;th&gt;&lt;/th&gt;&lt;th&gt;&lt;/th&gt;&lt;th&gt;&lt;/th&gt;&lt;th&gt;&lt;/th&gt; &lt;th&gt;&lt;span&gt;欢迎你：&lt;s:property value=&quot;#session[&apos;UserName&apos;]&quot;/&gt;&lt;/span&gt;&lt;/th&gt; &lt;th&gt;&lt;a class=&quot;btn btn-info&quot; href=&quot;/management/login&quot; &gt;退出&lt;/a&gt;&lt;/th&gt; &lt;/tr&gt; &lt;%-- 如果登录用于不是admin，则屏蔽所有能对数据操作的按钮 --%&gt; &lt;s:if test=&quot;#session[&apos;UserName&apos;] == &apos;admin&apos;&quot;&gt; &lt;tr&gt; &lt;th&gt;&lt;button class=&quot;btn btn-info&quot; onclick=&quot;deleteMore()&quot;&gt;删除&lt;/button&gt;&lt;/th&gt; &lt;th&gt;&lt;/th&gt;&lt;th&gt;&lt;/th&gt;&lt;th&gt;&lt;/th&gt;&lt;th&gt;&lt;/th&gt;&lt;th&gt;&lt;/th&gt;&lt;th&gt;&lt;/th&gt;&lt;th&gt;&lt;/th&gt; &lt;th&gt;&lt;a class=&quot;btn btn-info&quot; href=&quot;/management/staff&quot; &gt;员工管理&lt;/a&gt;&lt;/th&gt; &lt;th&gt;&lt;a class=&quot;btn btn-info&quot; href=&quot;/management/position&quot; &gt;职位管理&lt;/a&gt;&lt;/th&gt; &lt;/tr&gt; &lt;/s:if&gt; &lt;tr&gt; &lt;th&gt;&lt;/th&gt; &lt;th&gt;ID&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;性别&lt;/th&gt; &lt;th&gt;职位&lt;/th&gt; &lt;th&gt;薪资&lt;/th&gt; &lt;th&gt;Email&lt;/th&gt; &lt;th&gt;入职时间&lt;/th&gt; &lt;th&gt;&lt;/th&gt; &lt;th&gt;&lt;/th&gt; &lt;/tr&gt;&lt;/thead&gt; 这是table标签内的部分代码 首先是显示登录用户名称1&lt;span&gt;欢迎你：&lt;s:property value=&quot;#session[&apos;UserName&apos;]&quot;/&gt; 使用Session保存登录用户信息 前端的页面就完成了，也就是添加一个显示用户名称的span和一个退出登录的按钮 Struts2拦截器拦截器是Struts2框架的核心，它主要完成解析请求参数、将请求参数赋值给Action属性、执行数据校验、文件上传等工作。Struts2设计的灵巧性，拦截器起了关键性的作用，当需要扩展Struts2功能时，只需要提供对应拦截器，并将它配置在Struts2容器中即可 要实现自定义拦截器有两种方式：1、实现Interceptor接口，同时还要实现Interceptor接口中的三个方法 void init()：初始化拦截器所需资源 void destroy()：释放在init()中分配的资源 String intercept(ActionInvocation ai) throws Exception： 实现拦截器功能 利用ActionInvocation参数获取Action状态 返回result字符串作为逻辑视图 2、继承AbstractInterceptor类 提供了inti()和destroy()方法的空实现 只需要实现intercept方法即可 为了避免Action类过于臃肿，所以这里采用第二种方式 基于Struts2的拦截器实现权限控制先说明思路： 登录用户的信息通过Struts2的值栈传递进来的，在执行LoginAction类的login方法之前，先要通过一系列的拦截器，如果没有自定义的拦截器，会通过一个默认的拦截器 根据Struts.xml的配置不同，会经过用户指定的拦截器，当经过自定义的拦截器的时候，会执行intercept方法，这里对Session执行简单的空判断 如果Session中的UserName不为空，则执行invoke方法，然后执行相应的Action；否则返回登录页面 因为intercept方法中只是进行空判断，所以这个拦截器的作用是为了防止用户通过拼接URL来直接进入列表页 对用户行为的控制则有Struts2的if标签进行控制，如果通过判断Session中的用户不是admin的话，则那些增删改查的按钮就不会显示 以上的思路虽然可以肯定实际的工作中不会这样做，但是这是目前为止我能想到的方法，这样也可以简单的了解一下Struts2的拦截器功能 在src/main/java/management包下新建一个intercept包，用于存放自定义的拦截器 接着创建一个AuthInterceptor类并继承AbstractInterceptor12345678910111213141516@SuppressWarnings(&quot;serial&quot;)public class AuthInterceptor extends AbstractInterceptor &#123; @Override public String intercept(ActionInvocation invocation) throws Exception &#123; ActionContext context = ActionContext.getContext(); Map&lt;String, Object&gt; session = context.getSession(); if(session.get(&quot;UserName&quot;) != null &amp;&amp; !&quot;&quot;.equals(session.get(&quot;UserName&quot;)))&#123; String result = invocation.invoke(); return result; &#125;else&#123; return &quot;login&quot;; &#125; &#125;&#125; 首先登陆用户的信息存放在Session中，Struts2通过ActionContext来获取Session，接着就是对Session中的UserName进行判断，如果为空，则返回登录页面 如果Session中的UserName不为空，则执行invoke方法1String result = invocation.invoke(); ActionInvocation中的invoke方法就调用ActionInvocation的下一个拦截器，如果当前是最后一个拦截器，则执行目标Action，这里可以输出result的结果到控制台，可以看到执行invoke方法后返回的是SUCCESS 接着改动一下LoginAction中的login方法12345678910111213141516171819202122232425262728293031public String login()&#123; String username = login.getUsername(); String password = login.getPassword(); //获取验证码 String kaptchaExpected = (String)ActionContext.getContext().getSession().get(com.google.code.kaptcha.Constants.KAPTCHA_SESSION_KEY); //获取用户输入的验证码 String kaptcha = login.getKaptcha(); //这个判断之所以写在最前面，因为刚打开登录页面的时候input的值就通过Struts2的数据模型传递过来了 //刚开始username与password是null，kaptcha是空，所以要先拦截下来 if(kaptcha == null || kaptcha.equals(&quot;&quot;) || username == null || password == null )&#123; return &quot;input&quot;; &#125;else if(!kaptcha.equals(kaptchaExpected))&#123; this.addActionError(&quot;验证码错误！！！&quot;); return &quot;input&quot;; &#125; //通过值栈中的用户名和密码作为参数对数据库进行查询，如果不符合条件，返回的数据为null Login loginInfo = loginService.check(username, password); if(loginInfo == null)&#123; //返回的数据为null，说明用户名或者密码错误 this.addActionError(&quot;登录失败！！！&quot;); return &quot;input&quot;; &#125;else if(loginInfo.getUsername().equals(&quot;admin&quot;) &amp;&amp; loginInfo.getPassword().equals(&quot;admin&quot;))&#123; //判断登录的用户是否是admin用户，如果是admin用户，则没有限制 session.put(&quot;UserName&quot;, loginInfo.getUsername()); return &quot;success&quot;; &#125;else&#123; //如果登录用户是普通用户，在前端页面可以使用Struts2的if标签进行判断，对用户行为进行控制 session.put(&quot;UserName&quot;, loginInfo.getUsername()); return &quot;success&quot;; &#125;&#125; 首先，要使用Session，则要实现SessionAware接口 基本上改动不大，主要集中在执行完LoginService类的check的方法之后，如果返回的数据为null，则返回登录界面 如果返回的数据不为空，则对返回的数据进行判断，这里的判断实际上是重复的，最初以为在Action中对不同的登录用户进行不同的控制，最后还是决定使用Struts2的if标签，所以这里的最后一个else就显的没有必要了，没有改过来就是想给自己提个醒，看看有没有办法在后端就可以对登录用户进行行为控制 只要返回的数据不为空，就把登录用户的用户名放入Session的UserName中 然后对拦截器进行配置，打开struts.xml12345678910&lt;!-- 注册拦截器 --&gt;&lt;interceptors&gt; &lt;interceptor name=&quot;auth&quot; class=&quot;management.interceptor.AuthInterceptor&quot;&gt;&lt;/interceptor&gt; &lt;!-- 自定义拦截器栈 --&gt; &lt;interceptor-stack name=&quot;myInterceptor&quot;&gt; &lt;interceptor-ref name=&quot;defaultStack&quot;&gt;&lt;/interceptor-ref&gt; &lt;interceptor-ref name=&quot;auth&quot;&gt;&lt;/interceptor-ref&gt; &lt;/interceptor-stack&gt;&lt;/interceptors&gt; interceptors中的所有内容要在package中 首先是要注册自定义拦截器1&lt;interceptor name=&quot;auth&quot; class=&quot;management.interceptor.AuthInterceptor&quot;&gt;&lt;/interceptor&gt; 基本上注册完自定义的拦截器后就可以在相应的action中进行配置了，但是这里有一点要注意，如果只使用自定义拦截器，默认的拦截器就会失效，也就是，如果不使用自定义的拦截器，Struts2会有默认的拦截器，只是使用默认的拦截器可以不显式的显示出来，所以当使用自定义的拦截器的同时不显式的调用默认拦截器，则默认的拦截器就不会执行 所以既想用自定义拦截器的同时还要使用默认的拦截器，或者自定义的拦截器过多的时候，就可以使用拦截器栈12345&lt;!-- 自定义拦截器栈 --&gt;&lt;interceptor-stack name=&quot;myInterceptor&quot;&gt; &lt;interceptor-ref name=&quot;defaultStack&quot;&gt;&lt;/interceptor-ref&gt; &lt;interceptor-ref name=&quot;auth&quot;&gt;&lt;/interceptor-ref&gt;&lt;/interceptor-stack&gt; 默认的拦截器是defaultStack 接着就可以在需要拦截器的action中配置拦截器了，基本上除了登录页面，其余的action都需要权限控制的拦截器，防止用户通过猜测拼接URL直接进入相应的页面，这是不允许的123456&lt;action name=&quot;list_*&quot; class=&quot;management.action.ListAction&quot; method=&quot;&#123;1&#125;&quot;&gt; &lt;interceptor-ref name=&quot;myInterceptor&quot;&gt;&lt;/interceptor-ref&gt; &lt;result &gt;/WEB-INF/jsp/list.jsp&lt;/result&gt; &lt;result name=&quot;input&quot; type=&quot;redirect&quot;&gt;/list&lt;/result&gt; &lt;result name=&quot;login&quot; type=&quot;redirect&quot;&gt;/login&lt;/result&gt;&lt;/action&gt; 首先是列表页的action，这里有个result的name为login，就是因为在AuthInterceptor类中判断Session的UserName是否为空，如果为空，返回逻辑视图’login’ 接着是员工管理页面1234&lt;action name=&quot;staff_*&quot; class=&quot;management.action.StaffAction&quot; method=&quot;&#123;1&#125;&quot;&gt; &lt;interceptor-ref name=&quot;myInterceptor&quot;&gt;&lt;/interceptor-ref&gt; &lt;result &gt;/WEB-INF/jsp/staff.jsp&lt;/result&gt;&lt;/action&gt; 基本上是除了登录页面的action，其余的都要执行权限控制的拦截器，所以如果页面多的话，可以设置不同的拦截器栈，不同的action调用不同的拦截器栈，这里引用的是拦截器栈，而不是单独的一个拦截器 至于用户的行为控制，暂时使用Struts2的if标签，虽然感觉不是正规的方式，但是在目前页面还不是特别复杂的时候，用着还不错（实际是根本不知道正规的方法是什么）1&lt;s:if test=&quot;#session[&apos;UserName&apos;] == &apos;admin&apos;&quot;&gt; 通过这个语句可以进行简单的行为控制，如果登录的用户不是admin，则可以屏蔽一些按钮，具体使用就不说了，自己可以想屏蔽哪些功能就屏蔽哪些功能 至此，一个不是很正规的权限控制完成了]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java笔记之人员管理模块(五)]]></title>
      <url>%2F2017%2F03%2F01%2FJava%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%BA%BA%E5%91%98%E7%AE%A1%E7%90%86%E6%A8%A1%E5%9D%97-%E4%BA%94%2F</url>
      <content type="text"><![CDATA[本篇将完成列表页数据展示，写完后感觉写的比较乱，真的应该把项目完成后再写，但是既然开始了，就得继续写，要不一拖再拖就更写不成了 最初的列表页在这之前，先把列表页建立起来，首先是在StaffAction类中的execute()方法1234567//这不是最终版public String execute()&#123; List&lt;Staff&gt; staffList = staffService.queryStaffList(); HttpServletRequest request = ServletActionContext.getRequest(); request.setAttribute(&quot;staffList&quot;, staffList); return SUCCESS;&#125; 然后是Struts2的配置文件1234&lt;action name=&quot;list_*&quot; class=&quot;management.action.StaffAction&quot; method=&quot;&#123;1&#125;&quot;&gt; &lt;result &gt;/WEB-INF/jsp/list.jsp&lt;/result&gt; &lt;result name=&quot;input&quot; type=&quot;redirect&quot;&gt;/list&lt;/result&gt;&lt;/action&gt; 结合着该系列四最开始的list.jsp页面，基本的列表页就完成了 虽然上面的execute()方法不是最终版，但是那个StaffService调用的queryStaffList()方法是需要的，也在最终版中，在编写单条删除与新增员工的功能的时候，StaffService接口已经被注入StaffAction中了12@Autowiredprivate StaffService staffService; 然后是在StaffService接口中创建相应的方法123456/** * 查询所有员工信息 * @param staffId * @return */List&lt;Staff&gt; queryStaffList(); 因为是查询所有的员工信息，所以把返回结果放在List中，接着在StaffServiceImpl类中实现这个接口1234567/** * 查询所有员工信息 */public List&lt;Staff&gt; queryStaffList() &#123; List&lt;Staff&gt; staffList = staffDao.queryStaffList(); return staffList;&#125; 在StaffDao接口中创建相应方法123456/** * 查询所有员工信息 * @param staffId * @return */List&lt;Staff&gt; queryStaffList(); 然后打开mapper目录下的StaffDao.xml文件123&lt;select id=&quot;queryStaffList&quot; resultType=&quot;Staff&quot;&gt; select id,name,gender,job,salary,email,regdate from staff&lt;/select&gt; 返回类型要记得加上，是Staff类 现在，基本的列表页完成了，上面的所有内容，除了execute()方法后面要大改，其余的都可以不用动，接着就要想办法实现分页功能 实现分页功能的思路其实整个列表页的数据展示，全部依赖于分页功能 由于是第一次实现分页功能，所以就先去查了下Oracle数据库实现分页的原理，查了半天，觉得这一篇Oracle数据库分页查询原理挺不错的 Oracle中的表，除了我们建表时设计的各个字段，其实还有两个字段（此处只介绍2个），分别是ROWID（行标示符）和ROWNUM（行号），即使我们使用DESCRIBE命令查看表的结构，也是看不到这两个列的描述的，因为，他们其实是只在数据库内部使用的，所以也通常称他们为伪列（pseudo column） 可以使用简单的查询语句先验证一下1select rowid,rownum,id,name from staff; 这个rowid我们一般用不到，Oracle数据库内部使用它来存储行的物理位置，是一个18位的数字，采用base-64编码而这个rownum，我们也正是使用它来进行分页查询的，它的值，就是表示的该行的行号 使用伪列的时候还有个小坑，这里就不多说了，刚才那个链接解释的很详细，我再解释也是复制粘贴而已，所以这里就不增加篇幅了，知道了Oracle数据库有伪列这个东西，那就要好好利用了 接着决定在页面采用什么样式，“首页”、“上一页”、“下一页”、用户指定页码的按钮这些功能一定要有，当时感觉也能做出来，但是“上一页”与“下一页”的中间显示什么？ 这是当时想的样式，本来只想实现1~5的按钮的形式，在js中也是各种实验，但是最后还是放弃了，虽然现在有了点思路，也等到以后实现吧 然后就决定采用“当前页”的形式，但是这种形式必然要把数据全查询一遍，我对于这种需要全查询的情况感觉不太好，现在的数据量何其大，为了分页都要查询一遍？但是最后想通了，就目前我的水平，无论用哪种方式，为了实现分页，都要进行全查询 这就是最后决定的分页功能的展示形式 那么这五个部分先实现哪个呢？ 我决定从难到易，所以先排除“首页”和GO按钮余下“上一页”、“当前页”、“下一页”，这三部分又以“上一页”最难，但是现在又实现不了，因为连当前是第几页都不知道，所以先从“当前页”开始下手 实现“当前页”就比较简单了，全查询是肯定要做的，而且是必须做，因为伪列是根据查询语句的变化而变化的，伪列是对每一次查询结果进行标注，所以必须要全查询，这样才能获得总页数 有了全查询，总页数的问题解决了，当前页数也好解决，默认是第一页，之后就根据用户的操作了 现在的问题是数据传递的问题，反正我一直是对前后端通信方式有很大的疑惑，从后台获取到了总页数，如何传递到前端页面呢？ 最先想到的还是Cookie，但是Cookie会长时间保留，就算直接关闭浏览器，过一段时间再打开，使用F12来查看Cookie，显示的当前页数还不是第一页，也不能清除Cookie，在哪清除？Cookie存在时间多长？这些都不确定 然后就想到execute()方法中的方式，使用HttpServletRequest来设置属性，这样后端的数据可以传递到前端，但是在前端页面如何保存当前页数？用户点击“上一页”或者“下一页”的时候如何获取当前页数？当时前端页面使用的还不是Struts2的标签，也不是jsp页面，而是FreeMarker，这是为了面试而准备的，不过面试也没过，所以最后坚持不下去了，就放弃使用FreeMarker，全部改为jsp页面，使用Struts2的标签 因为在这个过程中一直寻找前后端传递数据的问题，所以在慕课网也看了Struts2和Java的基础视频，也提到了一些，但都是单方向的，ModelDriven就是看Struts2入门视频学到的，还是那句话，一些东西只有用到的时候，才能看懂，Struts2入门视频在那之前就看过了，但是还没遇到Struts2接收前端数据的问题，所以也没在意 慕课网也有制作员工管理系统的视频，但是肯定不能再跟着视频一步一步的敲代码，那样很难提高，但是在知道自己出问题的关键点的情况下再去看视频，就会学到很多东西，比如123456789101112&gt; ActionContext是Action的上下文，Struts2自动在其中保存了一些在Action执行过程中所需的对象，比如session, parameters, locale等。Struts2会根据每个执行HTTP请求的线程来创建对应的ActionContext，即一个线程有一个唯一的ActionContext。因此，使用者可以使用静态方法ActionContext.getContext()来获取当前线程的ActionContext，ActionContext本身的数据结构是映射结构，即一个Map，用key来映射value。所以使用者完全可以像使用Map一样来使用它，或者直接使用Action.getContextMap()方法来对Map进行操作对于值栈，在这篇[文章](http://www.jianshu.com/p/82954b841b5e#)可以了解的比较详细简单来说就是&gt; 我们可以直接将其理解为一种类似于域对象的用来存值和取值、在页面和后台之间传递数据的功能。在action中将数据存入值栈，然后在页面中通过EL表达式或者OGNL表达式将值取出知道了如何使用ajax请求并传递参数，知道了如何在Struts2的Action类中接收这些参数，知道了在前端页面如何使用Struts2的标签和OGNL表达式来获取后端存储的数据，接着就是代码的编写## 分页功能编码既然可以使用Struts2的标签来获取值栈中的数据，那么先在前端页面进行更改 当前第/页123当前页很容易改动，只是用于显示而已，要记得Struts2标签内value的值，这就是Map中的key接着是“下一页” 下一页 12345首先有个判断，如果当前页数不等于总页数的时候，这个“下一页”就会显示出来，如果等于的话，就不会显示。原来是想在js中进行判断的，但是感觉这种方法更好而且原本是想把传递参数的工作也交给$.post方法，不过无意中看到使用URL传递参数也不错，而且很方便，当然肯定有安全问题，但是不是现在能考虑的，所以暂时先采用URL传递参数的方式然后是“上一页” 上一页 123这里也进行判断，如果当前页数不等于1，就显示出来然后是首页 首页123这里就可以直接赋值为1，使用URL传递参数和使用ajax请求传递参数，在后端都是使用```request.getParameter()```的方式获取的还有一个输入框和GO按钮，这个就需要写js了，首先在input和button中进行埋点 Go 123button调用go函数并传递总页数接着在staff.js进行编码 function go(sumPage){ var pageNum = $(‘#inputGo’).val(); if(pageNum == null){ alert(“没有负数页码！！！”); }else if(pageNum &gt; sumPage){ alert(“没有数据！！！”); }else if(pageNum &lt; 1){ alert(“没有输入页码！！！”); }else{ $.post(manage.url.page(“queryByPage”), {“pageNum” : pageNum}, function(){ location.href=”/management/list_queryByPage.action?pageNum=” + pageNum; }); }}1首先对输入框的输入的数据进行判断，然后在使用ajax请求，之前在staff.js中统一封装了所有URL，这次再添加一个 var manage = { url : { list : function(key) { return &apos;/management/list_&apos; + key + &apos;.action&apos;; }, addStaff : function(key){ return &apos;/management/staff_&apos; + key + &apos;.action&apos;; }, page : function(key){ return &apos;/management/list_&apos; + key + &apos;.action&apos;; }, } }12345目前就是这么多，以后有其他的再添加使用ajax请求的时候还要传递参数，并且在回调函数中要刷新页面，这里就有个很大的问题，在传递参数的时候，后台就已经执行了一次queryByPage方法了，在回调函数中刷新的页面也传递了参数，后台也执行了一次，所以一共执行了两次，但是目前这个问题我也没解决，如果回调函数中不写那一句的话，虽然后台执行了一遍queryByPage方法，但是前端页面没有变化，也就是没有跳转的相应的URL然后就可以开始Action类的编码了 public String queryByPage(){ //获取request对象，获取前端传递过来的Cookie和通过URL传递的参数 HttpServletRequest request = ServletActionContext.getRequest(); //对传递过来的指定页码进行格式转换 int pageNum = Integer.parseInt(request.getParameter(“pageNum”)); //设置将要跳转的页面的第一条数据的伪列号 int pageStart = ((pageNum - 1) * 5) + 1; //获取全部数据，方便计算总页数 List staffList = staffService.queryStaffList(); //判断页面第一条数据的伪列号是否小于总行数，如果大于，说明没有相应的数据可以显示，直接返回 if(staffList.size() &gt;= pageStart){ //数据存放在List中，第一个元素为0 pageStart = pageStart - 1; for(int i = 1; i &lt;= 5; i++){//设置一个页面最多5条信息 //因为之前已经判断页面第一条数据的伪列号小于总行数，所以至少有一条数据 list.add(staffList.get(pageStart)); pageStart = pageStart + 1; //如果下一条数据的下标等于总行数，说明此时已经没有数据了 if(pageStart == staffList.size()){ break; } } //传递页数和当前页 //1、获取值栈对象 ActionContext context = ActionContext.getContext(); ValueStack stack = context.getValueStack(); //2、调用值栈对象中的set方法 double sumPage = Math.ceil(staffList.size() / 5.0); //向值栈中设置要传递的参数 stack.set(&quot;sumPage&quot;, (int)sumPage); stack.set(&quot;currentPage&quot;, pageNum); return SUCCESS; }123首先是获取Request对象，接收前端页面使用URL传递参数的方式传递过来的数据，但是使用```request.getParameter()```接收的参数的类型是String，这里转换为int然后计算出将要跳转的页面的第一条数据的伪列号，这里使用id是不靠谱的 int pageStart = ((pageNum - 1) * 5) + 1;123比如要跳转到第2页，那么第2页第一条数据的伪列号就是6然后调用queryStaffList方法获取全部数据，接着对数据的长度进行判断，如果总行数小于页面中第一条数据的伪列号，那就说明没有数据；如果大于，就可以进行数据的添加了 list.add(staffList.get(pageStart));123之前设置queryStaffList方法返回的是List，这里就体现了好处，可以获取指定的数据，同时把要显示的数据添加到list中，之后再看在前端页面如何获得如果要取得伪列号为6~10的数据，如果数据库中只有6条数据，那么如果不在循环中加以判断的话 ，会报出空指针异常，所以对接下来的下标进行判断 //如果下一条数据的下标等于总行数，说明此时已经没有数据了if(pageStart == staffList.size()){ break;}12存储完数据，别忘了还要存储总页数和当前页，使得那么分页的按钮能够发挥作用 //传递页数和当前页//1、获取值栈对象ActionContext context = ActionContext.getContext();ValueStack stack = context.getValueStack(); //2、调用值栈对象中的set方法double sumPage = Math.ceil(staffList.size() / 5.0);//向值栈中设置要传递的参数stack.set(“sumPage”, (int)sumPage);stack.set(“currentPage”, pageNum);return SUCCESS;123在计算总页数的时候，如果是6/5的话，获得的是1，无法进1，所以使用小数，之后在转换成int型，或者不转换也可以然后是前端页面如何获取List中的数据 &gt; 删除 12345要实现循环，就要使用Struts2标签的iterator，然后在相应位置使用OGNL表达式来获取每一条数据因为在StaffAction类中的queryByPage方法中至调用了StaffService接口中的queryById方法，所以queryByPage方法的编码就完成了最后是修改execute()中的内容，基本和queryByPage方法中的内容一致 /** 初始化显示*/public String execute(){ int pageStart = 1; List staffList = staffService.queryStaffList(); for(int i = 1; i &lt;= 5; i++){ list.add(staffList.get(pageStart)); pageStart = pageStart + 1; if(pageStart == staffList.size()){ break; } } //传递页数和当前页 //1、获取值栈对象 ActionContext context = ActionContext.getContext(); ValueStack stack = context.getValueStack(); //2、调用值栈对象中的set方法 double sumPage = Math.ceil(staffList.size() / 5.0); stack.set(“sumPage”, (int)sumPage); stack.set(“currentPage”, 1); return SUCCESS;}``` 至此，分页功能完成了，总体写的比较乱，因为还要进行改动，所以思路也比较乱]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java笔记之人员管理模块(四)]]></title>
      <url>%2F2017%2F02%2F27%2FJava%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%BA%BA%E5%91%98%E7%AE%A1%E7%90%86%E6%A8%A1%E5%9D%97-%E5%9B%9B%2F</url>
      <content type="text"><![CDATA[本篇将完成列表页的单条删除和员工管理页的新增员工功能 列表页设计 设计很简陋，使用的是表格和Bootstrap的网格系统，自己最好设计页面，毕竟程序员哪有那么细的分工，这也就是在国内，国外貌似都没有Java工程师、前端工程师等（我也是看新闻的，没去过国外），开始可以有偏重的方向，不过还是要贴一下代码，毕竟埋点什么的要知道在哪123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;%@ include file=&quot;common/tag.jsp&quot; %&gt;&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;%@ include file=&quot;common/head.jsp&quot; %&gt;&lt;title&gt;员工列表页&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;panel panel-default&quot;&gt; &lt;div class=&quot;panel-heading text-center&quot;&gt; &lt;h2&gt;员工列表&lt;/h2&gt; &lt;/div&gt; &lt;div class=&quot;panel-body&quot;&gt; &lt;form id=&quot;mainForm&quot; method=&quot;post&quot;&gt; &lt;table class=&quot;table table-striped&quot;&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;&lt;button class=&quot;btn btn-info&quot; onclick=&quot;deleteMore()&quot;&gt;删除&lt;/button&gt;&lt;/th&gt; &lt;th&gt;&lt;/th&gt;&lt;th&gt;&lt;/th&gt;&lt;th&gt;&lt;/th&gt;&lt;th&gt;&lt;/th&gt;&lt;th&gt;&lt;/th&gt;&lt;th&gt;&lt;/th&gt;&lt;th&gt;&lt;/th&gt; &lt;th&gt;&lt;a class=&quot;btn btn-info&quot; href=&quot;/management/staff&quot; onclick=&quot;deleteCookie()&quot;&gt;员工管理&lt;/a&gt;&lt;/th&gt; &lt;th&gt;&lt;a class=&quot;btn btn-info&quot; href=&quot;/management/position&quot; onclick=&quot;deleteCookie()&quot;&gt;职位管理&lt;/a&gt;&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;&lt;/th&gt; &lt;th&gt;ID&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;性别&lt;/th&gt; &lt;th&gt;职位&lt;/th&gt; &lt;th&gt;薪资&lt;/th&gt; &lt;th&gt;Email&lt;/th&gt; &lt;th&gt;入职时间&lt;/th&gt; &lt;th&gt;&lt;/th&gt; &lt;th&gt;&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;%-- &lt;s:debug&gt;&lt;/s:debug&gt; --%&gt; &lt;s:iterator value=&quot;list&quot; var=&quot;s&quot;&gt; &lt;tr&gt; &lt;td&gt; &lt;div class=&quot;col-lg-6&quot;&gt; &lt;div class=&quot;input-group&quot;&gt; &lt;input type=&quot;checkbox&quot; name=&quot;ids&quot; value=&lt;s:property value=&quot;#s.id&quot;/&gt;&gt; &lt;/div&gt;&lt;!-- /input-group --&gt; &lt;/div&gt;&lt;!-- /.col-lg-6 --&gt;&lt;br&gt; &lt;/td&gt; &lt;td&gt;&lt;s:property value=&quot;#s.id&quot;/&gt;&lt;/td&gt; &lt;td&gt;&lt;s:property value=&quot;#s.name&quot;/&gt;&lt;/td&gt; &lt;td&gt;&lt;s:property value=&quot;#s.gender&quot;/&gt;&lt;/td&gt; &lt;td&gt;&lt;s:property value=&quot;#s.job&quot;/&gt;&lt;/td&gt; &lt;td&gt;&lt;s:property value=&quot;#s.salary&quot;/&gt;&lt;/td&gt; &lt;td&gt;&lt;s:property value=&quot;#s.email&quot;/&gt;&lt;/td&gt; &lt;td&gt;&lt;s:date name=&quot;#s.regDate&quot; format=&quot;yyyy-MM-dd&quot;/&gt;&lt;/td&gt; &lt;!-- &lt;td&gt;&lt;button class=&quot;btn btn-info&quot;&gt;修改&lt;/button&gt;&lt;/td&gt; --&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;button class=&quot;btn btn-info&quot; onclick=&quot;deleteStaffById(&lt;s:property value=&quot;#s.id&quot;/&gt;)&quot;&gt;删除&lt;/button&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/s:iterator&gt; &lt;/tbody&gt; &lt;tfoot&gt; &lt;tr&gt; &lt;th&gt;&lt;/th&gt; &lt;th&gt;&lt;/th&gt; &lt;th&gt;&lt;/th&gt; &lt;th&gt;&lt;/th&gt; &lt;th&gt;&lt;/th&gt; &lt;th&gt;&lt;/th&gt; &lt;th&gt;&lt;/th&gt; &lt;th&gt; &lt;/th&gt; &lt;th&gt; &lt;/th&gt; &lt;th&gt;&lt;/th&gt; &lt;/tr&gt; &lt;/tfoot&gt; &lt;/table&gt; &lt;/form&gt; &lt;div&gt; &lt;div class=&quot;col-lg-offset-6 input-group&quot; &gt; &lt;ul class=&quot;pagination&quot; &gt; &lt;li&gt;&lt;a class=&quot;btn btn-default&quot; href=&quot;/management/list_queryByPage.action?pageNum=1&quot;&gt; 首页 &lt;/a&gt;&lt;/li&gt; &lt;li&gt; &lt;s:if test=&quot;currentPage != 1&quot;&gt; &lt;a class=&quot;btn btn-default&quot; href=&quot;/management/list_queryByPage.action?pageNum=&lt;s:property value=&quot;currentPage - 1&quot;/&gt;&quot;&gt; 上一页 &lt;/a&gt; &lt;/s:if&gt; &lt;/li&gt; &lt;%-- &lt;s:iterator value=&quot;list&quot; var=&quot;s&quot;&gt; &lt;li id=&quot;li1&quot;&gt;&lt;span class=&quot;btn btn-default&quot; id=&quot;num1&quot;&gt;1&lt;/span&gt;&lt;/li&gt; &lt;li id=&quot;li2&quot;&gt;&lt;span class=&quot;btn btn-default&quot; id=&quot;num2&quot;&gt;2&lt;/span&gt;&lt;/li&gt; &lt;li id=&quot;li3&quot;&gt;&lt;span class=&quot;btn btn-default&quot; id=&quot;num3&quot;&gt;3&lt;/span&gt;&lt;/li&gt; &lt;li id=&quot;li4&quot;&gt;&lt;span class=&quot;btn btn-default&quot; id=&quot;num4&quot;&gt;4&lt;/span&gt;&lt;/li&gt; &lt;li id=&quot;li5&quot;&gt;&lt;span class=&quot;btn btn-default&quot; id=&quot;num5&quot;&gt;5&lt;/span&gt;&lt;/li&gt; &lt;/s:iterator&gt; --%&gt; &lt;li id=&quot;li6&quot;&gt;&lt;span &gt; 当前第&lt;s:property value=&quot;currentPage&quot;/&gt;/&lt;s:property value=&quot;sumPage&quot;/&gt;页 &lt;/span&gt;&lt;/li&gt; &lt;li&gt; &lt;s:if test=&quot;currentPage != sumPage&quot;&gt; &lt;a class=&quot;btn btn-default&quot; href=&quot;/management/list_queryByPage.action?pageNum=&lt;s:property value=&quot;currentPage + 1&quot;/&gt;&quot;&gt; 下一页 &lt;/a&gt; &lt;/s:if&gt; &lt;/li&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;inputGo&quot; style=&quot;max-width:20%;&quot;&gt; &lt;span class=&quot;input-group-btn&quot;&gt; &lt;button class=&quot;btn btn-default&quot; id=&quot;go&quot;&gt;Go&lt;/button&gt; &lt;/span&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;!-- jQuery文件。务必在bootstrap.min.js 之前引入 --&gt;&lt;script src=&quot;http://cdn.static.runoob.com/libs/jquery/2.1.1/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;!-- 最新的 Bootstrap 核心 JavaScript 文件 --&gt;&lt;script src=&quot;http://cdn.static.runoob.com/libs/bootstrap/3.3.7/js/bootstrap.min.js&quot;&gt;&lt;/script&gt;&lt;!-- 使用CDN获取公共js --&gt;&lt;!-- jQuery cookie操作插件 --&gt;&lt;script src=&quot;http://cdn.bootcss.com/jquery-cookie/1.4.1/jquery.cookie.js&quot;&gt;&lt;/script&gt;&lt;!-- 引入外部js --&gt; &lt;script src=&quot;resources/js/staff.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;&lt;!-- &lt;script type=&quot;text/javascript&quot;&gt; $(function()&#123; manage.init(&#123; currentPage : &lt;s:property value=&quot;currentPage&quot;/&gt; &#125;); &#125;); --&gt;&lt;/script&gt;&lt;/html&gt; 可以看到，我目前隐藏两个地方，一个是应该和删除一起出现的修改按钮，我的意思是点击修改按钮的时候，在当前页面就可以直接修改对应id的员工信息，而不是再跳转到一个页面再修改，那样和新增员工的操作基本上是类似的 这里要明白自己做一个练手的项目的最初目的，应该大部分都是为了完善自己的技能树，不是为了实现而实现 但是目前还不知道怎么实现这个功能，连搜索的关键字都不知道，所以先放在这 还有一个隐藏的地方就是5个按钮，就是和所有的搜索引擎一样，点击数字跳转到相应页数的页面，分页我已经实现了，默认一共显示5个按钮1~5，但是如果数据有6页，怎样实现在点击大于3的数字的时候，这些按钮上的数字改变为2~6 现在有一些简单的思路： 首先在这个span上做埋点，特别是第一个按钮和最后一个按钮，然后把当前页的数字与第一个按钮、最后一个按钮的数字进行简单的比较 如果当前页数小于第一个按钮与最后一个按钮数字和的平均值，当前所有数字不变 如果当前页数大于第一个按钮与最后一个按钮数字和的平均值，算出差多少，所有数字加多少，这种情况就是要保持当前页数总是两个数字和的平均值 这里先说明一下，因为刚开始的时候对Struts2理解还不深，所以Action写的有点乱，列表页和员工管理页都写在一个Aaction中，当然目前没什么影响，但是比我“洁癖”还大的人，最好还是分开 还有就是我重写了execute()方法，为的就是在刚打开列表页的时候，可以执行一些初始化的程序，但是这个留在后面讲，因为这又是一大堆思考，但是在现在看来，这些方法都是理所当然的，在刚开始的时候，execute()里的内容也很简单123456public String execute()&#123; List&lt;Staff&gt; staffList = staffService.queryStaffList(); HttpServletRequest request = ServletActionContext.getRequest(); request.setAttribute(&quot;staffList&quot;, staffList); return SUCCESS;&#125; 然后是Struts2的配置文件1234&lt;action name=&quot;list_*&quot; class=&quot;management.action.StaffAction&quot; method=&quot;&#123;1&#125;&quot;&gt; &lt;result &gt;/WEB-INF/jsp/list.jsp&lt;/result&gt; &lt;result name=&quot;input&quot; type=&quot;redirect&quot;&gt;/list&lt;/result&gt;&lt;/action&gt; 就是通过request来存储数据，由于数据少，也没限制条数，这也是当时搜了好久才找到的，当时也不太明白，返回数据为啥不是response？再看response中的方法也没有setAttribute方法，当时这样写感觉没什么，后来又改了，所以execute()暂时先这样写 如果想先让数据在列表也显示出来，那么Service层和DAO层以及SQL动态配置可以先接着完成 错误演示先简单说下从最开始的无知到略微明白什么是ajax请求，真的是 有一些东西只有用到的时候，才能看懂 ，之前一直看有关ajax请求的东西，在w3school与菜鸟教程中 都有详细介绍，东西也不多，两个网站的内容基本一样 但是之前真的是不明白怎么用，知道可以不用刷新页面就可以从服务器请求数据，但不知道怎么用，请求数据不应该是http请求？传递过去的数据，应该怎么接收？ 在这里思考的时间还算是少的，之后实现分页功能才叫煎熬，现在既然还是不明白，但是我会用Cookie啊，虽然使用Cookie传递数据不好，但是还好只是单条删除功能，一次只传递一个id就行了，先把功能实现再说，所以有了以下的代码12//list.jsp&lt;td&gt;&lt;button class=&quot;btn btn-info&quot; onclick=&quot;deleteStaffById(&lt;s:property value=&quot;#s.id&quot;/&gt;)&quot;&gt;删除&lt;/button&gt;&lt;/td&gt; 因为要传递参数，所以使用了onclick方法，传递的参数使用Struts2的标签，因为这个删除按钮也是在循环体内，所以很容易取到id，这也是目前我知道的唯一获取对应id的方法，有其他方法的也可以留言 接着是js的代码12345678//错误演示//staff.jsfunction deleteStaffById(id)&#123; $.post(manage.url.list(&quot;deleteById&quot;), &#123;&#125;, function()&#123; $.cookie(&quot;staffId&quot;, id) window.location.reload();//刷新页面 &#125;);&#125; 因为打算使用通配符的方式来调用相应的action中的方法，所以在$.post中的第一个参数传递一个参数，这个字符串就是接下来在action的方法名，并且以后要调用不同的action，所以把url统一封装起来 在staff.js的最上面这样写12345678var manage = &#123; url : &#123; list : function(key) &#123; return &apos;/management/list_&apos; + key + &apos;.action&apos;; &#125; &#125;&#125; 也可以使用这样的方法封装一些经常用到的常量 接着回到上面的错误演示，当时想的是先发送请求，第二个参数是要发送的数据，但是当时我不知道在action中用什么方法来接收，所以就空着，然后是回调函数，当时以为发送完请求就执行回调函数（实际上也是这样的），回调函数执行完之后然后接着才是执行删除操作（这是不对的） 当时写完也试了试，也能正常的删除，除了 需要多点一下 ，当时也没在意，直到开始编写增加员工的代码的时候才发现不对劲，因为增加员工的代码和上面的错误演示完全一样，在执行$.post方法之前先获取用户输入的用户信息，然后在$.post方法的回调函数中对Cookie设置相应的值 当时的现象就是，在第一次新增员工信息的时候，也是需要多点一次，感觉不太应该啊，应该不是网络的问题，每次都要多点一下，然后再输入新增信息的时候，在列表页也多了一条，但是和上次输入的一模一样，也就是有两条完全相同的员工信息 因为当时对$.post方法也不熟悉，然后就是各种瞎想，首先在回调函数中，在向Cookie赋值完之后，再清空Cookie，然后就找各种清楚Cookie的方法，什么重覆盖、有效时间小于当前时间，当然这都是清除Cookie的方法，但是没解决问题，最后不知道怎么想的想到了是不是MyBatis有问题 因为当时比较着急，时间比较紧，所以也没记录当时具体是怎么想的，现在都不明白当时为什么想到MyBatis 最后使用F12查看Cookie的情况加上后端在控制台输出的信息才明白，不是网络的问题，而是点击一次删除按钮，实际已经执行了一次删除操作，执行完删除操作，才执行的$.post方法的回调函数，这时候Cookie中才有数据，然后再点击一次，对应的信息就删除了，其实这时候对post请求还是没理解清楚，也是实现完分页功能后才明白的 GET和POST都是用于请求数据的，只是一个有大小限制，一个没有；一个比较安全，一个不安全，重点是在请求 当时我以为使用post发送一个请求，然后 直接就执行回调函数，接着后台再执行相应操作 ，但实际上， post 是 从服务器请求数据 的作用，后端执行完之后才执行$.post中回调函数内的代码（这句如果说的不对，请指教，因为现在还是小白） 这就体现那句真理 Talk is cheap,Show me the code 作为计算系的学生，GET和POST请求当然很熟悉，但是没动手之前理解不深刻，虽然大学也写了代码，但是都学习算法与数据结构的时候，也就在控制台输出，没有写过前后端通信的项目，所以真的很羡慕那些在大学都明白或者暂时有一个自己比较喜欢的方向的人 然后就理所当然的把回调函数中的代码都放在外面，其实作为新手，单条删除和新增一个员工的操作这样写也未尝不可，直到我为了实现分页功能，挣扎两天后才会使用$.post方法的第二个参数 单条删除功能实现先编写前端部分，主要是js部分12345function deleteStaffById(id)&#123; $.post(manage.url.list(&quot;deleteById&quot;), &#123;&quot;id&quot; : id&#125;, function()&#123; window.location.reload();//刷新页面 &#125;);&#125; 请求的URL实际上是1/management/list_deleteById.action 使用通配符的方式来调用相应的方法，结合着struts.xml文件来看123456&lt;package name=&quot;management&quot; extends=&quot;struts-default&quot; namespace=&quot;/&quot;&gt; &lt;action name=&quot;list_*&quot; class=&quot;management.action.StaffAction&quot; method=&quot;&#123;1&#125;&quot;&gt; &lt;result &gt;/WEB-INF/jsp/list.jsp&lt;/result&gt; &lt;result name=&quot;input&quot; type=&quot;redirect&quot;&gt;/list&lt;/result&gt; &lt;/action&gt;&lt;/package&gt; 因为项目比较简单，所以所有action只有一个package，action的name属性就对应URL中的“list_”，之后跟的是Action类中的方法名，使用通配符的方式可以避免配置文件中的action太多，也因为使用比较灵活，而调用的方法就在class属性规定的类中 在结果集中，如果返回SUCCESS，就返回列表页，第二个name为“input”的结果集是在实现批量删除功能的时候加上的，因为执行完批量删除的操作之后，页面上就没有数据了，原因是URL 接着别着急创建Action类，还要在Spring配置文件中配置相应的bean，打开spring.xml1&lt;bean id=&quot;staffAction&quot; class=&quot;management.action.StaffAction&quot; scope=&quot;prototype&quot;&gt;&lt;/bean&gt; 接着在action包下新建一个StaffAction类1public class StaffAction extends ActionSupport 首先要继承ActionSupport，这样才可以使用SUCCESS、INPUT这样的关键字 还要注入Service层对象12@Autowiredprivate StaffService staffService; 然后是deleteById方法1234567891011/** * 根据ID删除员工信息 * @return * @throws UnsupportedEncodingException */public String deleteById() throws UnsupportedEncodingException&#123; HttpServletRequest request = ServletActionContext.getRequest(); long id = Long.parseLong(request.getParameter(&quot;id&quot;)); staffService.deleteById(id); return SUCCESS;&#125; 在苦想如何实现分页功能的时候，才知道$.post、$.get方法传递的参数在后台都是这样得到的 这里的异常感觉不能这样抛出，应该使用try/catch后使用Spring AOP来进行日志管理 之后就比较顺利了，在service包下新家一个StaffService接口123456/** * 删除员工信息 * @param staffId * @return */void deleteById(long id); 因为暂时不需要返回反馈信息，所以暂时设计为void 然后在service.impl包下新建StaffServiceImpl类，实现StaffService接口1234567891011121314@Servicepublic class StaffServiceImpl implements StaffService &#123; @Autowired private StaffDao staffDao; /** * 根据ID删除员工信息 */ @Transactional public void deleteById(long id) &#123; staffDao.deleteById(id); &#125;&#125; 在类上添加@Service注解，然后注入DAO层对象 接着在dao包下新建StaffDao接口12345678public interface StaffDao &#123; /** * 删除员工信息 * @param staffId * @return */ int deleteById(long id);&#125; 这里设置为void也行，因为暂时不需要返回受影响的行数 接着在mapper目录下新建一个StaffDao.xml文件1234567&lt;!-- 为DAO层接口方法提供SQL语句配置 --&gt;&lt;mapper namespace=&quot;management.dao.StaffDao&quot;&gt; &lt;delete id=&quot;deleteById&quot;&gt; delete from staff where id = #&#123;id&#125; &lt;/delete&gt;&lt;/mapper&gt; 命名空间要在mapper目录下唯一，id要和StaffDao接口中的方法名相同，这样MyBatis才会自动实现DAO层接口，所以这里不需要编写DAO接口的实现类 四、新增员工功能实现对于这个功能我的基本思路是 点击列表也的员工管理按钮，然后跳转到一个新的页面，一次可以提交一个员工信息 首先在列表页设置一个员工管理的按钮1&lt;th&gt;&lt;a class=&quot;btn btn-info&quot; href=&quot;/management/staff&quot; onclick=&quot;deleteCookie()&quot;&gt;员工管理&lt;/a&gt;&lt;/th&gt; 实际上这是一个连接，但是class使用的Bootstrap的按钮样式，所以展现的就是一个按钮，href就是要跳转的页面，至于那个onclick就可以说明我之前所说的，在把对Cookie的操作写到$.post的回调函数内的时候，生怕Cookie的内容不能及时更新，所以还专门写了个清楚Cookie的函数，当然只是清除和员工信息相关的，这个onclick是用不到的，既然知道前后端是如何传递参数的，这次就直奔主题 在webapp/WEB-INF/jsp目录下新建一个staff.jsp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;%@ include file=&quot;common/tag.jsp&quot; %&gt;&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;%@ include file=&quot;common/head.jsp&quot; %&gt;&lt;title&gt;新增员工&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;panel panel-default&quot;&gt; &lt;div class=&quot;panel-heading text-center&quot;&gt; &lt;h2&gt;员工管理&lt;/h2&gt; &lt;/div&gt; &lt;div class=&quot;panel-body&quot;&gt; &lt;%-- &lt;s:form class=&quot;form-horizontal&quot; role=&quot;form&quot; action=&quot;staff_addStaff&quot; method=&quot;post&quot; &gt; --%&gt; &lt;table class=&quot;table table-striped&quot;&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;&lt;/th&gt; &lt;th&gt; &lt;div class=&quot;input-group&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; name=&quot;name&quot; id=&quot;name&quot; placeholder=&quot;姓名&quot;&gt; &lt;/div&gt; &lt;/th&gt; &lt;th&gt; &lt;form role=&quot;form&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;select class=&quot;form-control&quot; name=&quot;gender&quot; id=&quot;gender&quot;&gt; &lt;option&gt;男&lt;/option&gt; &lt;option&gt;女&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;/form&gt; &lt;/th&gt; &lt;th&gt; &lt;form role=&quot;form&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;select class=&quot;form-control&quot; name=&quot;job&quot; id=&quot;job&quot;&gt; &lt;option&gt;Java&lt;/option&gt; &lt;option&gt;美工&lt;/option&gt; &lt;option&gt;前端&lt;/option&gt; &lt;option&gt;PHP&lt;/option&gt; &lt;option&gt;产品&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;/form&gt; &lt;/th&gt; &lt;th&gt; &lt;div class=&quot;input-group&quot;&gt; &lt;input type=&quot;text&quot; calss=&quot;form-control&quot; name=&quot;salary&quot; id=&quot;salary&quot; placeholder=&quot;薪资&quot;&gt; &lt;/div&gt; &lt;/th&gt; &lt;th&gt; &lt;div class=&quot;input-group&quot;&gt; &lt;input type=&quot;text&quot; calss=&quot;form-control&quot; name=&quot;email&quot; id=&quot;email&quot; placeholder=&quot;邮箱&quot;&gt; &lt;/div&gt; &lt;/th&gt; &lt;th&gt;&lt;button class=&quot;btn btn-info&quot; onclick=&quot;addStaff()&quot;&gt;提交&lt;/button&gt;&lt;/th&gt; &lt;th&gt;&lt;a class=&quot;btn btn-info&quot; href=&quot;/management/list&quot; onclick=&quot;deleteCookie()&quot;&gt;返回列表页&lt;/a&gt;&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;/table&gt; &lt;%-- &lt;/s:form&gt; --%&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;!-- jQuery文件。务必在bootstrap.min.js 之前引入 --&gt;&lt;script src=&quot;http://cdn.static.runoob.com/libs/jquery/2.1.1/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;!-- 最新的 Bootstrap 核心 JavaScript 文件 --&gt;&lt;script src=&quot;http://cdn.static.runoob.com/libs/bootstrap/3.3.7/js/bootstrap.min.js&quot;&gt;&lt;/script&gt;&lt;!-- 使用CDN获取公共js --&gt;&lt;!-- jQuery cookie操作插件 --&gt;&lt;script src=&quot;http://cdn.bootcss.com/jquery-cookie/1.4.1/jquery.cookie.js&quot;&gt;&lt;/script&gt;&lt;!-- 引入外部js --&gt; &lt;script src=&quot;resources/js/staff.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;&lt;/html&gt; 这里对数据的传递现在有三种方案： 通过Cookie：虽然管用，但是不建议使用 通过GET或POST请求：最好是使用ajax请求 通过Struts2的ModelDriven：登录页面就是用这种方式，但是在这遇到了至今没解决的问题 先看一下效果图，感觉不舒服的真的要忽略一下，我也是忍着的… 暂时功能实现了就比较满足了，页面粗糙点暂且还在忍受范围内 回到上面说的没解决的问题，那就是在使用Struts2的ModelDriven的时候，第二个选择框也就是选择职位的那个，在后台获取到的是null，就很奇怪，其他数据都可以，把两个选择框调换位置也获取不到职位，貌似使用ModelDriven的时候，只能获取一个选择框的值，还好有三种方案，不行就换别的 先看返回列表的按钮1&lt;th&gt;&lt;a class=&quot;btn btn-info&quot; href=&quot;/management/list&quot; onclick=&quot;deleteCookie()&quot;&gt;返回列表页&lt;/a&gt;&lt;/th&gt; 这里的onclick也是没用的，我留下来就是提醒自己而已，不过这里还有个小需求，就是这样简单粗暴地返回，是返回到第一页，如果数据很多，成千上百页，这个体验就很差了 因为实现了分页功能，所以现在有了点思路，不过 Talk is cheap ，以后慢慢完善 然后是提交按钮1&lt;th&gt;&lt;button class=&quot;btn btn-info&quot; onclick=&quot;addStaff()&quot;&gt;提交&lt;/button&gt;&lt;/th&gt; 对于使用onclick或者jQuery的方式，我比较习惯onclick，一是如果传递参数，使用jQuery的12然后在staff.js中创建名为addStaff的函数 function addStaff(){ var name = $(‘#name’).val(); var email = $(‘#email’).val(); var gender = $(‘#gender’).val(); var salary = $(‘#salary’).val(); var job = $(‘#job’).val(); if(salary &amp;&amp; !isNaN(salary)){ $.post(manage.url.addStaff(“addStaff”), { “name” : name, “gender” : gender, “job” : job, “salary” : salary, “email” : email }, function(){ window.location.reload();//刷新页面 }); }else{ alert(“工资栏应该填写数字！！！”); }}123首先是获取数据，这里对填写的数据的宽容度很大，实际上还要验证的就是email，但是肯定要用到简单的正则表达式，正则以前我也练过，用Python写了个爬百度百科的爬虫，但是好久没用过正则，忘的差不多了然后就是对薪资的判断 if(salary &amp;&amp; !isNaN(salary))1234567第一个条件是salary是否存在，这个主要是为了演示js与Java的区别，js中的变量本身在判断的时候，会转换成Java中的布尔值isNaN函数是判断这个变量是不是非数字，如果是，就为真，所以这里要取反如果判断不通过，在最后弹出个警告；如果判断通过，就使用$.post方法，和删除员工的代码完全一样对于提交的URL，在前面的封装里面还要再添加一个 var manage = { url : { list : function(key) { return &apos;/management/list_&apos; + key + &apos;.action&apos;; }, addStaff : function(key){ return &apos;/management/staff_&apos; + key + &apos;.action&apos;; } } }1可以看到，在Struts2的配置文件中还要添加一个action，打开struts.xml /WEB-INF/jsp/staff.jsp12345对于```staff_*```这种形式的URL，对应的是Action类中的StaffAction类，通配符```*```和method属性对应比如这次传递过来的是```staff_addStaff```，就是执行StaffAction类中的addStaff方法（这个方法暂时还没创建），因为在编写列表页的时候已经在Spring的配置文件中配置了StaffAction的bean，所以这里就不用配置了在StaffAction类中新建一个名为addStaff的方法 /** 添加员工 @return @throws UnsupportedEncodingException*/ public String addStaff() throws UnsupportedEncodingException{HttpServletRequest request = ServletActionContext.getRequest(); String name = request.getParameter(&quot;name&quot;); String gender = request.getParameter(&quot;gender&quot;); String job = request.getParameter(&quot;job&quot;); long salary = Long.parseLong(request.getParameter(&quot;salary&quot;)); String email = request.getParameter(&quot;email&quot;); staffService.addStaff(name, gender, job, salary, email); return SUCCESS; }123原来是Cookie传递数据的时候，因为使用request获得的是一个Cookie数组，还要经过foreach循环才能取到数据，所以还专门封装的一个类，最后返回的是一个Map，不过现在也用不到了接着是在StaffService接口中创建相应的方法 /** 增加员工 @param staff @return*/void addStaff(String name, String gender, String job, long salary, String email);123返回值也是void然后在StaffServiceImpl中实现这个方法 /** 增加员工*/@Transactionalpublic void addStaff(String name, String gender, String job, long salary, String email) { staffDao.addStaff(name, gender, job, salary, email);}123记得在方法上要添加@Transaction注解，使用Spring的声明式事务然后在StaffDao接口创建相应的方法 /** 增加员工 @param staff @return*/int addStaff(@Param(“name”) String name, @Param(&quot;gender&quot;) String gender, @Param(&quot;job&quot;) String job, @Param(&quot;salary&quot;) long salary, @Param(&quot;email&quot;) String email); 123再说一遍，使用MyBatis的时候，如果DAO层接口传递的是多个参数，一定要使用@Param进行绑定，这样MyBatis才知道DAO层接口传递的参数对应SQL语句中的哪个#&#123;&#125;然后打开staffDao.xml文件 insert into staff (id,name,gender,job,salary,email,regdate) values (staff_seq.nextval,#{name},#{gender},#{job},#{salary},#{email},sysdate)```还要提醒的是，id一定要和DAO层接口对应的方法名要一直，最好使用复制粘贴的方式，自己写容易出错 对于id和regdate的值，Oracle数据库没有自增主键，所以使用序列来实现自增主键的效果；sysdate则是Oracle数据库的一个函数，获取的是系统当前时间 至此，最简单的单条删除与新增员工的功能完成了]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java笔记之人员管理模块(三)]]></title>
      <url>%2F2017%2F02%2F25%2FJava%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%BA%BA%E5%91%98%E7%AE%A1%E7%90%86%E6%A8%A1%E5%9D%97-%E4%B8%89%2F</url>
      <content type="text"><![CDATA[本篇将完成登录页面的设计与编码 页面设计关于登录页面，实在是太多了，自己的重点暂时不在前端的页面设计，所以就在菜鸟教程的Bootstrap教程中找了个，复制粘贴后简单的修改了一下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;%@ include file=&quot;common/tag.jsp&quot; %&gt;&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;%@ include file=&quot;common/head.jsp&quot; %&gt;&lt;title&gt;登录页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;panel panel-default&quot;&gt; &lt;div class=&quot;panel-heading text-center&quot;&gt; &lt;h2&gt;登录&lt;/h2&gt; &lt;/div&gt; &lt;div class=&quot;panel-body&quot;&gt; &lt;s:form class=&quot;form-horizontal&quot; role=&quot;form&quot; action=&quot;login&quot; method=&quot;post&quot; &gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;firstname&quot; class=&quot;col-sm-2 control-label&quot;&gt;用户名&lt;/label&gt; &lt;div class=&quot;col-sm-10&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; name=&quot;username&quot; id=&quot;username&quot; placeholder=&quot;请输入用户名&quot; style=&quot;max-width:30%&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;lastname&quot; class=&quot;col-sm-2 control-label&quot;&gt;密码&lt;/label&gt; &lt;div class=&quot;col-sm-10&quot;&gt; &lt;input type=&quot;password&quot; class=&quot;form-control&quot; name=&quot;password&quot; id=&quot;passwrod&quot; placeholder=&quot;请输入密码&quot; style=&quot;max-width:30%&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;div class=&quot;col-sm-offset-2 col-sm-10&quot;&gt; &lt;!-- &lt;div class=&quot;checkbox&quot;&gt; &lt;label&gt; &lt;input type=&quot;checkbox&quot;&gt;请记住我 &lt;/label&gt; &lt;/div&gt; --&gt; ![](Kaptcha.jpg) &lt;a href=&quot;javascript:_change()&quot;&gt;换一张&lt;/a&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; name=&quot;kaptcha&quot; id=&quot;kaptcha&quot; placeholder=&quot;请输入验证码&quot; style=&quot;max-width:15%&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;div class=&quot;col-sm-offset-2 col-sm-10&quot;&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-default&quot; id=&quot;login&quot;&gt;登录&lt;/button&gt; &lt;span id=&quot;show&quot;&gt;&lt;s:actionerror/&gt;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;/s:form&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;!-- jQuery文件。务必在bootstrap.min.js 之前引入 --&gt;&lt;script src=&quot;http://cdn.static.runoob.com/libs/jquery/2.1.1/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;!-- 最新的 Bootstrap 核心 JavaScript 文件 --&gt;&lt;script src=&quot;http://cdn.static.runoob.com/libs/bootstrap/3.3.7/js/bootstrap.min.js&quot;&gt;&lt;/script&gt;&lt;!-- 使用CDN获取公共js --&gt;&lt;!-- jQuery cookie操作插件 --&gt;&lt;script src=&quot;http://cdn.bootcss.com/jquery-cookie/1.4.1/jquery.cookie.js&quot;&gt;&lt;/script&gt;&lt;!-- 引入外部js --&gt; &lt;script src=&quot;resources/js/login.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;&lt;/html&gt; 把“请记住我”的那个复选框改为显示验证码的地方，这里的验证码使用的是现成的组件，叫kaptcha，后面详细说明配置 在最上面和head中，把共通的部分都单独放在外部文件中 在webapp/WEB-INF/jsp/common新建一个tag.jsp，用于存放引入的要使用的标签1&lt;%@ taglib prefix=&quot;s&quot; uri=&quot;/struts-tags&quot;%&gt; 既然后端是Struts2，所以就使用Struts2的标签，对于uri，需要费一点功夫，这个struts-tags.tld文件是在struts2-core-2.3.16的jar包的META-INF目录下的 你需要把struts-tags.tld这个文件放在webapp/WEB-INF目录下，所以就要对struts2-core-2.3.16这个jar包解压缩 我用的是Windows（很想用Linux，老电脑了，在虚拟机Linux太卡），在maven的.m2目录下找到这个jar包，在命令行可以使用unzip这个命令解压 在common目录下新建一个head.jsp，主要存放引入Bootstrap的CSS的CDN链接12345678910&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; charset=&quot;utf-8&quot;&gt;&lt;!-- 引入 Bootstrap --&gt;&lt;link href=&quot;http://cdn.static.runoob.com/libs/bootstrap/3.3.7/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt; &lt;!-- HTML5 Shim 和 Respond.js 用于让 IE8 支持 HTML5元素和媒体查询 --&gt;&lt;!-- 注意： 如果通过 file:// 引入 Respond.js 文件，则该文件无法起效果 --&gt;&lt;!--[if lt IE 9]&gt; &lt;script src=&quot;https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js&quot;&gt;&lt;/script&gt;&lt;![endif]--&gt; 当然，jQuery和Bootstrap的核心文件也是必不可少的123456789&lt;!-- jQuery文件。务必在bootstrap.min.js 之前引入 --&gt;&lt;script src=&quot;http://cdn.static.runoob.com/libs/jquery/2.1.1/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;!-- 最新的 Bootstrap 核心 JavaScript 文件 --&gt;&lt;script src=&quot;http://cdn.static.runoob.com/libs/bootstrap/3.3.7/js/bootstrap.min.js&quot;&gt;&lt;/script&gt;&lt;!-- 使用CDN获取公共js --&gt;&lt;!-- jQuery cookie操作插件 --&gt;&lt;script src=&quot;http://cdn.bootcss.com/jquery-cookie/1.4.1/jquery.cookie.js&quot;&gt;&lt;/script&gt; 这样，一个简单的登录页面就完成了，也不需要埋点，这里简单的在登录按钮后放一个span，用于显示错误信息1&lt;span id=&quot;show&quot;&gt;&lt;s:actionerror/&gt;&lt;/span&gt; 同时使用Struts2标签，当在后端的action中向actionerror中放入要显示的内容，前端页面就可以显示相应的内容，使用过Struts2的标签后感觉真的很神奇，登录界面根本不用写js，因为没有看过底层源码，所以先猜测是使用的值栈，当然以后肯定要去看底层源码的，现在知道这么用就可以了，慢慢来 输入框中的内容可以通过使用Struts2的ModelDriven，很方便的获取到，在主要组件的外层，使用Struts2的标签1&lt;s:form class=&quot;form-horizontal&quot; role=&quot;form&quot; action=&quot;login&quot; method=&quot;post&quot; &gt; 这样在input中输入的内容，就可以被指定的action获取到，input中的name属性要和Action中声明的属性名称要一致 登录页面编码在action包下新建一个LoginAction类，这个类要继承ActionSupport，方便使用特定的关键字，还要实现ModelDriven接口，这个可以方便的获取前端页面输入框中的数据1public class LoginAction extends ActionSupport implements ModelDriven&lt;Login&gt; 同时要对ModelDriven指定类型，因为在login的实体类中也就两个属性，所以这里直接使用Login类123456789101112//这是Login实体类public class Login &#123; private String username; private String password; @Override public String toString() &#123; return &quot;Login [username=&quot; + username + &quot;, password=&quot; + password + &quot;]&quot;; &#125;&#125; 实现ModelDriven接口后要实现它的getModel方法，返回值就是指定的类型123public Login getModel() &#123; return login;&#125; 同时还要实例化指定类型的对象1private Login login = new Login(); 这些就是使用ModelDriven的必要条件，所以如果要获取的数据较多的时候，可以专门封装一个类 然后在Spring的配置文件中spring.xml中进行bean的配置1&lt;bean id=&quot;loginAction&quot; class=&quot;management.action.LoginAction&quot; scope=&quot;prototype&quot;&gt;&lt;/bean&gt; 接着在Struts2的配置文件struts.xml文件中配置action123456&lt;package name=&quot;management&quot; extends=&quot;struts-default&quot; namespace=&quot;/&quot;&gt; &lt;action name=&quot;login&quot; class=&quot;management.action.LoginAction&quot; method=&quot;login&quot;&gt; &lt;result name=&quot;success&quot; type=&quot;redirect&quot;&gt;/list&lt;/result&gt; &lt;result name=&quot;input&quot; &gt;/WEB-INF/jsp/login.jsp&lt;/result&gt; &lt;/action&gt;&lt;/package&gt; 由于项目比较简单，所以所有的action都在这个包下，设置完成后，要访问的路径就是1localhost:8080/management/login 这里指定使用的方法时login方法，也是LoginAction中的唯一方法 然后是结果集，当登录成功是，action返回SUCCESS关键字，就可以跳转到list页面，在这个结果集中使用重定向的方式；如果登录失败，则还是返回登录界面的文件 然后回到LoginAction类中，先自动注入LoginService类，尽管现在还没有12@Autowiredprivate LoginService loginService; 然后编写login方法1234567891011121314public String login()&#123; String username = login.getUsername(); String password = login.getPassword(); if(username == null || password == null)&#123; return &quot;input&quot;; &#125; Login loginInfo = loginService.check(username, password); if(loginInfo == null)&#123; this.addActionError(&quot;登录失败！！！&quot;); return &quot;input&quot;; &#125;else&#123; return &quot;success&quot;; &#125;&#125; 由于对ModelDriven的工作原理不清楚，暂时猜测是前端是Struts2的表单标签，把输入框中的数据放入值栈中，并赋值给ModelDriven中指定类型的实例化对象中，如果不放心的，可以在if判断前面加上输出语句，在控制台输出username和password 123if(username == null || password == null)&#123; return &quot;input&quot;;&#125; 然后就是对获取到是数据进行判断，只要有一个为空，就返回input，在Struts2的配置文件中设置的结果集中，input指向的还是登陆界面 然后是调用Service中的方法，这里虽然Service接口都还建立，但是我们在这里就要设计数据库了，需不需要传递参数，需不需要返回值，要什么类型的返回值 1Login loginInfo = loginService.check(username, password); 我的思路是：向数据库传递登陆界面用户输入的数据，在数据库中进行查询，如果有相同的，就返回相应的数据，只要有一个不满足要求，返回的Login中就是空的 1234if(loginInfo == null)&#123; this.addActionError(&quot;登录失败！！！&quot;); return &quot;input&quot;;&#125; 如果是空的，说明用户输入的信息是不正确的，然后使用addActionError方法，向前端传递错误信息，这个信息会替换前端页面中的标签，然后返回input，也就是登录界面；如果不为空，就跳转到list页面 接着编写Service接口中的方法（这就体现了IDE的好处了）1234567891011public interface LoginService &#123; /** * 验证登录用户 * @param username * @param password * @return */ Login check(String username, String password);&#125; 然后是在service.impl包下新建一个LoginServiceImpl类12345678910111213141516@Servicepublic class LoginServiceImpl implements LoginService &#123; @Autowired private LoginDao loginDao; /** * 验证登录用户 */ @Transactional public Login check(String username, String password) &#123; Login loginInfo = loginDao.check(username, password); return loginInfo; &#125;&#125; 在类上加上@Service注解，同时注入LoginDao接口，尽管还没有建立，然后创建相应的方法，这是在action中就设计好的 接着在dao包下新建一个LoginDao接口12345678public interface LoginDao &#123; /** * 获取指定登录用户信息 */ Login check(@Param(&quot;username&quot;) String username, @Param(&quot;password&quot;) String password);&#125; 由于传递的是多个参数，所以要把参数进行绑定，好让MyBatis知道哪个参数是对应哪个#{}中的内容，@Param中的字符串要和MyBatis的xml文件中#{}的内容一致，如果不这样做，传递过去的数据就是arg1、arg2这样的参数，MyBatis不知道要对应关系 最后在resources/mapper目录下新建一个LoginDao.xml12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt; &lt;mapper namespace=&quot;management.dao.LoginDao&quot;&gt; &lt;select id=&quot;check&quot; resultType=&quot;Login&quot;&gt; select username,password from manage_login where username = #&#123;username&#125; and password = #&#123;password&#125; &lt;/select&gt;&lt;/mapper&gt; mapper中的命名空间要在mapper目录中唯一，这次只使用到查询语句，所以使用select标签，id要和LoginDao接口中的方法名一致，同时要设置返回值类型，可以直接写Login，不用写类的全限定名，因为在MyBatis的配置文件中配置了相关属性 然后就可以开启服务器，在浏览器打开1localhost:8080/management/login 至此，一个基本的登录页面完成了 使用kaptcha验证码组件这一步是可选的，如果不适用验证码，上面配置也算是个合格的登录界面；如果使用验证码就要对前面的内容进行简单的修改 本来想着是看慕课网的视频，然后自己做一个，我是为了节省时间，想着先把验证码的功能实现了，所以直接上组件，虽然验证码的组件很多，但是这个重复造轮子的过程以后还是要学习一下的，只造一遍即可 首先要下载Kaptcha的jar包，在maven下载不了，直接百度一个，通过Build Path加载到项目中 记得要在Order and Export中勾选 如果之后还是报错，如找不到类，可以尝试右键项目，打开Properties，找到Deployment Assembly，点击add-&gt;Java Build Path Entries-&gt;Next，然后就会显示还没添加的jar包，添加后记得点击Apply 然后打开web.xml，开始配置Kaptcha12345678910111213141516&lt;!-- kaptcha验证码组件配置 --&gt;&lt;servlet&gt; &lt;servlet-name&gt;Kaptcha&lt;/servlet-name&gt; &lt;servlet-class&gt;com.google.code.kaptcha.servlet.KaptchaServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;description&gt;图片边框 合法值：yes，no&lt;/description&gt; &lt;param-name&gt;kaptcha.border&lt;/param-name&gt; &lt;param-value&gt;no&lt;/param-value&gt; &lt;/init-param&gt;&lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;Kaptcha&lt;/servlet-name&gt; &lt;url-pattern&gt;/Kaptcha.jpg&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 跟一般的MVC框架一样的配置，init-param中可以配置很多Kaptcha的属性，我就挑了一个 在url-pattern中写的jpg的名称一定要和前端页面img标签中的src属性一致123![](Kaptcha.jpg) &lt;a href=&quot;javascript:_change()&quot;&gt;换一张&lt;/a&gt;&lt;input type=&quot;text&quot; class=&quot;form-control&quot; name=&quot;kaptcha&quot; id=&quot;kaptcha&quot; placeholder=&quot;请输入验证码&quot; style=&quot;max-width:15%&quot;&gt; 前两行代码我没动，直接复制的，input是根据我的页面稍微改了一下，并且加上name属性，为了使Struts2的ModelDriven可以获得input的值 关于a标签的连接，也是目前登录界面的唯一js代码，在webapp/resources/js目录下新建一个login.js，在文章的最开始展示的login.jsp代码中我已经引入过了1234567891011//login.js$(function() &#123; //点击图片本身更换图片 $(&apos;#kaptchaImage&apos;).click(function() &#123; $(this).attr(&apos;src&apos;, &apos;Kaptcha.jpg?&apos; + Math.floor(Math.random() * 100)); &#125;)&#125;);//点击换一张,更换图片function _change() &#123; $(&quot;#kaptchaImage&quot;).attr(&apos;src&apos;, &apos;Kaptcha.jpg?&apos; + Math.floor(Math.random() * 100));&#125; 为了要使用Struts2的ModelDriven，前面定义的类型是Login，所以在Login类中添加一个kaptcha属性，用于存放用户输入的验证码123//Login.java//存放用户输入的验证码信息private String kaptcha; 同时添加getter和setter方法 然后打开LoginAction类，修改一下之前的login方法12345678910111213141516171819202122232425public String login()&#123; cookieMap.get(&quot;password&quot;).toString());*/ String username = login.getUsername(); String password = login.getPassword(); //获取验证码 String kaptchaExpected = (String)ActionContext.getContext().getSession().get(com.google.code.kaptcha.Constants.KAPTCHA_SESSION_KEY); //获取用户输入的验证码 String kaptcha = login.getKaptcha(); //这个判断之所以写在最前面，因为刚打开登录页面的时候input的值就通过Struts2的ModelDriven传递过来了 //刚开始username与password是null，kaptcha是空，所以要先拦截下来 if(kaptcha == null || kaptcha.equals(&quot;&quot;) || username == null || password == null )&#123; return &quot;input&quot;; &#125; if(!kaptcha.equals(kaptchaExpected))&#123; this.addActionError(&quot;验证码错误！！！&quot;); return &quot;input&quot;; &#125; Login loginInfo = loginService.check(username, password); if(loginInfo == null)&#123; this.addActionError(&quot;登录失败！！！&quot;); return &quot;input&quot;; &#125;else&#123; return &quot;success&quot;; &#125;&#125; 首先要修改的是获取页面中的验证码和用户输入的验证码1234//获取页面验证码String kaptchaExpected = (String)ActionContext.getContext().getSession().get(com.google.code.kaptcha.Constants.KAPTCHA_SESSION_KEY);//获取用户输入的验证码String kaptcha = login.getKaptcha(); Kaptcha通过Session来存放页面显示的验证码，而用户输入的验证码就通过Struts2的ModelDriven获得 最开始的判断其实也就是减少一次查询数据库的过程，因为刚打开页面的时候，input的值就传递过来了，username与password是null，kaptcha是空，如果是之前那样没有使用验证码并且没有这个判断的情况下，刚打开页面，后台就要查询一次数据库，所以先进行判断 之后就是再对用户输入的验证码与页面显示的验证码进行比较1234if(!kaptcha.equals(kaptchaExpected))&#123; this.addActionError(&quot;验证码错误！！！&quot;); return &quot;input&quot;;&#125; 好了，现在就可以使用验证码功能了]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java笔记之人员管理模块(二)]]></title>
      <url>%2F2017%2F02%2F21%2FJava%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%BA%BA%E5%91%98%E7%AE%A1%E7%90%86%E6%A8%A1%E5%9D%97-%E4%BA%8C%2F</url>
      <content type="text"><![CDATA[本篇将完成三大框架（Struts2+Spring+MyBatis+Oracle）基本整合工作，作为一个不是跟着视频一步一步做的项目，虽然网上很多例子，非常多，但是作为入门的话，像我这样的小白不自己做一遍，很难掌握其中的要点，所以在整合完框架、明白MVC模式的情况下，如果需要什么功能就添加什么功能就可以了，如果是自己做的话，不会一开始就把每个模块的编码都想的很清楚 基本的目录结构的简历先在src/main/java下建立一个数据库对应的实体包management.entity 在entity包中建立数据库对应的实体类，先是Staff类，对应数据库中的staff表，这种实体类平时改动不多，只有数据库改变，这个实体类才改变1234567891011121314151617181920212223242526272829public class Staff &#123; private long id; private String name; private String gender; private String job; private long salary; private String department; private String email; private Date regDate; @Override public String toString() &#123; return &quot;Staff [id=&quot; + id + &quot;, name=&quot; + name + &quot;, gender=&quot; + gender + &quot;, job=&quot; + job + &quot;, salary=&quot; + salary + &quot;, fepartment=&quot; + department + &quot;, email=&quot; + email + &quot;, regDate=&quot; + regDate + &quot;]&quot;; &#125;&#125; 重写toString方法，并生成getter和setter方法，这里就不显示了 接着是Position类，用于存储职位信息123456789101112public class Position &#123; private long id; private String job; @Override public String toString() &#123; return &quot;Position [id=&quot; + id + &quot;, job=&quot; + job + &quot;]&quot;; &#125;&#125; 数据库的行名要与实体类的属性名完全一样 ，不用担心数据库中使用的是下划线，而Java使用的是驼峰命名，后面MyBatis配置中可以开启驼峰命名转换，会把执行后的结果中下划线转换为驼峰命名，如果这里不一样，后面测试的时候虽然会成功连接数据库，但是获取的都是null 接着在src/main/java目录下建立以下包： management.dao：存放对存储工具操作的接口 management.service：存放业务相关方法的接口 management.service.impl：存放实现Service层接口的实现类 management.action：存放Controller层相关代码，写成action是由于Struts2的关系，其实应该都一样 management.exception：存放自定义异常 management.dto：存放浏览器与Java客户端之间数据通信有关的类 代码相关的目录结构基本完成，肯定不够，后面需要再加 Spring与MyBatis整合所有的配置文件都存放在src/main/resources目录下，先在该目录下新建一个mybatis-config.xml文件123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt; &lt;configuration&gt; &lt;!-- 配置全局属性 --&gt; &lt;settings&gt; &lt;!-- 使用列别名替换列名 默认为true --&gt; &lt;setting name=&quot;useColumnLabel&quot; value=&quot;true&quot;/&gt; &lt;!-- 开启驼峰命名转换 --&gt; &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt; &lt;/settings&gt;&lt;/configuration&gt; 暂时用到的属性不多，我也没在官网上都看一遍，暂时用不到，看了也忘了，索性用到再看，熟练了之后应该就记得差不多了 再在resources目录下新建一个jdbc.properties文件，用于配置连接数据库所需要的参数1234db.driver=oracle.jdbc.driver.OracleDriverdb.url=jdbc:oracle:thin:@localhost:1521:orcldb.user=scottdb.password=tiger 这是连接Oracle数据库的写法，不同数据库的driver和url都是不一样的 然后是Spring的配置文件，原本我是把Spring的配置文件按照MVC的层次来分的，但是配置监听器的时候总是提示找不到ContextLoaderListener，这还了得，又用maven换了几个Spring版本，spring-core下载的是真慢，网上查的时候都是一个配置文件，本来不甘心那么多东西都放在一个文件中，但是现在一个功能还没写呢，不想把时间浪费在这里，所以最后还是复制到一起了 在resources目录下新建一个spring.xml文件，虽然是一个文件，但是我把相关配置还是分成MVC的层次来管理 首先是整体配置12&lt;!-- 自动扫描需要Spring容器管理的包 --&gt;&lt;context:component-scan base-package=&quot;management.service,management.dao,management.dto&quot; /&gt; 现在用到的就这一个，其他的也不知道，出了问题再说，基本上 小白们及刚入行的，不用关心也不要想一步配置到位，基本的配置完成就行，属性太多，记是没用的，如果这些配置就能完成我们需要的功能，何必写一些多余的配置，更不用担心出问题，这个阶段的要的就是出问题，有问题解决了才能提高 接着是DAO层需要的配置123456789101112131415161718192021222324252627282930313233343536&lt;!-- DAO层 --&gt;&lt;!-- 加载数据库相关参数 --&gt;&lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt;&lt;!-- 配置数据库连接池 --&gt;&lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;!-- 配置连接池属性 --&gt; &lt;property name=&quot;driverClass&quot; value=&quot;$&#123;db.driver&#125;&quot;/&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;$&#123;db.url&#125;&quot;/&gt; &lt;property name=&quot;user&quot; value=&quot;$&#123;db.user&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;db.password&#125;&quot;/&gt; &lt;!-- 配置连接池私有属性 --&gt; &lt;!-- 关闭连接后不自动commit --&gt; &lt;property name=&quot;autoCommitOnClose&quot; value=&quot;false&quot;/&gt;&lt;/bean&gt;&lt;!-- 配置SqlSessionFactory对象 --&gt;&lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;!-- 注入数据库连接池 --&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;!-- 配置MyBatis全局配置文件，即mybatis-config.xml --&gt; &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;/&gt; &lt;!-- 扫描entity包，使用别名 省略包名 --&gt; &lt;property name=&quot;typeAliasesPackage&quot; value=&quot;management.entity&quot;/&gt; &lt;!-- 扫描SQL配置文件 即mapper目录下的xml文件 --&gt; &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:mapper/*.xml&quot;/&gt;&lt;/bean&gt;&lt;!-- 配置扫描DAO接口包 动态实现DAO接口并注入到Spring容器中 --&gt;&lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt; &lt;!-- 注入SqlSessionFactory --&gt; &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot;/&gt; &lt;!-- 扫描DAO层下的接口 --&gt; &lt;property name=&quot;basePackage&quot; value=&quot;management.dao&quot;&gt;&lt;/property&gt;&lt;/bean&gt; 这个应该基本就是DAO层需要的最少配置了，虽然现在还没参加工作，但是感觉这就是最基本的配置了 然后是Service层123456789&lt;!-- 配置事务管理器 --&gt;&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;!-- 注入数据库连接池 --&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;&lt;/bean&gt;&lt;!-- 配置基于注解的声明式事务：默认使用注解来管理事务行为 --&gt;&lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot; /&gt; 暂时也不介绍这些配置了，有一些东西比如自动包扫描、配置数据库连接池这些配置比较显而易见的好理解，但是这个DataSource也有很多内容，而像SqlSessionFactory、MyBatis动态实现DAO接口这些配置需要深入的了解JDBC和MyBatis的原理，这也是我现在要掌握的内容，所以在我没掌握之前，现在就不瞎说了 Spring与Struts2整合之web.xmlSpring与Struts2的整合基本的就是web.xml文件，整个项目运行的时候，所有的请求都会先找到web.xml，被web.xml中的WEB层框架所拦截，比如Struts2、Spring MVC等 Spring MVC与Spring从名字就可以看出，实际上都是一个东西，只不过把WEB层的内容抽离出来，二者之间的配置也很容易 而Struts2与Spring之间的配置，以我现在的程度的理解，就是根据action类来配置的，所以以后需要什么action，到时候再配置，现在也无法全部配置完 12345678&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot; version=&quot;3.1&quot; metadata-complete=&quot;true&quot;&gt; &lt;!-- 修改Servlet的版本为3.1 模板在Tomcat根目录下的webapps\examples\WEB-INF --&gt;&lt;/web-app&gt; 接着是Struts2的核心配置，类似Spring MVC的配置123456789&lt;filter&gt; &lt;filter-name&gt;management&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt;&lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;management&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; Spring MVC的核心控制器就是前端控制器，即DispatcherServlet，本质上就是一个Servlet，而Struts2主要的就是过滤器，所有的请求都会经过一系列的过滤器，其中最核心的就是StrutsPrepareAndExecuteFilter 2.1.3版本之后的核心过滤器就是StrutsPrepareAndExecuteFilter，其中还有一个小坑， 在2.3版本之前（具体小版本不清楚，可以看相应的jar包），是要写成上面这样的，2.3版本以后需要把“ng”去掉 同样在filter-mapping中过滤所有的请求，如果是实际工作中，这些配置要求应该都是经过讨论的 然后配置Spring的监听器12345678&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring.xml&lt;/param-value&gt;&lt;/context-param&gt; 如果你的Spring配置文件放在/WEB-INF/目录下，并且命名为applicationContex.xml的时候可以不用配置context-param，因为Spring监听器加载Spring配置文件的时候，会先在WEB-INF目录下寻找applicationContext.xml的文件，如果没有，再在context-param中提供的路径寻找 这些是最基本的配置，因为后面要用到FreeMarker，而要让Struts2在FreeMarker支持标签功能，还要下面的配置12345&lt;servlet&gt; &lt;servlet-name&gt;JspSupportServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.apache.struts2.views.JspSupportServlet&lt;/servlet-class&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt; 并且设置启动优先级为最高 至此，基本的目录结构及三大框架的基本配置就完成了]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java笔记之人员管理模块(一)]]></title>
      <url>%2F2017%2F02%2F21%2FJava%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%BA%BA%E5%91%98%E7%AE%A1%E7%90%86%E6%A8%A1%E5%9D%97-%E4%B8%80%2F</url>
      <content type="text"><![CDATA[这个模块主要就是实现增删改查和权限控制的功能，第一次自己独立完成一个模块，用的时间还是比较长的，但是一回生，二回熟，所以之后就会轻松点，这个系列是对纯小白的，所以有点经验的就不需要看了，就连我做完之后就感觉花的时间有点相当的长，不过收获还是很多的，总之， 看三遍基础视频，如果不用，几个月就忘了，那么面试时候的回答会让别人有“你真的知道什么是Java？Hello World都没写过吧？”的直观感受 前言本篇将完成准备工作 使用maven创建项目 建立数据库 准备工作这次后端使用的框架为Struts2+Spring+MyBatis+Oracle，由于之前做的秒杀系统是典型的SSM框架，所以本篇就长话短说，在熟练使用SQL之前持久层不会换成Hibernate 使用maven建立项目的过程就省略了，直接看引入的依赖1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980 &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- 将junit版本由3.8.1改为4.11 因为junit3.0是默认使用编程的方式 4.0的默认使用注解的方式来运行junit --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;1.7.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-core&lt;/artifactId&gt; &lt;version&gt;1.1.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 实现slf4j接口并整合 --&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.1.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Oracle数据库相关依赖(需要手动下载) --&gt;&lt;dependency&gt; &lt;groupId&gt;c3p0&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- DAO框架:Mybatis相关依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Mybatis自身实现Spring的整合依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Servlet Web相关依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;taglibs&lt;/groupId&gt; &lt;artifactId&gt;standard&lt;/artifactId&gt; &lt;version&gt;1.1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.5.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/dependency&gt; 接着是Spring相关依赖12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;!-- Spring依赖 --&gt; &lt;!-- Spring核心依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;3.1.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;3.1.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;3.1.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;3.1.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Spring Dao层的依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;3.1.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;3.1.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-orm&lt;/artifactId&gt; &lt;version&gt;3.1.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Spring WEB相关的依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;3.1.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Spring test相关的依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;3.1.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; 有关数据库的依赖，Ojdbc14是收费的，maven的仓库中没有，Ojdbc6是不收费的，但不知为何也无法从maven中下载，而且我在官网上下载的时候总是停在99.2%，N次都是这样，所以百度一个就行，然后在项目中手动的引用 下面引入Struts2的依赖123456789101112131415161718192021222324252627282930313233 &lt;!-- Struts2相关依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.struts&lt;/groupId&gt; &lt;artifactId&gt;struts2-core&lt;/artifactId&gt; &lt;version&gt;2.3.16&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.struts&lt;/groupId&gt; &lt;artifactId&gt;struts2-spring-plugin&lt;/artifactId&gt; &lt;version&gt;2.3.4.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.struts&lt;/groupId&gt; &lt;artifactId&gt;struts2-convention-plugin&lt;/artifactId&gt; &lt;version&gt;2.3.20&lt;/version&gt;&lt;/dependency&gt;&lt;!--config-browser-plugin插件，使用了这个插件之后， 就可以很方便的浏览项目中的所有action及其与 jsp view的映射 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.struts&lt;/groupId&gt; &lt;artifactId&gt;struts2-config-browser-plugin&lt;/artifactId&gt; &lt;version&gt;2.3.20&lt;/version&gt;&lt;/dependency&gt; &lt;!-- struts2的json依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.struts&lt;/groupId&gt; &lt;artifactId&gt;struts2-json-plugin&lt;/artifactId&gt; &lt;version&gt;2.3.4&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt;&lt;/dependency&gt; 建立数据库本次项目使用的数据库是Oracle 11g，安装过程就不赘述了，很简单，在安装过程中输入的密码就是以后sys/system用户的密码 首先登陆Oracle的system用户来建立表空间，可以使用SqlPlus，也可以使用图形化工具SQLDeveloper，建议从官网上下载图形化工具123system/你的密码 或者sys/你的密码 as sysdba 1234567-- 创建表空间create tablespace management datafile &apos;management.dbf&apos; size 10m -- 数据文件初始大小autoextend on -- 表空间容量不足时自动扩展next 5m -- 表空间每扩展一次增加5m; 该表空间初始大小为10M，当容量不足时会自动扩展，每次扩展5M，也可以设置空间容量上限和下限 建立员工信息表12345678910111213141516171819202122232425-- 创建员工表，先查看user_objects表中是否存在相同名称的表，如果有就删除prompt create table staff 员工信息表...declare rowcount number(10);begin select count(*) into rowcount from dual where exists( select * from user_objects where object_name = upper(&apos;staff&apos;) ); if rowcount = 1 then execute immediate &apos;drop table staff&apos;; end if;end;/create table staff( id number(12,0) not null primary key, name varchar2(125), gender number(1,0),-- 0:male 1:female job varchar2(20), salary number(12,0), department varchar2(20), email varchar2(125), regdate date) tablespace management; 在创建表之前，先判断数据库中有没有相同名称的表，数据库中表的信息都存放在user_objects中，如果里面有相同名称的表，就立刻删除它 创建表最后指定表存放在management表空间中 由于Oracle不支持自增主键（感觉好不方便），可以使用Oracle的序列123-- 创建序列，实现自增主键功能-- 使用方法：在执行insert语句的时候，在主键的值中调用序列的nextval方法，即management_primary_key.nextvalcreate SEQUENCE staff_seq start with 1 increment by 1 ; SEQUENCE关键字后面跟序列名 start with：开始值 increment by：每次增加的个数 使用方法 nextval：返回序列中下一个有效的值，任何用户都可以引用 currval：存放序列的当前值 这些都是一部分，还有一些参数和方法本项目没有用到，就不提了 建立职位表1234567891011121314151617181920prompt create table position 职位表...declare rowcount number(10);begin select count(*) into rowcount from dual where exists( select * from user_objects where object_name = upper(&apos;positon&apos;) ); if rowcount = 1 then execute immediate &apos;drop table position&apos;; end if;end;/create table position( id number(10) not null primary key, job varchar2(20) not null)tablespace management;-- 创建职位表的自增序列create SEQUENCE position_seq start with 1 increment by 1; 虽然职位表的内容比较固定，但是还是使用序列来实现自增主键 插入数据1234567891011121314151617181920-- 插入员工测试数据insert into staff(id,name,gender,job,salary,email,regdate) values(staff_seq.nextval,&apos;小明&apos;,0,&apos;Java&apos;,2500,&apos;xiaoming@gmail.com&apos;,sysdate);insert into staff(id,name,gender,job,salary,email,regdate) values(staff_seq.nextval,&apos;小花&apos;,1,&apos;美工&apos;,2000,&apos;xiaohua@gmail.com&apos;,sysdate);insert into staff(id,name,gender,job,salary,email,regdate) values(staff_seq.nextval,&apos;小红&apos;,1,&apos;前端&apos;,3000,&apos;xiaohong@gmail.com&apos;,add_months(sysdate,-6));insert into staff(id,name,gender,job,salary,email,regdate) values(staff_seq.nextval,&apos;小王&apos;,0,&apos;PHP&apos;,2500,&apos;xiaowang@gmail.com&apos;,add_months(sysdate,-3));insert into staff(id,name,gender,job,salary,email,regdate) values(staff_seq.nextval,&apos;小张&apos;,0,&apos;产品&apos;,4000,&apos;xiaozhang@gmail.com&apos;,add_months(sysdate,-12));-- 插入职位表数据insert into position(id,job) values(position_seq.nextval,&apos;Java&apos;);insert into position(id,job) values(position_seq.nextval,&apos;PHP&apos;);insert into position(id,job) values(position_seq.nextval,&apos;美工&apos;);insert into position(id,job) values(position_seq.nextval,&apos;前端&apos;);insert into position(id,job) values(position_seq.nextval,&apos;产品&apos;); 因为有登录界面，所以还要有一个存储登录用户的表，也方便以后进行权限管理1234567891011121314151617181920212223-- 创建登录用户信息表prompt create table management_login 登录用户信息表...declare rowcount number(10);begin select count(*) into rowcount from dual where exists( select * from user_objects where object_name = upper(&apos;manage_login&apos;) ); if rowcount = 1 then execute immediate &apos;drop table manage_login&apos;; end if;end;/create table manage_login( id number(12) not null primary key, username varchar2(100) not null, password varchar2(100))tablespace management;-- 创建登录用户信息表自增主键序列create SEQUENCE mlogin_seq start with 1 increment by 1; 插入测试数据1234567-- 插入登录用户信息数据insert into manage_login(id,username,password) values(mlogin_seq.nextval,&apos;admin&apos;,&apos;admin&apos;);insert into manage_login(id,username,password) values(mlogin_seq.nextval,&apos;小明&apos;,&apos;xiaoming&apos;);insert into manage_login(id,username,password) values(mlogin_seq.nextval,&apos;小王&apos;,&apos;xiaowang&apos;); 准备工作基本完成，以后有需求再添加]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java笔记之高并发秒杀API(终)]]></title>
      <url>%2F2017%2F02%2F14%2FJava%E7%AC%94%E8%AE%B0%E4%B9%8B%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A7%92%E6%9D%80API-%E7%BB%88%2F</url>
      <content type="text"><![CDATA[其实什么都是借口，要达到相应的级别，就需要一万小时定律，不是看看视频就可以的 终于使用框架完成了一个完整的项目，虽然是跟着视频做的，但是作为没有项目经验的我来说这是快速入门的一个方法，通过这样的方式可以大概的了解这些框架的使用方法 如果有实习，这样跟着视频做完整的项目的方式根本不需要，因为有实际的项目可以学习 如果还没有工作，这样的方式也只能在刚开始使用一次，可以快速的了解这些框架是如何整合在一起的，虽然很多时候不理解为什么这样写，不理解的地方可以Google，最好是看文档 当你明白了视频中为什么这样做的时候，你也只是有了阅读源码的能力，而且阅读还是类似于视频中使用的方法，如果其他人不这样写，你可能就又不理解了 最重要的是自己可以独立的完成，明白各个框架是如何整合的，都承担了什么工作，其余的完全可以通过Google、查看文档来完成，这与跟着视频一步步敲代码的区别很大，最起码看完视频后凭记忆自己再写一遍也是可以的 现在我对Java WEB开发的主流框架的分工和相互的整合也算有了整体的认识，开源的框架暂时先不去了解，先把主流的掌握再说 接下来要重新补补Java的基础知识，之前是光看不练，一直重复看，生怕没掌握，结果还是没记住，然后再找个需求，自己试着完成，虽然看文档比较痛苦，看着看着眼神就涣散了，但好歹大部分都有中文的，比起以前算是相当的不错了 这个项目的源码就不贴了，GitHub上肯定有不少相同的代码，我也敢肯定连jsp页面都一样，我也上传了，算是给自己GitHub的contributions上添点绿]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java笔记之高并发秒杀API(六)]]></title>
      <url>%2F2017%2F02%2F03%2FJava%E7%AC%94%E8%AE%B0%E4%B9%8B%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A7%92%E6%9D%80API-%E5%85%AD%2F</url>
      <content type="text"><![CDATA[本篇将完成高并发优化，包括： Redis后端缓存优化 并发优化 高并发优化分析在优化之前要明白高并发发生在哪 红色的部分是可能出现高并发的点，绿色部分则没有影响 当用户进入详情页的是时候，如果秒杀没有开始，在页面就会显示倒计时，如果开始了，就会显示执行秒杀操作的按钮，接着是执行秒杀操作，最后是返回结果 获取系统时间在详情页，当秒杀还没开始的时候，用户会不断的刷新页面，这是很有可能的，这就会造成大量的请求，详情页实际应该部署到CDN节点上，CDN会把详情页做静态化处理，详情页当中还有许多获取静态资源的请求，这些静态资源也会部署到CDN上 CDN的全称是Content Delivery Network，即内容分发网络。其基本思路是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。通过在网络各处放置节点服务器所构成的在现有的互联网基础之上的一层智能虚拟网络，CDN系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。其目的是使用户可就近取得所需内容，解决 Internet网络拥挤的状况，提高用户访问网站的响应速度。 ——百度百科 当详情页部署在CDN上的时候，这些获取静态资源的请求是不用访问系统，这样也会导致获取不到系统时间，无法对是否开启秒杀做判断，所以要单独的获取时间 也就是，在详情页可能会有大量的获取静态资源的请求，无论是在秒杀开始前还是秒杀开始后，对于这种有可能出现高并发的地方，其中一种的措施是把详情页部署在CDN中，这样不同的用户会请求距离最近的CDN节点来获取这些静态资源，但是这些请求是不用访问系统的，为了时刻获取到系统时间，所以就要从系统中获取时间 那么从系统中获取时间的操作需不需要优化呢？ 从系统中获取时间不需要优化 Java访问一次内存(Cacheline)大约10ns，1秒等于十亿纳秒，当我们访问系统时间，本质上也就是new了一个日期对象，然后返回给用户，在理想状态下，这个操作可以1秒中实现一亿次，没有后端的访问，所以这个操作可以不用优化 秒杀地址接口分析秒杀地址接口无法使用CDN缓存，因为CDN适合对于请求的资源不宜变化的，但是秒杀地址的返回数据是在变化的，随着时间的推移，秒杀活动从未开始到结束，这都是不断变化的 但是适合使用服务器端缓存，比如Redis，先访问数据库，获取到了秒杀的数据，然后放到Redis缓存中，当下一次访问的时候，直接在缓存中查找，缓存中如果有相应的数据，直接返回，而不用再访问数据库 秒杀操作优化分析该操作同样也不能使用CDN缓存，大部分的写操作和核心部分的请求一般无法使用CDN缓存，并且后端缓存困难，因为库存问题，极短的时间内都要对数据库进行更新操作，无法使用缓存技术，否则会出现不一致的错误 Java控制事务行为分析 当事务开启的时候，另一个事务要对数据库的同一行进行操作，在当前事务没有commit或者rollback之前，其他事务是无法执行的，此时，正在执行的事务获得了数据库该行的行级锁 当然，如果一个事务持有行级锁的时间极短的话，也可以忽略，但是实际的情况并没有那么理想 客户端执行update减库存操作，获取到执行后的结果，然后SQL语句会通过网络把结果返回给MySQL的时候，网络延迟是必须考虑的，还要考虑的就是GC Java GC：(Garbage Collection)垃圾回收机制 GC又分新生代GC和老生代GC，GC不一定每次出现，但是一定会出现 具体关于GC的内容有很多，这也是成为Java开发人员必须要理解掌握的，我作为初学者，也没有深入了解过GC，水平有限，这里只是先提到，要成为Java开发者，GC是避不开的 当Java客户端执行这个事务的时候，Java客户端和数据库之间的网络延迟和可能的GC会持续较长时间，特别对于秒杀系统来说，行级锁的持有时间是一定要优化的 对异地机房之间的通信做一个简单的分析 也就是上海机房和北京机房之间的通讯(一来一回)大约需要13毫秒，这是理想状态，实际应该在20毫秒左右，也就是1秒最多执行50次相同的操作 所以优化的思路是： 把客户端逻辑放在MySQL服务端，避免网络延迟和GC的影响，从而减少行级锁的持有时间 Redis后端缓存优化首先是Redis安装，这个就不多说了，Windows的最好下载MSI，Linux用户可以下载安装包，在控制台进入Redis目录，使用make、make install安装Redis 使用redis-server命令启动Redis，这里只是简单的使用Redis，所以就使用Redis默认的配置 使用redis-cli -p 6379命令连接Redis，默认的端口就是6379 要使用Java访问Redis，需要在pom.xml中添加相应的依赖，首先是引入的是Redis的客户端Jedis，在Redis官网中可以看到各种语言访问redis的客户端是什么 星号代表的是推荐的客户端，接着引入Jedis123456&lt;!-- redis客户端：jedis --&gt;&lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;2.7.3&lt;/version&gt;&lt;/dependency&gt; 因为要优化的是秒杀暴露接口，所以打开SeckillServiceImpl类，找到exportSeckillUrl方法1Seckill seckill = seckillDao.queryById(seckillId); 要优化的地方就是这一步，对数据库的操作，所有秒杀单都要请求暴露秒杀地址接口，可以使用Redis缓存起来，这样可以降低数据库的访问压力 使用Redis常用的基本的逻辑是： 先从cache中取数据，如果cache中有相应的数据，则直接返回，如果cache中没有数据，则从数据库中获取数据，获得的数据先put到cache中，然后返回给用户 为了后期维护和可扩展性，肯定不能把这些逻辑直接写在业务代码中，也就是不能直接现在SeckillServiceImpl类的exportSeckillUrl方法中 之前说过对数据库或者是其他用于存储的类所在的包是DAO，也就是数据访问对象，在Dao包下新建一个cache包，在cache包下新建一个RedisDao类12345678910public class RedisDao &#123; private final Logger logger = LoggerFactory.getLogger(this.getClass()); private final JedisPool jedisPool; public RedisDao(String ip, int port)&#123; jedisPool = new JedisPool(ip, port); &#125;&#125; 要在后台打印信息，所以使用slf4j，之前已经引入了Jedis的依赖，所以可以直接使用，有点类似于数据库连接池的ConnectionPool 然后初始化一个构造方法，出入ip和port，用于连接Redis，因为本项目只是简单的运用Redis，不需要复杂的配置，所以直接初始化JedisPool即可 这个类是对Redis进行操作，我们使用Redis是要从缓存中获取Seckill对象，如果缓存中没有，还要对数据库进行操作，并把数据存放在缓存中12345678910111213141516171819202122232425262728/** * 从Redis获取数据，由于在redis中的数据都是字节数组，所以需要对数据进行反序列化，转化为想要的类型对象 * @param seckillId * @return */public Seckill getSeckill(long seckillId)&#123; //redis操作逻辑 try&#123; Jedis jedis = jedisPool.getResource(); try&#123; String key = &quot;seckill: &quot; + seckillId; //没有实现内部序列化操作，采用自定义序列化 byte[] bytes = jedis.get(key.getBytes()); if(bytes != null)&#123; //空对象 Seckill seckill = schema.newMessage(); ProtostuffIOUtil.mergeFrom(bytes, seckill, schema); //seckill被反序列 return seckill; &#125; &#125; finally &#123; jedis.close(); &#125; &#125; catch(Exception e) &#123; logger.error(e.getMessage(), e); &#125; return null;&#125; 这个方法用于从Redis中获取数据 首先是获取到Jedis对象，使用了Jedis就要关闭，所以在接下来的逻辑还要再try/catch，在finally中关闭Jedis 1byte[] bytes = jedis.get(key.getBytes()); 由于Redis并没有实现内部序列化操作，所以在Redis中存储的数据均为字节码数组，所以就要通过反序列化获取到Object数据，也就是Seckill对象 在GitHub上专门有一个对Java序列化技术的性能比对 本项目采用自定义序列化，使用的是protostuff，需要两个依赖123456789101112&lt;!-- 自定义序列化技术 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.dyuproject.protostuff&lt;/groupId&gt; &lt;artifactId&gt;protostuff-core&lt;/artifactId&gt; &lt;version&gt;1.0.12&lt;/version&gt;&lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.dyuproject.protostuff&lt;/groupId&gt; &lt;artifactId&gt;protostuff-runtime&lt;/artifactId&gt; &lt;version&gt;1.0.12&lt;/version&gt;&lt;/dependency&gt; 这样就可以实现把一个对象转换成二进制数组，然后传到Redis中 使用protostuff的API，全局的定义一个动态的schema，是由protostuff自定转换的，对性能几乎没影响1private RuntimeSchema&lt;Seckill&gt; schema = RuntimeSchema.createFrom(Seckill.class); class对象代表类的字节码对象，也就是这个类的类类型，可以通过反射获取到这个类有哪些属性和方法，RuntimeSchema就是基于传递参数的字节码对象来做一个模式，当创建对象的时候，会根据不同的模式赋予相应的值 序列化就是根据字节码和字节码所对应的对象有哪些属性，把字节码的数据传递给那些属性，这样就可以序列化好一个对象 传递的参数是这个对象的class，也就是这个对象的类类型，再传递一个类似schema的内容，会描述这个对象的结构 回到getSeckill方法中1234567//Redis没有实现内部序列化操作，采用自定义序列化byte[] bytes = jedis.get(key.getBytes()); if(bytes != null)&#123; Seckill seckill = schema.newMessage(); ProtostuffIOUtil.mergeFrom(bytes, seckill, schema); return seckill;&#125; 使用Jedis的get方法，返回的是字节码数组，然后对字节码数组进行判断，如果bytes不为空，则是从Redis中获取到了数据，然后使用protostuff进行转换 protostuff提供了一个Util工具类来进行转换，需要传递的参数有这个对象的字节码数组，空的对象，和自定义的模式schema，然后protostuff就会把字节码数组按照传入的模式，即schema，将数据传入空对象中，这样Seckill对象就已经被赋值了，这样就是把一个字节数组转化为我们想要的对象，也就是对象反序列化 当Redis缓存中有数据的时候，使用getSeckill方法可以获取到数据，当Redis缓存中没有数据的时候，还需要向Redis缓存中存放数据123456789101112131415161718192021222324/** * 把数据放入Redis中时，需要对数据进行序列化，转化为字节数组 * @param seckill * @return */public String putSeckill(Seckill seckill)&#123; try&#123; Jedis jedis = jedisPool.getResource(); try&#123; String key = &quot;seckill: &quot; + seckill.getSeckillId(); byte[] bytes = ProtostuffIOUtil.toByteArray(seckill, schema, LinkedBuffer.allocate(LinkedBuffer.DEFAULT_BUFFER_SIZE)); //超时缓存 int timeout = 60 * 60;//一小时 String result = jedis.setex(key.getBytes(), timeout, bytes); return result; &#125; finally &#123; jedis.close(); &#125; &#125; catch(Exception e) &#123; logger.error(e.getMessage(), e); &#125; return null;&#125; 大部分代码和getSeckill方法相同，主要分析不同部分1234567891011try&#123; String key = &quot;seckill: &quot; + seckill.getSeckillId(); byte[] bytes = ProtostuffIOUtil.toByteArray(seckill, schema, LinkedBuffer.allocate(LinkedBuffer.DEFAULT_BUFFER_SIZE)); //超时缓存 int timeout = 60 * 60;//一小时 String result = jedis.setex(key.getBytes(), timeout, bytes); return result;&#125; finally &#123; jedis.close();&#125; 我们需要把Object对象，这里是Seckill对象转换成字节码数组，然后put到Redis中，这个过程也就是序列化的过程 首先设置一个key，然后使用protostuff的IOUtil工具来得到相应对象的字节码数组，传递的对象有Seckill对象本身，之前自定义的模式schema，需要一个缓存器，缓存器的大小直接设置默认的大小即可，当对象数据特别大的时候，会有缓冲的过程 接着使用Jedis的setex方法，也就是超时缓存，返回的是String类型，如果错误，则返回的是错误信息，如果正确，则会返回OK 然后回到SeckillServiceImpl类，既然有了RedisDao，通过注解注入到Spring容器中12@Autowiredprivate RedisDao redisDao; 然后把exportSeckillUrl方法中1Seckill seckill = seckillDao.queryById(seckillId); 替换为一下内容12345678910111213//优化点：缓存优化//1、访问redisSeckill seckill = redisDao.getSeckill(seckillId);if(seckill == null)&#123; //2、访问数据库 seckill = seckillDao.queryById(seckillId); if(seckill == null)&#123; return new Exposer(false, seckillId); &#125;else&#123; //3、放入Redis中 redisDao.putSeckill(seckill); &#125;&#125; 首先通过RedisDao从Redis中获取数据，然后对获取到的数据进行判断，如果为空，说明缓存中没有相应的数据，这时就需要从数据库中获取数据，获取到的数据还要再放入Redis缓存中 秒杀操作并发优化 当一个事务在执行对数据库的更改操作的时候，会获得该行的行级锁，然后通过update返回的结果来决定是否进行insert操作，最后是commit或者rollback，这时行级锁也被释放，期间肯定会有网络延迟和GC的影响 简单优化 主要的目的是减少行级锁的持有时间，通过对事务执行的流程进行下调换就可以使行级锁的持有时间大幅度减少 把insert操作放在前面，我们在创建success_killed表的时候就设置了seckilId和userPhone为联合主键，这个主键冲突的概率并不是很高 然后才是update减库存操作，这时候会获取到该行的行级锁，通过insert的返回结果来决定是否进行update操作，最后是commit或者rollback 1234567891011121314151617181920212223242526272829303132333435@Transactionalpublic SeckillExecution executeSeckill(long seckillId, long userPhone, String md5) &#123; if(md5 == null || !md5.equals(getMD5(seckillId)))&#123; throw new SeckillException(&quot;seckill data rewrite&quot;); &#125; //执行秒杀逻辑：减库存 + 记录购买行为 Date nowTime = new Date(); try &#123; //记录购买行为 int insertCount = successKilledDao.insertSuccessKilled(seckillId, userPhone); if(insertCount &lt;= 0)&#123; //重复秒杀 throw new RepeatKillException(&quot;seckill repeated&quot;); &#125; else &#123; //减库存 int updateCount = seckillDao.reduceNumber(seckillId, nowTime); if(updateCount &lt;= 0)&#123; //没有更新记录，即秒杀活动结束 throw new SeckillCloseException(&quot;seckill is closed&quot;); &#125; else &#123; //秒杀成功 SuccessKilled successKilled = successKilledDao.queryByIdWithSeckill(seckillId, userPhone); return new SeckillExecution(seckillId, SeckillStateEnum.SUCCESS, successKilled); &#125; &#125; &#125; catch(SeckillCloseException e1) &#123; throw e1; &#125; catch(RepeatKillException e2)&#123; throw e2; &#125; catch (Exception e) &#123; logger.error(e.getMessage(), e); //所有编译期异常转化为运行期异常 throw new SeckillException(&quot;seckill inner error: &quot; + e.getMessage()); &#125;&#125; 主要改变的是中间try/catch部分 深度优化同样的目的是降低行级锁到commit或者rollback之间的时间，同时还要让MySQL获得更高的QPS，所以将事务SQL放在MySQL端来执行，之前是在MyBatis的配置文件中编写SQL语句的，这里使用存储过程，将编写的SQL语句直接在MySQL端执行 在sql目录下新建一个seckill.sql文件1234567891011121314151617181920212223242526272829303132333435363738394041-- 秒杀执行存储过程DELIMITER $$ --console ; 转换为 $$-- 定义存储过程CREATE PROCEDURE `seckill`.`execute_seckill` (in v_seckill_id bigint, in v_phone bigint, in v_kill_time timestamp, out r_result int) BEGIN DECLARE insert_count int DEFAULT 0; START TRANSACTION; insert ignore into success_killed (seckill_id,user_phone,create_time) value (v_seckill_id,v_phone,v_kill_time); select row_count() into insert_count; IF (insert_count = 0) THEN ROLLBACK; set r_result = -1;-- 重复秒杀 ELSEIF (insert_count &lt; 0) THEN ROLLBACK; set r_result = -2;-- 系统错误 ELSE update seckill set number = number - 1 where seckill_id = v_seckill_id and end_time &gt; v_kill_time and start_time &lt; v_kill_time and number &gt; 0; select row_count() into insert_count; IF (insert_count = 0) THEN ROLLBACK; set r_result = 0;-- 秒杀结束 ELSEIF (insert_count &lt; 0) THEN ROLLBACK; set r_result = -2; ELSE COMMIT; set r_result = 1; END IF; END IF; END $$-- 存储过程定义结束 首先要知道的是MySQL中的console是用分号来隔离的，但是在存储过程中也是通过分号来决定是否换行，所以使用MySQL的DELIMITER暂时地把MySQL的隔离符号改为$$1DELIMITER $$ --console ; 转换为 $$ 接着创建存储过程123CREATE PROCEDURE `seckill`.`execute_seckill` (in v_seckill_id bigint, in v_phone bigint, in v_kill_time timestamp, out r_result int) 同时定义一些变量： in：输入参数，在存储过程中可以被使用 out：输出参数，在存储过程中不能被使用，但是可以被赋值 然后开始编写存储过程的逻辑12DECLARE insert_count int DEFAULT 0;START TRANSACTION; 先是定义一个变量insert_count，默认设置为0，然后开启事务 先执行insert语句，插入用户的购买明细1234insert ignore into success_killed (seckill_id,user_phone,create_time) value (v_seckill_id,v_phone,v_kill_time);select row_count() into insert_count; 不要忘记ignore关键字，然后使用 MySQL的内置函数row_count()，用于显示上一条修改类型SQL语句执行后被影响的行数 ，把row_count()的值赋值给insert_count变量，接着对insert_count进行判断1234567IF (insert_count = 0) THEN ROLLBACK; set r_result = -1;-- 重复秒杀ELSEIF (insert_count &lt; 0) THEN ROLLBACK; set r_result = -2;-- 系统错误ELSE insert_count = 0：未修改语句，设置输出参数r_result的值为-1，对应之前在Java中创建的数据字典就是重复秒杀 insert_count &lt; 0：SQL错误/未执行修改SQL，设置输出参数r_result的值为-2，对应之前在Java中创建的数据字典就是系统错误 如果insert_count的值大于0，则执行update操作1234567update seckillset number = number - 1where seckill_id = v_seckill_id and end_time &gt; v_kill_time and start_time &lt; v_kill_time and number &gt; 0;select row_count() into insert_count; 同样最后使用row_count()函数来判断是否commit或者rollback12345678910IF (insert_count = 0) THEN ROLLBACK; set r_result = 0;-- 秒杀结束ELSEIF (insert_count &lt; 0) THEN ROLLBACK; set r_result = -2;ELSE COMMIT; set r_result = 1;END IF; insert_count = 0：未更改数据，设置输出参数r_result的值为0，对应之前在Java中创建的数据字典就是秒杀结束 insert_count &lt; 0：SQL错误/未执行修改SQL，设置输出参数r_result的值为-2，对应之前在Java中创建的数据字典就是系统错误 insert_count &gt; 0：成功更改数据，设置输出参数r_result的值为1，对应之前在Java中创建的数据字典就是秒杀成功 最后结尾的时候使用$$结束存储过程，然后把换行符再改为分号1DELIMITER ; 整个过程就是把insert插入购买明细及update减库存操作放入存储过程中，在MySQL端直接执行这些语句，然后就可以直接调用这个存储过程12345set @r_result = -3;-- 执行存储过程call execute_seckill(1003,13522233356,now(),@r_result);-- 获取结果select @r_result; 首先是定义一个变量，在console中定义变量使用@，通过call执行存储过程 然后在Service层的SeckillService类中添加通过使用存储过程执行秒杀操作的方法，通过Java客户端来调用存储过程，这时只要获取到返回值，通过数据字典就可以判断执行结果12345678/** * 执行秒杀操作by存储过程 * @param seckillId * @param userPhone * @param md5 * @return */SeckillExecution executeSeckillProcedure(long seckillId, long userPhone, String md5); 接着在SeckillServiceimpl中复写这个方法123456789101112131415161718192021222324public SeckillExecution executeSeckillProcedure(long seckillId, long userPhone, String md5) &#123; if(md5 == null || !md5.equals(getMD5(seckillId)))&#123; return new SeckillExecution(seckillId, SeckillStateEnum.DATA_REWRITE); &#125; Date killTime = new Date(); Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); map.put(&quot;seckillId&quot;, seckillId); map.put(&quot;phone&quot;, userPhone); map.put(&quot;killTime&quot;, killTime); map.put(&quot;result&quot;, null); try &#123; seckillDao.killByProcedure(map); int result = MapUtils.getInteger(map, &quot;result&quot;, -2); if(result == 1)&#123; SuccessKilled sk = successKilledDao.queryByIdWithSeckill(seckillId, userPhone); return new SeckillExecution(seckillId, SeckillStateEnum.SUCCESS, sk); &#125;else&#123; return new SeckillExecution(seckillId, SeckillStateEnum.stateOf(result)); &#125; &#125; catch (Exception e) &#123; logger.error(e.getMessage(), e); return new SeckillExecution(seckillId, SeckillStateEnum.INNER_ERROR); &#125;&#125; 首先要验证的是MD5，如果MD5值错误，就返回SeckillExecution对象，数据字典中传递数据被篡改123if(md5 == null || !md5.equals(getMD5(seckillId)))&#123; return new SeckillExecution(seckillId, SeckillStateEnum.DATA_REWRITE);&#125; 重新获取系统时间1Date killTime = new Date(); 接着要使用SeckillDao获取到数据库的执行结果，所以在SeckillDao类中创建一个方法12345/** * 使用存储过程执行秒杀 * @param paramMap */void killByProcedure(Map&lt;String, Object&gt; paramMap); 传入的参数是Map，这个方法要在SeckillDao.xml中使用，也就是MyBatis的配置文件，还是要通过MyBatis调用存储过程12345678&lt;select id=&quot;killByProcedure&quot; statementType=&quot;CALLABLE&quot;&gt; call execute_seckill( #&#123;seckillId, jdbcType=BIGINT, mode=IN&#125;, #&#123;phone, jdbcType=BIGINT, mode=IN&#125;, #&#123;killTime, jdbcType=TIMESTAMP, mode=IN&#125;, #&#123;result, jdbcType=INTEGER, mode=OUT&#125; )&lt;/select&gt; CALLABLE是jdbc专门为调用存储过程而开发的，使用call，后面跟存储过程的名称 每个传递的参数都包括要传递的值，jdbc的类型，参数的模式 回到SeckillServiceImpl的executeSeckillProcedure中，要使用killByProcedure，需要传入Map类型的参数，所以要先声明Map对象，12345Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();map.put(&quot;seckillId&quot;, seckillId);map.put(&quot;phone&quot;, userPhone);map.put(&quot;killTime&quot;, killTime);map.put(&quot;result&quot;, null); Result现在为空，所以赋值null 然后就可以使用SeckillDao来获取数据库执行的结果，因为使用SeckillDao的方法的时候可能会出现异常，所以try/catch12345678910111213try &#123; seckillDao.killByProcedure(map); int result = MapUtils.getInteger(map, &quot;result&quot;, -2); if(result == 1)&#123; SuccessKilled sk = successKilledDao.queryByIdWithSeckill(seckillId, userPhone); return new SeckillExecution(seckillId, SeckillStateEnum.SUCCESS, sk); &#125;else&#123; return new SeckillExecution(seckillId, SeckillStateEnum.stateOf(result)); &#125;&#125; catch (Exception e) &#123; logger.error(e.getMessage(), e); return new SeckillExecution(seckillId, SeckillStateEnum.INNER_ERROR);&#125; 然后是获取result，使用MapUtil，要使用MapUtil，需要在pom.xml中引入依赖12345&lt;dependency&gt; &lt;groupId&gt;commons-collections&lt;/groupId&gt; &lt;artifactId&gt;commons-collections&lt;/artifactId&gt; &lt;version&gt;3.2&lt;/version&gt;&lt;/dependency&gt; 使用MapUtil传递的参数需要传递map，获取指定属性的值，如果没有获取到该属性，则赋值-2，表示系统内部错误1int result = MapUtils.getInteger(map, &quot;result&quot;, -2); 接着就可以通过result进行判断123456if(result == 1)&#123; SuccessKilled sk = successKilledDao.queryByIdWithSeckill(seckillId, userPhone); return new SeckillExecution(seckillId, SeckillStateEnum.SUCCESS, sk);&#125;else&#123; return new SeckillExecution(seckillId, SeckillStateEnum.stateOf(result));&#125; 如果等于1，获取用户购买明细，返回SeckillExecution对象，否则也返回SeckillExecution对象，但是可能是各种各样的异常，所以使用SeckillStateEnum的stateOf方法12345678public static SeckillStateEnum stateOf(int index)&#123; for(SeckillStateEnum state : values())&#123; if(state.getState() == index)&#123; return state; &#125; &#125; return null;&#125; 通过传递的数字对应相应的字符串，如果不在数据字典中的异常，就要在catch中再返回一次，传递的参数是系统错误12logger.error(e.getMessage(), e);return new SeckillExecution(seckillId, SeckillStateEnum.INNER_ERROR); 至此，高并发优化完成了]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java笔记之高并发秒杀API(五)]]></title>
      <url>%2F2017%2F01%2F25%2FJava%E7%AC%94%E8%AE%B0%E4%B9%8B%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A7%92%E6%9D%80API-%E4%BA%94%2F</url>
      <content type="text"><![CDATA[本篇将完成前端页面的设计与开发，包括： 使用Bootstrap开发页面结构 交互逻辑编程 使用Bootstrap开发页面结构在设计SeckillController中我们已经设置了jsp文件的路径，在/WEB-INF/新建一个jsp目录，在该目录下新建list.jsp和detail.jsp 使用Bootstrap的模板，这个模板基本上是固定的12345678910111213141516171819202122232425&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Bootstrap 模板&lt;/title&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;!-- 引入 Bootstrap --&gt; &lt;link href=&quot;http://cdn.static.runoob.com/libs/bootstrap/3.3.7/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt; &lt;!-- HTML5 Shim 和 Respond.js 用于让 IE8 支持 HTML5元素和媒体查询 --&gt; &lt;!-- 注意： 如果通过 file:// 引入 Respond.js 文件，则该文件无法起效果 --&gt; &lt;!--[if lt IE 9]&gt; &lt;script src=&quot;https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js&quot;&gt;&lt;/script&gt; &lt;![endif]--&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;!-- jQuery (Bootstrap 的 JavaScript 插件需要引入 jQuery) --&gt; &lt;script src=&quot;https://code.jquery.com/jquery.js&quot;&gt;&lt;/script&gt; &lt;!-- 包括所有已编译的插件 --&gt; &lt;script src=&quot;js/bootstrap.min.js&quot;&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; list.jsp123456789101112131415161718&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; %&gt;&lt;!-- 引入jstl --&gt;&lt;%@ include file=&quot;common/tag.jsp&quot; %&gt;&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;秒杀列表页&lt;/title&gt; &lt;%@ include file=&quot;common/head.jsp&quot; %&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;!-- jQuery文件。务必在bootstrap.min.js 之前引入 --&gt;&lt;script src=&quot;http://cdn.static.runoob.com/libs/jquery/2.1.1/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;!-- 最新的 Bootstrap 核心 JavaScript 文件 --&gt;&lt;script src=&quot;http://cdn.static.runoob.com/libs/bootstrap/3.3.7/js/bootstrap.min.js&quot;&gt;&lt;/script&gt;&lt;/html&gt; 在最上面的jsp内置对象page中的contentType修改为UTF-8，这个模板已经引入了一些文件包含了 jquery.js、bootstrap.min.js 和 bootstrap.min.css 文件，用于让一个常规的 HTML 文件变为使用了Bootstrap的模板 最下面有两个script标签，通过CDN加载一些Bootstrap资源， JavaScript有一个先后引入规则，jQuery作为Bootstrap的底层依赖，要先于Bootstrap声明 ，这两个script标签在上面介绍的网站上都有 这里有些通用的标签以及要引入的文件都单独提取出来，不用把这些相同的代码都写在每一个页面中 在jsp目录下新建一个common目录，专门存放通用的jsp文件 新建一个tag.jsp，用于引入jstl，如果以后还要引入别的标签，再添加12&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot;%&gt;&lt;%@ taglib prefix=&quot;fmt&quot; uri=&quot;http://java.sun.com/jsp/jstl/fmt&quot;%&gt; 新建一个head.jsp，head标签中的内容所有页面基本都一样12345678910&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;&lt;!-- 引入 Bootstrap --&gt;&lt;link href=&quot;http://cdn.static.runoob.com/libs/bootstrap/3.3.7/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt; &lt;!-- HTML5 Shim 和 Respond.js 用于让 IE8 支持 HTML5元素和媒体查询 --&gt;&lt;!-- 注意： 如果通过 file:// 引入 Respond.js 文件，则该文件无法起效果 --&gt;&lt;!--[if lt IE 9]&gt; &lt;script src=&quot;https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js&quot;&gt;&lt;/script&gt;&lt;![endif]--&gt; 然后使用jsp的内置对象include，静态引入head.jsp， 静态包含 是会把引入的文件合并过来 ，也就是head.jsp中的内容会放到外层list.jsp中作为一个Servlet输出，如果是 动态包含 的话，那么head.jsp会作为一个 独立的jsp，先转换为Servlet ，转换后的结果再和list.jsp合并 接着开始编写lsit.jsp的细节部分panel-default、text-center都是使用Bootstrap提供的样式 在panel-body中使用表格，通过jstl提供的方法来显示要展示的秒杀商品12345678910&lt;thead&gt; &lt;tr&gt; &lt;th&gt;名称&lt;/th&gt; &lt;th&gt;库存&lt;/th&gt; &lt;th&gt;开始时间&lt;/th&gt; &lt;th&gt;结束时间&lt;/th&gt; &lt;th&gt;创建时间&lt;/th&gt; &lt;th&gt;详情页&lt;/th&gt; &lt;/tr&gt;&lt;/thead&gt; 1234567891011121314151617181920&lt;tbody&gt; &lt;c:forEach var=&quot;sk&quot; items=&quot;$&#123;list&#125;&quot;&gt; &lt;tr&gt; &lt;td&gt;$&#123;sk.name&#125;&lt;/td&gt; &lt;td&gt;$&#123;sk.number&#125;&lt;/td&gt; &lt;td&gt; &lt;fmt:formatDate value=&quot;$&#123;sk.startTime&#125;&quot; pattern=&quot;yyyy-MM-dd HH:mm:ss&quot;/&gt; &lt;/td&gt; &lt;td&gt; &lt;fmt:formatDate value=&quot;$&#123;sk.endTime&#125;&quot; pattern=&quot;yyyy-MM-dd HH:mm:ss&quot;/&gt; &lt;/td&gt; &lt;td&gt; &lt;fmt:formatDate value=&quot;$&#123;sk.createTime&#125;&quot; pattern=&quot;yyyy-MM-dd HH:mm:ss&quot;/&gt; &lt;/td&gt; &lt;td&gt; &lt;a class=&quot;btn btn-info&quot; href=&quot;/seckill/$&#123;sk.seckillId&#125;/detail&quot; target=&quot;_blank&quot;&gt;link&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt;&lt;/tbody&gt; 首先使用jstl的c:forEach标签，用来迭代从SeckillController中的list方法传过来的”list”，这个list是存放秒杀的商品，属性var代表当前项目的变量名，items表示进行循环的项目 一个tr标签是一行，每个td标签是一列，数据库有多少个秒杀商品这个表格就有多少行123456789@RequestMapping(value = &quot;/list&quot;, method = RequestMethod.GET)public String list(Model model)&#123; //获取列表页 List&lt;Seckill&gt; list = seckillService.getSeckillList(); model.addAttribute(&quot;list&quot;, list); return &quot;list&quot;; &#125; 从SeckillController的list方法返回的是字符串，但是之前说过，Spring MVC会拼接成一个URL地址，返回的数据是个泛型，类型是Seckill1234567891011121314public class Seckill &#123; private long seckillId; private String name; private int number; private Date startTime; private Date endTime; private Date createTime;&#125; 这是Seckill定义的属性，所以在list.jsp页面中通过sk.name来调用相关的参数 日期类型的输出默认是直接调用日期类型的toString，这不符合我们的规范，所以使用jstl的fmt:formatDate标签来格式化输出的时间 最后一列给一个超链接，用于链接这个秒杀商品的详情页，可以把这个超链接做成一个按钮，使用的也是Bootstrap的CSS detail.jsp 这是detail.jsp的一个大的框架，先是由两个div组成，一个用于显示日期或者文本的一个显示面板，在显示面板中做一个埋点，因为这个面板在之后的交互逻辑编码中，在不同时间显示的是不同的内容1&lt;h1&gt;$&#123;seckill.name &#125;&lt;/h1&gt; 这里可以直接这样写的原因是：1model.addAttribute(&quot;seckill&quot;, seckill);//SeckillController中的detail方法 另一个div就是登录弹出层，在进入详情页的时候，会通过Cookie判断用户时候登录，没有登录的用户的页面会显示这个登录弹出层，提示用户登录 首先在最外围的div中进行埋点1&lt;div id=&quot;killPhoneModal&quot; class=&quot;modal fade&quot;&gt; 因为这个登录弹出层不是每次用户到详情页都要出现，只有验证Cookie中没有用户登录信息才会出现，所以在这里埋点，如果Cookie中有用户的信息，在交互逻辑中我们会控制这个div不出现 登录弹出层实际是一个模态框，在页面显示的时候主要由三个部分： modal-header：显示一些文本 modal-body：用户输入登录信息 modal-footer：登录按钮 12345&lt;div class=&quot;modal-header&quot;&gt; &lt;h3 class=&quot;modal-title text-center&quot;&gt; &lt;span class=&quot;glyphicon glyphicon-phone&quot;&gt;&lt;/span&gt;秒杀电话： &lt;/h3&gt; &lt;/div&gt; 在modal-header中有个span面板用于显示一些文本和图标 12345678&lt;div class=&quot;modal-body&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-xs-8 col-xs-offset-2&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;killPhone&quot; id=&quot;killPhoneKey&quot; placeholder=&quot;填写手机号^o^&quot; class=&quot;form-control&quot;&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 在modal-body中有一个输入框，这里需要在输入框中进行埋点，之后的交互逻辑要通过这个埋点来获取用户输入的信息 1234567&lt;div class=&quot;modal-footer&quot;&gt; &lt;!-- 验证信息 --&gt; &lt;span id=&quot;killPhoneMessage&quot; class=&quot;glyphicon&quot;&gt;&lt;/span&gt; &lt;button type=&quot;button&quot; id=&quot;killPhoneBtn&quot; class=&quot;btn btn-success&quot;&gt; &lt;span class=&quot;glyphicon glyphicon-phone&quot;&gt;&lt;/span&gt; &lt;/button&gt;&lt;/div&gt; 在modal-footer中由两部分组成： span：显示错误信息 button：登录按钮 在button中也需要埋点，用于绑定点击事件 body标签中的内容完成了，下面也要通过CDN引入一些文件1234567891011&lt;!-- jQuery文件。务必在bootstrap.min.js 之前引入 --&gt;&lt;script src=&quot;http://cdn.static.runoob.com/libs/jquery/2.1.1/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;!-- 最新的 Bootstrap 核心 JavaScript 文件 --&gt;&lt;script src=&quot;http://cdn.static.runoob.com/libs/bootstrap/3.3.7/js/bootstrap.min.js&quot;&gt;&lt;/script&gt;&lt;!-- 使用CDN获取公共js --&gt;&lt;!-- jQuery cookie操作插件 --&gt;&lt;script src=&quot;http://cdn.bootcss.com/jquery-cookie/1.4.1/jquery.cookie.js&quot;&gt;&lt;/script&gt;&lt;!-- jQuery countDown倒计时插件 --&gt;&lt;script src=&quot;http://cdn.bootcss.com/jquery.countdown/2.2.0/jquery.countdown.min.js&quot;&gt;&lt;/script&gt; jquery文件和bootstrap.min.js之前在list.jsp也引入了 对Cookie的操作使用jQuery Cookie插件，倒计时使用jQuery的countDown插件 交互逻辑交互流程 当用户点击某一个秒杀商品的按钮的时候，会进入到相应的详情页，这个详情页会判断用户是否登录过，如果登录过就展示详情页页面，如果没有登录过，就弹出登录弹出层，在用户正确填写登录信息后就可以进入详情页 获取标准系统时间，因为用户可能处在不同的时区，用户终端的时间也不可能完全一致，所以要统一地采用一个标准时间，也就是服务器时间 通过秒杀商品的开始时间和结束时间来做出不同的判断： 系统时间大于结束时间：秒杀活动已结束，在detail.jsp的显示面板显示“秒杀结束”字样 系统时间小于开始时间：秒杀活动未开始，在detail.jsp的显示面板显示倒计时，使用的是jQuery的countDown插件，倒计时完成后，会出现秒杀按钮，用户可以执行秒杀操作 系统时间介于开始时间和结束时间之间：秒杀活动正在进行，直接出现秒杀按钮，用户可以执行秒杀操作 页面展示 交互逻辑编程在src/main/webapp目录下新建一个resources文件夹，再在其中新建一个script文件夹，用于存放脚本文件 创建一个seckill.js 这是最后完成的总览，接着一步步来，整个seckil这样写的原因是模拟高级语言分包的概念，使JavaScript模块化，这样当调用一个方法可以用seckill.detail.init(params)的形式 在详情页初始化中，首先要做的就是获取killPhone节点，这个killPhone节点不是程序中具体的标签，而是Cookie中的用于标识用户信息的数据，用户的信息都放在Cookie中名为killPhone的节点1234567891011121314151617181920//在cookie中查找手机号var killPhone = $.cookie(&apos;killPhone&apos;);//验证手机号if(!seckill.validatePhone(killPhone))&#123; var killPhoneModal = $(&apos;#killPhoneModal&apos;); killPhoneModal.modal(&#123; show : true,//显示登录弹出层 backdrop : &apos;static&apos;,//禁止位置关闭 keyboard : false//关闭键盘事件 &#125;); $(&apos;#killPhoneBtn&apos;).click(function()&#123; var inputPhone = $(&apos;#killPhoneKey&apos;).val(); if(seckill.validatePhone(inputPhone))&#123; $.cookie(&apos;killPhone&apos;, inputPhone, &#123;expires:7, path:&apos;/seckill&apos;&#125;);//手机号写入cookie window.location.reload();//刷新页面 &#125;else&#123; $(&apos;#killPhoneMessage&apos;).hide().html(&apos;&lt;label class=&quot;label label-danger&quot;&gt;手机号错误!&lt;/label&gt;&apos;).show(300); &#125; &#125;);&#125; 从Cookie的killPhone中获取数据后，就要验证手机号，验证手机号的逻辑建议提取到更上层，因为可能多个地方都要用到 创建一个函数，名字为validatePhone，这个函数的位置在这一节最开始的图片上可以看到12345678//验证手机号validatePhone : function(phone)&#123; if(phone &amp;&amp; phone.length == 11 &amp;&amp; !isNaN(phone))&#123; return true; &#125;else&#123; return false; &#125;&#125;, 要验证手机号，所以传入一个手机号的参数，这里使用if语句简单的判断一下 首先要判断手机号是否为空，在js中直接传入参数，它会判断这个参数是否为空，空的话就是undefine，就认为是false 手机号长度必须为11位 isNaN是判断这个参数是否是非数字，如果是非数字的话就是true，所以这里要取反 接着就可以在init方法中调用validatePhone函数来验证手机号1234567if(!seckill.validatePhone(killPhone))&#123; var killPhoneModal = $(&apos;#killPhoneModal&apos;); killPhoneModal.modal(&#123; show : true,//显示登录弹出层 backdrop : &apos;static&apos;,//禁止位置关闭 keyboard : false//关闭键盘事件 &#125;); 如果手机号存在，就可以直接跳转到详情页了，所以这里处理手机号不存在的情况，因为这个if语句中东西比较多，所以分开来说，完整的代码在前面已经展示过了 手机号不存在，就需要用户进行绑定，之前在detail.jsp中也提前做好了一个登录弹出层，并进行了埋点 id为killPhoneModal，在seckill.js中使用jQuery的选择器可以取到这个节点1var killPhoneModal = $(&apos;#killPhoneModal&apos;); 这个登录弹出层已经不是单纯的div了，因为使用了Bootstrap的modal，它本身有一个modal的方法，向这个方法传入json， 用于设置这个模态框的一些属性 之前在detail.jsp中这个modal的属性为fade，是隐藏的，既然要让用户绑定手机号，所以要把这个弹出层显示出来1234killPhoneModal.modal(&#123; show : true,//显示登录弹出层 backdrop : &apos;static&apos;,//禁止位置关闭 keyboard : false//关闭键盘事件 我们希望在用户没有正确的填写手机号之前，是不能关掉这个弹出层，所以把backdrop关掉，因为用户点击其他区域可能把这个弹出层关掉；通过键盘的ESC也可能关闭弹出层，所以要禁止键盘事件 弹出层显示出来后，要给按钮做事件绑定123456789$(&apos;#killPhoneBtn&apos;).click(function()&#123; var inputPhone = $(&apos;#killPhoneKey&apos;).val(); if(seckill.validatePhone(inputPhone))&#123; $.cookie(&apos;killPhone&apos;, inputPhone, &#123;expires:7, path:&apos;/seckill&apos;&#125;);//手机号写入cookie window.location.reload();//刷新页面 &#125;else&#123; $(&apos;#killPhoneMessage&apos;).hide().html(&apos;&lt;label class=&quot;label label-danger&quot;&gt;手机号错误!&lt;/label&gt;&apos;).show(300); &#125;&#125;); 按钮事件绑定完成后整个验证手机号的if语句才完成了 对按钮做绑定，首先就是要获取到按钮在详情页的节点1234567&lt;div class=&quot;modal-footer&quot;&gt; &lt;!-- 验证信息 --&gt; &lt;span id=&quot;killPhoneMessage&quot; class=&quot;glyphicon&quot;&gt;&lt;/span&gt; &lt;button type=&quot;button&quot; id=&quot;killPhoneBtn&quot; class=&quot;btn btn-success&quot;&gt; &lt;span class=&quot;glyphicon glyphicon-phone&quot;&gt;&lt;/span&gt; &lt;/button&gt;&lt;/div&gt; 可以看到，按钮的节点为killPhoneBtn 当用户点击了按钮，我们认为用户已经填写了在登录弹出层的input12345678&lt;div class=&quot;modal-body&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-xs-8 col-xs-offset-2&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;killPhone&quot; id=&quot;killPhoneKey&quot; placeholder=&quot;填写手机号^o^&quot; class=&quot;form-control&quot;&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 在input中，之前已经提前进行了埋点，id为killPhoneKey 在seckill.js中获取到这个节点，同时使用val()方法获取到用户输入的内容1var inputPhone = $(&apos;#killPhoneKey&apos;).val(); 拿到用户输入的内容，还要再进行验证，再调用用于验证手机号的函数validatePhone123456if(seckill.validatePhone(inputPhone))&#123; $.cookie(&apos;killPhone&apos;, inputPhone, &#123;expires:7, path:&apos;/seckill&apos;&#125;);//手机号写入cookie window.location.reload();//刷新页面&#125;else&#123; $(&apos;#killPhoneMessage&apos;).hide().html(&apos;&lt;label class=&quot;label label-danger&quot;&gt;手机号错误!&lt;/label&gt;&apos;).show(300);&#125; 如果验证通过了，先将inputPhone的值也就是用户输入的手机号写入Cookie中 expires：Cookie的有效期，单位是“天” path：给出有效路径，Cookie只在该路径下有效 为什么path不写全路径？因为当一些URL没有用到这个Cookie的时候，如果把Cookie中的path设置为全路径，那么这个Cookie中的数据也会传递到后端，对后端处理会有一些影响，所以这只这个killPhone只在seckill模块下有效 然后就是刷新页面，会重新调用detail属性的init方法 如果验证没有通过，在detail.jsp中登录弹出层的modal-footer提前预留了一个span，用于显示错误信息1&lt;span id=&quot;killPhoneMessage&quot; class=&quot;glyphicon&quot;&gt;&lt;/span&gt; 同样，在seckill.js中获取到这个span节点1$(&apos;#killPhoneMessage&apos;).hide().html(&apos;&lt;label class=&quot;label label-danger&quot;&gt;手机号错误!&lt;/label&gt;&apos;).show(300); 对html标签进行操作的时候，通常是先隐藏一下，避免用户看到中间过程，然后插入一些内容，显示的时候给一个时间，单位毫秒，这样看起来有动态的效果 插入的是label标签，使用Bootstrap的CSS，这里显示的文本没有经过处理，直接是写死了，实际的工作中这里应该是要配合前端的数据字典，根据不同的情况显示不同的文本 至此，详情页初始化部分完成，也就是开头的if语句 整个前端的流程基本完成 接着是详情页的流程 首先就是要获取标准系统时间 所以在detail.jsp的最下面添加一些内容，首先是要引入seckill.js12&lt;!-- 开始编写交互逻辑 --&gt;&lt;script src=&quot;/resources/script/seckill.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; 然后使用EL表达式传入参数1234567891011&lt;script type=&quot;text/javascript&quot;&gt; $(function()&#123; //使用EL表达式传入参数 seckill.detail.init(&#123; seckillId : &quot;$&#123;seckill.seckillId&#125;&quot;, startTime : &quot;$&#123;seckill.startTime.time&#125;&quot;, endTime : &quot;$&#123;seckill.endTime.time&#125;&quot; &#125;); &#125;);&lt;/script&gt; 接着在seckill.js中获取到这些参数1234567891011121314//已经登录//计时交互逻辑var startTime = parseInt(params[&apos;startTime&apos;]);var endTime = parseInt(params[&apos;endTime&apos;]);var seckillId = parseInt(params[&apos;seckillId&apos;]);$.get(seckill.URL.now(), &#123;&#125;, function(result)&#123; if(result &amp;&amp; result[&apos;success&apos;])&#123; var nowTime = result[&apos;data&apos;]; //时间判断，计时交互 seckill.countdown(seckillId, nowTime, startTime, endTime); &#125;else&#123; console.log(&apos;result: &apos; + result); &#125;&#125;); 这里从列表页传递过来的日期参数需要转型，否则之后会出现日期无效的情况 然后通过ajax请求来获取到系统当前时间123456@RequestMapping(value = &quot;/time/now&quot;, method = RequestMethod.GET)@ResponseBodypublic SeckillResult&lt;Long&gt; time()&#123; Date now = new Date(); return new SeckillResult&lt;Long&gt;(true, now.getTime());&#125; 在SeckillController中的time方法就是用来获取系统时间的，在@RequestMapping注解中显示系统当前时间的URL是“/time/now”，限制了请求方式为GET，所以在seckill.js中使用$.get()方法 简单说下$.get()方法 $.get(URL,data,function(data,status,xhr),dataType) URL：必需，规定您需要请求的 URL data：可选，规定连同请求发送到服务器的数据 function(data,status,xhr)：可选，规定当请求成功时运行的函数 data：包含来自请求的结果数据 status：包含请求的状态（”success”、”notmodified”、”error”、”timeout”、”parsererror”） xhr：包含 XMLHttpRequest 对象 dataType：可选，规定预期的服务器响应的数据类型，默认地，jQuery 会智能判断。可能的类型： xml - 一个 XML 文档 html - HTML 作为纯文本 text - 纯文本字符串 script - 以 JavaScript 运行响应，并以纯文本返回 json - 以 JSON 运行响应，并以 JavaScript 对象返回 jsonp - 使用 JSONP 加载一个 JSON 块，将添加一个 “?callback=?” 到 URL 来规定回调 123456789$.get(seckill.URL.now(), &#123;&#125;, function(result)&#123; if(result &amp;&amp; result[&apos;success&apos;])&#123; var nowTime = result[&apos;data&apos;]; //时间判断，计时交互 seckill.countdown(seckillId, nowTime, startTime, endTime); &#125;else&#123; console.log(&apos;result: &apos; + result); &#125;&#125;); 第一个参数是请求的URL，由于URL太多，为了后期维护、代码的整洁，所以要对URL进行统一的管理，在seckill中新建一个属性URL，用于封装秒杀相关ajax的URL123456//封装秒杀相关ajax的URL URL : &#123; now : function()&#123; return &apos;/seckill/time/now&apos;; &#125;&#125;, 在SeckillController中的time方法返回的是SeckillResult类型的对象12345678public class SeckillResult&lt;T&gt; &#123; private boolean success; private T data; private String error;&#125; 这是SeckillResult中定义的属性，其中success是判断是否成功请求，所以在$.get()方法的回调函数中要判断请求是否为空，如果不为空，则在控制台输出信息1234567if(result &amp;&amp; result[&apos;success&apos;])&#123; var nowTime = result[&apos;data&apos;]; //时间判断，计时交互 seckill.countdown(seckillId, nowTime, startTime, endTime);&#125;else&#123; console.log(&apos;result: &apos; + result);&#125; 如果请求成功，就可以获取到系统当前时间，再加上之前获取到的三个参数，就可以进行时间判断，判断系统当前时间在不在秒杀活动期内，如果不在是秒杀未开始还是秒杀已结束 在seckill中创建countdown函数，用于时间判断12345678910111213141516171819202122countdown : function(seckillId, nowTime, startTime, endTime)&#123; var seckillBox = $(&apos;#seckill-box&apos;); //时间判断 if(nowTime &gt; endTime)&#123; //秒杀结束 seckillBox.html(&apos;秒杀结束!&apos;); &#125;else if(nowTime &lt; startTime)&#123; //秒杀未开始，计时事件绑定 var killTime = new Date(startTime + 1000);//设置基准时间 seckillBox.countdown(killTime, function(event)&#123; //时间格式 var format = event.strftime(&apos;秒杀倒计时: %D天 %H时 %M分 %S秒&apos;); //时间完成后回调事件 &#125;).on(&apos;finish.countdown&apos;, function()&#123; //调用执行秒杀的函数 seckill.handleSeckill(seckillId, seckillBox); &#125;); &#125;else&#123; //调用执行秒杀的函数 seckill.handleSeckill(seckillId, seckillBox); &#125;&#125;, 因为对于时间判断的不同结果，要在详情页中展示不同的内容，所以在detail.jsp中专门设置了一个span，用于显示时间判断的结果12345678&lt;div class=&quot;panel-body&quot;&gt; &lt;h2 class=&quot;text-danger&quot;&gt; &lt;!-- 显示time图标 --&gt; &lt;span class=&quot;glyphicon glyphicon-time&quot;&gt;&lt;/span&gt; &lt;!-- 显示面板 --&gt; &lt;span class=&quot;glyphicon&quot; id=&quot;seckill-box&quot;&gt;&lt;/span&gt; &lt;/h2&gt;&lt;/div&gt; 提前设置了埋点，id为seckill-box，在seckill.js通过jQuery的加载器获取到这个span节点 然后进行时间判断1234if(nowTime &gt; endTime)&#123; //秒杀结束 seckillBox.html(&apos;秒杀结束!&apos;);&#125; 系统当前时间大于秒杀的结束时间，说明秒杀结束，这里不用和后端做通信，可以直接通过时间的判断就再详情页显示“秒杀结束”的字样，因为时间到了，不管有没有库存，都无所谓了 123456789101112if(nowTime &lt; startTime)&#123; //秒杀未开始，计时事件绑定 var killTime = new Date(startTime + 1000);//设置基准时间 seckillBox.countdown(killTime, function(event)&#123; //时间格式 var format = event.strftime(&apos;秒杀倒计时: %D天 %H时 %M分 %S秒&apos;); //时间完成后回调事件 &#125;).on(&apos;finish.countdown&apos;, function()&#123; //调用执行秒杀的函数 seckill.handleSeckill(seckillId, seckillBox); &#125;);&#125; 系统当前时间小于秒杀开启时间，秒杀未开始，在详情页显示倒计时，既然是倒计时，就要给系统一个基准时间，其实也就是秒杀的开启时间，但是这里在秒杀开始时间的基础+1s，防止用户端的计时偏移 接着使用Bootstrap提供的countdown方法，实际上就是一个事件绑定方法123456seckillBox.countdown(killTime, function(event)&#123; //时间格式 var format = event.strftime(&apos;秒杀倒计时: %D天 %H时 %M分 %S秒&apos;); seckillBox.html(format); //倒计时完成后回调事件&#125;) countdown事件绑定方法中也有一个回调函数，当日期在不断的变化的时候，这个回调函数会做相应的输出，对日期的格式做个调整 countdown插件只是负责倒计时，倒计时完成后就可以执行秒杀操作了，所以在countdown时间绑定后再接上一个事件操作1234.on(&apos;finish.countdown&apos;, function()&#123; //调用执行秒杀的函数 seckill.handleSeckill(seckillId, seckillBox);&#125;); 事件的名字是finish.countdown，再加上一个回调函数，用于倒计时完成后回调事件，在这个函数中要调用执行秒杀的函数 这里把执行秒杀的函数单独的提取出来，一是降低耦合，二是避免代码重复，因为在最初调用时间判断函数countdown的时候，可能秒杀正在进行，而上面的代码是秒杀未开始，倒计时完成后才可以执行秒杀，在多个地方需要执行秒杀的操作，所以要把执行秒杀的操作单独创建一个函数 1234567891011121314151617181920212223242526272829303132333435363738394041424344handleSeckill : function(seckillId, node)&#123; //获取秒杀地址，控制显示逻辑，执行秒杀 node.hide() .html(&apos;&lt;button class=&quot;btn btn-primary btn-lg&quot; id=&quot;killBtn&quot;&gt;开始秒杀&lt;/button&gt;&apos;); $.post(seckill.URL.exposer(seckillId), &#123;&#125;, function(result)&#123; //在回调函数中执行交互流程 if(result &amp;&amp; result[&apos;success&apos;])&#123; var exposer = result[&apos;data&apos;]; if(exposer[&apos;exposed&apos;])&#123; //开启秒杀，获取秒杀地址 var md5 = exposer[&apos;md5&apos;]; var killUrl = seckill.URL.execution(seckillId, md5); console.log(&apos;killUrl: &apos; + killUrl); //绑定一次点击事件 $(&apos;#killBtn&apos;).one(&apos;click&apos;, function()&#123; //执行秒杀请求 //1.禁用按钮 $(this).addClass(&apos;disabled&apos;); //2.发送秒杀请求执行秒杀 $.post(killUrl, &#123;&#125;, function(result)&#123; if(result &amp;&amp; result[&apos;success&apos;])&#123; var killResult = result[&apos;data&apos;]; var state = killResult[&apos;state&apos;]; var stateInfo = killResult[&apos;stateInfo&apos;]; //3.显示秒杀结果 node.html(&apos;&lt;span class=&quot;label label-success&quot;&gt;&apos; + stateInfo + &apos;&lt;/span&gt;&apos;); &#125; &#125;); &#125;); node.show(); &#125;else&#123; //未开启秒杀 var now = exposer[&apos;now&apos;]; var start = exposer[&apos;start&apos;]; var end = exposer[&apos;end&apos;]; seckill.countdown(seckillId, now, start, end); &#125; &#125;else&#123; console.log(&apos;result: &apos; + result); &#125; &#125;);&#125;. 这个方法的参数有个node，用来获取节点的，因为之前在detail.jsp中有专门显示时间判断的结果的span，当可以进行秒杀的时候，这个span显示的就是一个按钮，所以这里也要获取这个span节点，来对这个span进行操作，加入一个button标签12node.hide() .html(&apos;&lt;button class=&quot;btn btn-primary btn-lg&quot; id=&quot;killBtn&quot;&gt;开始秒杀&lt;/button&gt;&apos;); 插入按钮后先不要显示出来，因为后面还要对用户信息也就是手机号进行验证 执行秒杀操作之前，就要先取得秒杀的地址1234567891011121314151617@RequestMapping( value = &quot;/&#123;seckillId&#125;/exposer&quot;, method = RequestMethod.POST, produces = &#123;&quot;application/json;charset=UTF-8&quot;&#125;)@ResponseBodypublic SeckillResult&lt;Exposer&gt; exposer(@PathVariable(&quot;seckillId&quot;) Long seckillId)&#123; SeckillResult&lt;Exposer&gt; result; try &#123; Exposer exposer = seckillService.exportSeckillUrl(seckillId); result = new SeckillResult&lt;Exposer&gt;(true, exposer); &#125; catch (Exception e) &#123; logger.error(e.getMessage(), e); result = new SeckillResult&lt;Exposer&gt;(false, e.getMessage()); &#125; return result;&#125; 在SeckillController的exposer方法就是用来暴露秒杀地址的，这个方法只接收POST请求，返回的是SeckillResult对象，类型是Exposer、 在seckill.js中使用$.post()方法，类似前面讲过的$.get()方法12345678$.post(seckill.URL.exposer(seckillId), &#123;&#125;, function(result)&#123; //在回调函数中执行交互流程 if(result &amp;&amp; result[&apos;success&apos;])&#123; var exposer = result[&apos;data&apos;]; &#125;else&#123; console.log(&apos;result: &apos; + result); &#125;&#125;); 要传入请求的URL，也要放在seckill的URL属性中123exposer : function(seckillId)&#123; return &apos;/seckill/&apos; + seckillId + &apos;/exposer&apos;;&#125; 这个URL需要传递秒杀商品的id，因为不同的秒杀商品需要相应的UEL 首先还是要判断ajax请求是否成功，如果没有请求成功，在控制台打印信息 如果请求成功，获取$.post()方法返回过来的数据，是Exposer类型的，封装在SeckillResult的data属性中1234567891011121314151617181920public class Exposer &#123; //是否开启秒杀 private boolean exposed; //加密措施 private String md5; //id private long seckillId; //系统当前时间（毫秒） private long now; //秒杀开启时间 private long start; //秒杀结束时间 private long end;&#125; 获取到Exposer对象后，在Exposer类中有一个exposed属性，用来判断是否开启秒杀，如果开启秒杀，就要控制之前定义的按钮，先绑定点击事件，然后显示出来 如果不开启秒杀，就返回系统当前时间、秒杀开启时间、秒杀结束时间，再调用countdown函数123456789if(exposer[&apos;exposed&apos;])&#123;&#125;else&#123; //未开启秒杀 var now = exposer[&apos;now&apos;]; var start = exposer[&apos;start&apos;]; var end = exposer[&apos;end&apos;]; seckill.countdown(seckillId, now, start, end);&#125; 既然都到这一步了，什么情况下还是秒杀未开始？ 当不同的终端显示过长的时间的时候，可能出现一些偏差，用户显示已经开启秒杀，但是实际上服务器的时间还没到，虽然时间差很小，但是还是要重新计算计时逻辑，所以调用countdown函数 判断开启秒杀之后，先要获取秒杀地址1234//开启秒杀，获取秒杀地址var md5 = exposer[&apos;md5&apos;];var killUrl = seckill.URL.execution(seckillId, md5);console.log(&apos;killUrl: &apos; + killUrl); 用于执行秒杀操作的URL需要经过MD5的加密，所以还要从后端获取到MD5，同样，ajax请求的URL都要封装在seckill.js的URL属性中123execution : function(seckillId, md5)&#123; return &apos;/seckill/&apos; + seckillId + &apos;/&apos; + md5 + &apos;/execution&apos;;&#125; 这些URL之前在Controller层都已经定义好的12345678@RequestMapping( value = &quot;/&#123;seckillId&#125;/&#123;md5&#125;/execution&quot;, method = RequestMethod.POST, produces = &#123;&quot;application/json;charset=UTF-8&quot;&#125;)@ResponseBodypublic SeckillResult&lt;SeckillExecution&gt; execute(@PathVariable(&quot;seckillId&quot;) Long seckillId, @PathVariable(&quot;md5&quot;) String md5, @CookieValue(value = &quot;killPhone&quot;, required = false) Long phone) 获取到了执行秒杀的URL，就可以控制按钮，绑定点击事件123456789101112131415161718//绑定一次点击事件$(&apos;#killBtn&apos;).one(&apos;click&apos;, function()&#123; //执行秒杀请求 //1.禁用按钮 $(this).addClass(&apos;disabled&apos;); //2.发送秒杀请求执行秒杀 $.post(killUrl, &#123;&#125;, function(result)&#123; if(result &amp;&amp; result[&apos;success&apos;])&#123; var killResult = result[&apos;data&apos;]; var state = killResult[&apos;state&apos;]; var stateInfo = killResult[&apos;stateInfo&apos;]; //3.显示秒杀结果 node.html(&apos;&lt;span class=&quot;label label-success&quot;&gt;&apos; + stateInfo + &apos;&lt;/span&gt;&apos;); &#125; &#125;);&#125;); 但是只绑定一次点击事件，防止用户连续点击，比如用户不放心页面是否响应，所以可能会连续的点击按钮，如果不在这控制的话，这些点击最后都会发送到服务器端，会造成服务器端在同一时间接到大量相同的URL请求，对各方面都有影响 所以点击完之后就要禁用按钮，通过this指代当前对象，也就是相当于使用$(‘#killBtn’) 之后就是发送秒杀请求，执行秒杀操作，在SeckillController的execute方法只接收POST请求，所以使用$.post()方法 然后通过SeckillResult中的success属性判断是否请求成功123456789101112131415161718if(phone == null)&#123; return new SeckillResult&lt;SeckillExecution&gt;(false, &quot;未注册&quot;);&#125;//SeckillResult&lt;SeckillExecution&gt; result;try &#123; SeckillExecution execution = seckillService.executeSeckill(seckillId, phone, md5); return new SeckillResult&lt;SeckillExecution&gt;(true, execution);&#125; catch (RepeatKillException e) &#123; SeckillExecution execution = new SeckillExecution(seckillId, SeckillStateEnum.REPEAT_KILL); return new SeckillResult&lt;SeckillExecution&gt;(true, execution);&#125; catch (SeckillCloseException e) &#123; SeckillExecution execution = new SeckillExecution(seckillId, SeckillStateEnum.END); return new SeckillResult&lt;SeckillExecution&gt;(true, execution);&#125; catch (Exception e) &#123; logger.error(e.getMessage(), e); SeckillExecution execution = new SeckillExecution(seckillId, SeckillStateEnum.INNER_ERROR); return new SeckillResult&lt;SeckillExecution&gt;(true, execution);&#125; 这是SeckillController的execute方法，返回的都是SeckillExecution对象，这些对象存放在SeckillResult的data属性中12345678910111213public class SeckillExecution &#123; private long seckillId; //秒杀结果执行后的状态 private int state; //状态信息 private String stateInfo; //秒杀成功对象 private SuccessKilled successKilled;&#125; 这是SeckillExecution类中定义的方法，在seckill.js中获取到这些属性12345678910$.post(killUrl, &#123;&#125;, function(result)&#123; if(result &amp;&amp; result[&apos;success&apos;])&#123; var killResult = result[&apos;data&apos;]; var state = killResult[&apos;state&apos;]; var stateInfo = killResult[&apos;stateInfo&apos;]; //3.显示秒杀结果 node.html(&apos;&lt;span class=&quot;label label-success&quot;&gt;&apos; + stateInfo + &apos;&lt;/span&gt;&apos;); &#125;&#125;); 获取到执行秒杀的结果后，还要在详情页中显示出来，所以控制节点，输出状态信息，因为在SeckillController的execute方法中已经定义了重复秒杀、秒杀结束等异常也算请求成功，只是不对数据库进行操作，但是结果信息要返回到详情页 最后就可以把按钮显示出来了1node.show(); 至此，前端页面完成了]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java笔记之高并发秒杀API(四)]]></title>
      <url>%2F2017%2F01%2F23%2FJava%E7%AC%94%E8%AE%B0%E4%B9%8B%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A7%92%E6%9D%80API-%E5%9B%9B%2F</url>
      <content type="text"><![CDATA[本篇将完成WEB层的设计与开发，包括： Spring MVC与Spring、MyBatis整合 设计并实现Restful接口 Spring MVC与Spring整合之前Spring与MyBatis已经进行过整合了，当通过DispatcherServlet加载Spring MVC的时候，DispatcherServlet同时会把Spring相关的配置也会整合到Spring MVC中，这样就实现了三个框架的整合，即MyBatis+Spring+Spring MVC 打开web.xml，在Eclipse中位置是src/main/webapp/WEB-INF1234567891011&lt;!-- 配置DispatcherServlet --&gt;&lt;servlet&gt; &lt;servlet-name&gt;seckill-dispatcher&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 配置Spring MVC需要加载的配置文件 --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring/spring-*.xml&lt;/param-value&gt; &lt;/init-param&gt;&lt;/servlet&gt; 首先配置的是Spring MVC中央控制器的Servlet，即DispatcherServlet，所有Spring MVC的请求都由DispatcherServlet来分发 然后配置Spring MVC需要加载的配置文件，所有在spring目录下的xml配置文件都要加载进来，之前完成的配置文件有spring-dao.xml和spring-service.xml 12345&lt;servlet-mapping&gt; &lt;servlet-name&gt;seckill-dispatcher&lt;/servlet-name&gt; &lt;!-- 默认匹配所有请求 --&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 接着是servlet-mapping，默认匹配所有请求，也就是所有请求都会被DispatcherServlet拦截 在src\main\resources\spring下新建spring-web.xml12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;&lt;beans&gt; 把以上内容复制到spring-web.xml 开始配置Spring MVC12&lt;!-- 开启Spring MVC注解模式 --&gt;&lt;mvc:annotation-driven/&gt; 开启Spring MVC注解模式，这一步是一个简化配置，提供了以下功能： 自动注册DefaultAnnotationHandlerMapping，也就是默认地URL到Handler的映射是通过注解的方式 自动注册AnnotationMethodHandlerAdapter，这个是基于注解的Handler适配器 数据绑定 数字和日期的format，也就是转换，例如@NumberFormat，@DataTimeFormat 提供xml，json默认读写支持总而言之，我们可以通过不同的注解来完成以上的功能，当然这些功能不仅可以使用注解，也可以使用额外的xml配置文件甚至是编程的方式，根据项目的不同采用不同的方式 12&lt;!-- 静态资源默认servlet配置 --&gt;&lt;mvc:default-servlet-handler/&gt; 前面配置了servlet-mapping，映射路径为“/”，使用这样配置的话，就需要这个处理方式，有两个作用： 加入对静态资源的处理，即js、png等 允许使用”/“做整体映射 接着配置jsp123456&lt;!-- 配置输出样式为JSP 显示ViewResolver --&gt;&lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;viewClass&quot; value=&quot;org.springframework.web.servlet.view.JstlView&quot;/&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;&lt;/bean&gt; 也就是需要默认的文档输出是jsp和json，不过json不需要我们提供，因为在开始配置Spring MVC注解模式的时候，已经提供了json的读写支持，只要对应到相应的注解就行 因为可能要用到el表达式或者jstl标签，所以配置一个viewClass 还要配置一个识别JSP文件前缀的属性，设置jsp文件存放在/WEB-INF/jsp目录下，再加上后缀 12&lt;!-- 扫描WEB相关的bean --&gt;&lt;context:component-scan base-package=&quot;org.seckill.web&quot;/&gt; 扫描WEB相关的bean 接着按照我粗浅的理解，简单的说一下Spring MVC的运行流程：1、用户发送的请求，所有的请求都会映射到DispatcherServlet，这是一个中央控制器的Servlet，这个Servlet会拦截所有的请求，对应在项目中应该就是web.xml中配置的servlet-mapping标签2、DispatcherServlet默认的会使用DefaultAnnotation HandlerMapping，主要的作用就是映射URL，哪个URL对应哪个handler，对应在项目中就是在spring-web.xml中mvc:annotation-driven，即开启Spring MVC的注解模式3、DispatcherServlet默认的会使用DefaultAnnotation HandlerAdapter，用于做Handler适配，对应在项目中就是在spring-web.xml中mvc:annotation-driven，即开启Spring MVC的注解模式4、DefaultAnnotation HandlerAdapter最终会衔接这次开发的SeckillController，最终的产生就是ModelAndView5、ModelAndView会与中央控制器DispatcherServlet进行交互6、通过第五步的交互，DispatcherServlet会发现应用的是InternalResource ViewResolver，这个其实就是jsp默认的View7、通过第五步的交互，DispatcherServlet也会把Model和list.jsp相结合，8、最终返回给用户实际开发的时候只有蓝色的部分，其他的可以使用默认的注解形式，非常方便地映射URL，去对应到相应的逻辑，同时控制输出数据和对应的页面 设计Restful接口 一种软件架构风格，设计风格而不是标准，只是提供了一组设计原则和约束条件。它主要用于客户端和服务器交互类的软件。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。–百度百科 通过这个项目，我对Restful接口的理解是： 这是一种优雅的URL表达方式，通过这种URL表达式可以明显的感知到这个URL代表的是什么业务场景或者什么的数据、资源 以下是本项目的URL设计： /seckill/list：秒杀列表，GET方式 /seckill/{id}/detail：详情页，GET方式 /seckill/time/now：系统时间，通过系统时间为基准，对秒杀操作进行提前的计时的操作逻辑，GET方式 /seckill/{id}/exposer：暴露秒杀，通过这个URL才能拿到最后要执行秒杀操作的URL，POST方式 /sekcill/{id}/{md5}/execution：执行秒杀，POST方式 使用Spring MVC实现Restful接口在org.seckill包下新建一个web包，用于存放所有的controller，新建一个SeckillController类123@Controller@RequestMapping(&quot;/seckill&quot;)public class SeckillController 标注这个类是一个Controller，使用@Controller注解，目的是将这个类放入Spring容器当中 还要加上一个@RequestMapping注解，代表的是模块，由于我们使用比较规范的URL设计风格，所有的URL应该是：1/模块/资源/&#123;id&#125;/更加细分 要获取列表页，也就是要调用Service12345//实例化日志对象，导入org.slf4j包private final Logger logger = LoggerFactory.getLogger(this.getClass()); @Autowiredprivate SeckillService seckillService; 将Service注入到当前的Controller下，SeckillService在Spring容器中只有一个，Spring容器根据类型匹配，会直接找到bean的实例，然后注入到当前的Controller下 秒杀列表页123456789@RequestMapping(value = &quot;/list&quot;, method = RequestMethod.GET)public String list(Model model)&#123; //获取列表页 List&lt;Seckill&gt; list = seckillService.getSeckillList(); model.addAttribute(&quot;list&quot;, list); return &quot;list&quot;;&#125; 参数model就是用来存放渲染list.jsp的数据 1@RequestMapping(value = &quot;/list&quot;, method = RequestMethod.GET) 这里Spring MVC的注解映射使用的是@RequestMapping注解，其中value的值是二级URL，后面的method属性限制了http请求的方式，这个方法只接收GET方式的http请求，如果是POST请求，Spring MVC将不会做映射 @RequestMapping注解它支持很多种URL映射： 支持标准的URL 支持Ant风格URL，即```等字符123456 - ``` ? ```表示匹配一个字符 - ``` * ```表示匹配任意字符 - ``` ** ```表示匹配任意URL路径- 带&#123;&#125;占位符的URL举个栗子： /user//creation可以匹配/user/aaa/creation、/user/bbb/creation等URL/user/*/creation可以匹配/user/creation、/user/aaa/bbb/creation等URL/user/{userId}可以匹配user/213、user/abc等URL 123、abc可以以参数的方式传入/company/{companyId}/user/{userId}/detail匹配/company/123/user/456/detail等URL12在list方法中，通过实例化的SeckillService调用其中的方法 /** 查询所有秒杀商品记录 @return*/List getSeckillList();//这是SeckillService接口中的方法12345```//获取列表页List&lt;Seckill&gt; list = seckillService.getSeckillList();model.addAttribute(&quot;list&quot;, list);return &quot;list&quot;; model就是用来存放数据的，并把返回的数据通过字符串进行标识，最后返回一个字符串，那么这里为什么返回一个字符串？这个字符串会被怎么处理？ 之前介绍的Spring MVC运行流程HandlerAdapter在对Handler，即SeckillController进行处理之后会返回一个ModelAndView对象，在获得了ModelAndView对象之后，Spring就需要把该View渲染给用户，即返回给浏览器。在这个渲染的过程中，发挥作用的就是ViewResolver和View12345&lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;viewClass&quot; value=&quot;org.springframework.web.servlet.view.JstlView&quot;/&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;&lt;/bean&gt; 在spring-web.xml文件中使用的ViewResolver是InternalResourceViewResolver InternalResourceViewResolver 会把返回的视图名称都解析为 InternalResourceView 对象， InternalResourceView 会把 Controller 处理器方法返回的模型属性都存放到对应的 request 属性中，然后通过 RequestDispatcher 在服务器端把请求 forword 重定向到目标 URL 。比如在 InternalResourceViewResolver 中定义了 prefix=/WEB-INF/ ， suffix=.jsp ，然后请求的 Controller 处理器方法返回的视图名称为 test ，那么这个时候 InternalResourceViewResolver 就会把 test 解析为一个 InternalResourceView 对象，先把返回的模型属性都存放到对应的 HttpServletRequest 属性中，然后利用 RequestDispatcher 在服务器端把请求 forword 到 /WEB-INF/test.jsp 这就是 InternalResourceViewResolver 一个非常重要的特性，我们都知道存放在 /WEB-INF/ 下面的内容是不能直接通过 request 请求的方式请求到的，为了安全性考虑，我们通常会把 jsp 文件放在 WEB-INF 目录下，而 InternalResourceView 在服务器端跳转的方式可以很好的解决这个问题 秒杀详情页1234567891011121314@RequestMapping(value = &quot;/&#123;seckillId&#125;/detail&quot;, method = RequestMethod.GET)public String detail(@PathVariable(&quot;seckillId&quot;) Long seckillId, Model model)&#123; if(seckillId == null)&#123; return &quot;redirect:/seckill/list&quot;; &#125; Seckill seckill = seckillService.getById(seckillId); if(seckill == null)&#123; return &quot;forward:/seckill/list&quot;; &#125; model.addAttribute(&quot;seckill&quot;, seckill); return &quot;detail&quot;; &#125; 之前说过，@RequestMapping注解支持多种URL映射，本项目所设计的URL就有带{}占位符的URL12@RequestMapping(value = &quot;/&#123;seckillId&#125;/detail&quot;, method = RequestMethod.GET)public String detail(@PathVariable(&quot;seckillId&quot;) Long seckillId, Model model) 通过@PathVariable注解绑定后面的参数seckilId，然后对应到URL占位符，当用户传递对应的URL时，@RequestMapping注解中占位符{seckillId}的值会传入detail方法中对应的参数，因为不同的秒杀商品有不同的详情页，所以在二级URL上使用占位符标识不同id的秒杀商品 接着对传进来的seckillId进行判断1234567if(seckillId == null)&#123; return &quot;redirect:/seckill/list&quot;;&#125;Seckill seckill = seckillService.getById(seckillId);if(seckill == null)&#123; return &quot;forward:/seckill/list&quot;;&#125; 先要判断seckillId有没有传进来，如果没有传进来，就请求转发到list页面，会回到列表页；如果传进来的seckillId的值不属于任何秒杀商品，那么仍然会重定向到列表页 这里简单说下请求转发与重定向： 从地址栏显示来说： forward：服务器请求资源，服务器直接访问目标地址的URL，把那个URL的响应内容读取过来，然后把这些内容再发给浏览器，浏览器根本不知道服务器发送的内容从哪里来的，所以它的地址栏还是原来的地址 redirect：服务端根据逻辑，发送一个状态码，告诉浏览器重新去请求那个地址，所以地址栏显示的是新的URL，redirect等于客户端向服务器端发出两次request，同时也接受两次response 从数据共享来说 forward：转发页面和转发到的页面可以共享request里面的数据 redirect：不能共享数据 从运用地方来说 forward：一般用于用户登陆的时候,根据角色转发到相应的模块 redirect：一般用于用户注销登陆时返回主页面和跳转到其它的网站等 从效率来说 forward：高 redirect：低 这里使用redirect和forward没有特别的用意 12model.addAttribute(&quot;seckill&quot;, seckill);return &quot;detail&quot;; 接着就是使用model存储数据，并返回一个字符串 秒杀地址暴露1234567891011121314151617@RequestMapping( value = &quot;/&#123;seckillId&#125;/exposer&quot;, method = RequestMethod.POST, produces = &#123;&quot;application/json;charset=UTF-8&quot;&#125;)@ResponseBodypublic SeckillResult&lt;Exposer&gt; exposer(@PathVariable(&quot;seckillId&quot;) Long seckillId)&#123; SeckillResult&lt;Exposer&gt; result; try &#123; Exposer exposer = seckillService.exportSeckillUrl(seckillId); result = new SeckillResult&lt;Exposer&gt;(true, exposer); &#125; catch (Exception e) &#123; logger.error(e.getMessage(), e); result = new SeckillResult&lt;Exposer&gt;(false, e.getMessage()); &#125; return result;&#125; 同样在方法上使用@RequestMapping注解设置二级URL，限制http请求方式为POST，并且通过produces返回HttpResponse的hanndler，告诉浏览器这是一个application/json,同时设置编码为UTF-8 使用@ResponseBody注解，Spring MVC会把返回的数据封装成json 之前说过有个DTO层，主要是用来封装Service层与WEB层之间的数据，这里在dto包下新建一个SeckillResult类，用于封装数据结果123456789//封装json结果public class SeckillResult&lt;T&gt; &#123; private boolean success;//判断请求是否成功 private T data;//存放数据 private String error;//错误信息&#125; 这个类是一个泛型类型123456789public SeckillResult(boolean success, T data) &#123; this.success = success; this.data = data;&#125;public SeckillResult(boolean success, String error) &#123; this.success = success; this.error = error;&#125; 通过success来判断请求是否成功，成功的话，返回从数据库中取得的数据，如果请求不成功，返回错误信息 再生成get和set方法 12345SeckillResult&lt;Exposer&gt; result; try &#123; Exposer exposer = seckillService.exportSeckillUrl(seckillId); result = new SeckillResult&lt;Exposer&gt;(true, exposer);&#125; 实例化一个SeckillResult对象，调用SeckillService的exportSeckillUrl方法1234567/*** 秒杀开启时输出秒杀接口地址* 否则输出系统时间和秒杀时间* @param seckillId* @return*/Exposer exportSeckillUrl(long seckillId);//SeckillService接口中的方法 可以看到SeckillService的这个方法返回的是Exposer类型，所以实例化SeckillResult对象的时候，泛型中是Exposer类型1234567891011121314151617181920public class Exposer &#123; //是否开启秒杀 private boolean exposed; //加密措施 private String md5; //id private long seckillId; //系统当前时间（毫秒） private long now; //秒杀开启时间 private long start; //秒杀结束时间 private long end;&#125; 从之前定义好的Exposer类中的属性就可以看到，如果开启秒杀的话，页面会返回通过MD5加密过的秒杀的地址，如果没有开启秒杀，则返回系统当前时间及秒杀开启与结束时间，用于倒计时 在SeckillController中，如果秒杀开启，通过调用SeckillService中的exportSeckillUrl方法返回Exposer对象，存放的是MD5及seckillId，然后初始化SeckillResult对象，参数为true，成功返回Exposer对象中的数据 如果这期间出现错误，说明没有请求成功，需要把上面两步try/catch一下12345catch (Exception e) &#123; logger.error(e.getMessage(), e); result = new SeckillResult&lt;Exposer&gt;(false, e.getMessage());&#125;return result; 因为没请求成功，所以需要输出错误信息，同时说明不在秒杀活动期内，同样初始化SeckillResult对象，返回Exposer类中的信息，在Exposer中定义的有系统当前时间以及秒杀开启、结束时间，所以如果没有请求成功，在页面返回的是倒计时或者是秒杀结束等字样 执行秒杀12345678910111213141516171819202122232425262728@RequestMapping( value = &quot;/&#123;seckillId&#125;/&#123;md5&#125;/execution&quot;, method = RequestMethod.POST, produces = &#123;&quot;application/json;charset=UTF-8&quot;&#125;)@ResponseBodypublic SeckillResult&lt;SeckillExecution&gt; execute(@PathVariable(&quot;seckillId&quot;) Long seckillId, @PathVariable(&quot;md5&quot;) String md5, @CookieValue(value = &quot;killPhone&quot;, required = false) Long phone)&#123; if(phone == null)&#123; return new SeckillResult&lt;SeckillExecution&gt;(false, &quot;未注册&quot;); &#125; //SeckillResult&lt;SeckillExecution&gt; result; try &#123; SeckillExecution execution = seckillService.executeSeckill(seckillId, phone, md5); return new SeckillResult&lt;SeckillExecution&gt;(true, execution); &#125; catch (RepeatKillException e) &#123; SeckillExecution execution = new SeckillExecution(seckillId, SeckillStateEnum.REPEAT_KILL); return new SeckillResult&lt;SeckillExecution&gt;(true, execution); &#125; catch (SeckillCloseException e) &#123; SeckillExecution execution = new SeckillExecution(seckillId, SeckillStateEnum.END); return new SeckillResult&lt;SeckillExecution&gt;(true, execution); &#125; catch (Exception e) &#123; logger.error(e.getMessage(), e); SeckillExecution execution = new SeckillExecution(seckillId, SeckillStateEnum.INNER_ERROR); return new SeckillResult&lt;SeckillExecution&gt;(true, execution); &#125;&#125; 方法上的注解就不多说了，和上面一样，所有的ajax请求返回的都是统一的SeckillResult，之前在dto包中已经定义了SeckillException，用于封装秒杀执行后的结果123456789101112131415161718/** * 封装秒杀执行后的结果 * @author Fzero * */public class SeckillExecution &#123; private long seckillId; //秒杀结果执行后的状态 private int state; //状态信息 private String stateInfo; //秒杀成功对象 private SuccessKilled successKilled;&#125; 这里就可以理解DTO作为Service与WEB层之间数据传递 因为所有的秒杀都要有用户的标识，本项目没有做登录模块，所以使用手机号phone作为用户的标识，可以看到@RequestMapping注解中的请求参数中没有phone，这个参数是由用户浏览器的Request请求的cookie中获取到的，这里Spring MVC处理cookie有个小问题，如果不设置required属性为false的时候，当请求的header中没有一个cookie叫killPhone的时候，Spring MVC会报错，所以在@CookieValue注解中将required设置为false 1234567if(phone == null)&#123; return new SeckillResult&lt;SeckillExecution&gt;(false, &quot;未注册&quot;);&#125;try &#123; SeckillExecution execution = seckillService.executeSeckill(seckillId, phone, md5); return new SeckillResult&lt;SeckillExecution&gt;(true, execution);&#125; 这里先使用if简单的判断一下，实际项目中，要验证的参数很多，可以采用Spring MVC的验证信息，所以这里的killPhone不是必须的，验证用户的逻辑放在代码中 对于执行秒杀操作，可能会出现各种异常和错误，所以这里需要try/catch以下，并且有些特定的异常比如重复秒杀、秒杀结束等，之前单独建立了一个exception包，专门存放与业务相关的异常123456789/*** 执行秒杀操作* @param seckillId* @param userPhone* @param md5* @return*/SeckillExecution executeSeckill(long seckillId, long userPhone, String md5) throws SeckillException,RepeatKillException,SeckillCloseException; 这是SeckillService中定义的方法，可以看到抛出了不同的异常，所以对于这些特定的异常，要单独的catch1234catch (RepeatKillException e) &#123; SeckillExecution execution = new SeckillExecution(seckillId, SeckillStateEnum.REPEAT_KILL); return new SeckillResult&lt;SeckillExecution&gt;(true, execution);&#125; 这个是处理重复秒杀的异常，重新初始化SeckillExecution对象，向数据字典传入对象异常的标识，结果是返回初始化的SeckillResult，上面说过SeckillExecution对象是用于封装秒杀执行后的结果，这里的参数为true，因为当初在SeckillResult定义布尔类型的success的时候就说明这是判断请求是否成功，这里的重复秒杀显然是请求成功，所以参数为true 1234catch (SeckillCloseException e) &#123; SeckillExecution execution = new SeckillExecution(seckillId, SeckillStateEnum.END); return new SeckillResult&lt;SeckillExecution&gt;(true, execution);&#125; 秒杀关闭异常 12345catch (Exception e) &#123; logger.error(e.getMessage(), e); SeckillExecution execution = new SeckillExecution(seckillId, SeckillStateEnum.INNER_ERROR); return new SeckillResult&lt;SeckillExecution&gt;(true, execution);&#125; 如果不是上述特定的两个异常，其他的异常都视为inner_error 最后一个方法就是获取系统时间123456@RequestMapping(value = &quot;/time/now&quot;, method = RequestMethod.GET)@ResponseBodypublic SeckillResult&lt;Long&gt; time()&#123; Date now = new Date(); return new SeckillResult&lt;Long&gt;(true, now.getTime());&#125; 至此，WEB层完成了]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java笔记之高并发秒杀API(三)]]></title>
      <url>%2F2017%2F01%2F11%2FJava%E7%AC%94%E8%AE%B0%E4%B9%8B%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A7%92%E6%9D%80API-%E4%B8%89%2F</url>
      <content type="text"><![CDATA[本篇将完成Service层的设计与开发，包括： 秒杀业务接口设计与实现 基于Spring托管Service实现类 配置Spring声明式事务 Service层集成测试 秒杀业务接口设计在org.seckill包下创建Service层需要的包： service：存放Service接口和实现类 exception：存放Service接口所需要的一些自定义异常，比如重复秒杀、秒杀关闭等 dto：数据传输层，和entity有些类似，都是存放表示数据的一些类型，entity关注的是业务上的一些封装，dto关注的是WEB和Service之间的数据传递 接着在service包下新建一个SeckillService接口 首先要做一个列表页的话，就要拿到Seckill的所有属性123456789101112/** * 查询所有秒杀商品记录 * @return */List&lt;Seckill&gt; getSeckillList();/** * 查询单个秒杀商品记录 * @param seckillId * @return */Seckill getById(long seckillId); 这是基本的查询方法，接下来是一些行为的方法 1234567/** * 秒杀开启时输出秒杀接口地址 * 否则输出系统时间和秒杀时间 * @param seckillId * @return */Exposer exportSeckillUrl(long seckillId); 在秒杀活动开始之前，要保证没有人知道秒杀接口的地址，不能让用户通过url规则拼出来秒杀活动的地址，所以这个方法在秒杀活动开启时输出秒杀接口地址，否则输出系统时间和秒杀时间 那么这个方法返回的类型是什么呢？活动期间，这个方法返回的是秒杀接口地址url，不在活动期间，返回的是一些日期，都是和业务部相关的一些数据，所以我们需要一个dto 在dto包下新建一个Exposer类，用来暴露秒杀接口，或者输出日期123456789101112131415161718192021222324252627282930313233343536/** * 暴露秒杀地址DTO * @author Fzero * */public class Exposer &#123; //是否开启秒杀 private boolean exposed; //加密措施 private String md5; //id private long seckillId; //系统当前时间（毫秒） private long now; //秒杀开启时间 private long start; //秒杀结束时间 private long end; @Override public String toString() &#123; return &quot;Exposer [exposed=&quot; + exposed + &quot;, md5=&quot; + md5 + &quot;, seckillId=&quot; + seckillId + &quot;, now=&quot; + now + &quot;, start=&quot; + start + &quot;, end=&quot; + end + &quot;]&quot;; &#125;&#125; 首先是设置一个开关exposerd，判断秒杀接口是否要暴露，对于暴露的接口，还要对接口进行一下改动，加上简单的md5，还有上面说的系统时间和秒杀时间，复写toString方法，使得日志输出的时候方便获取属性值，并生成get和set方法 为了方便初始化，需要设置几个构造方法123456public Exposer(boolean exposed, String md5, long seckillId) &#123; super(); this.exposed = exposed; this.md5 = md5; this.seckillId = seckillId;&#125; 如果在秒杀活动期内，存储MD5，如果不在活动期内，MD5的值为空 12345678public Exposer(boolean exposed, long seckillId, long now, long start, long end) &#123; super(); this.exposed = exposed; this.seckillId = seckillId; this.now = now; this.start = start; this.end = end;&#125; 如果不在秒杀活动期，返回系统时间和秒杀活动开启、关闭时间 12345public Exposer(boolean exposed, long seckillId) &#123; super(); this.exposed = exposed; this.seckillId = seckillId;&#125; 是否开启秒杀，返回seckillId Exposer类完成，返回SeckillService接口 接下来就是执行秒杀操作的方法12345678/** * 执行秒杀操作 * @param seckillId * @param userPhone * @param md5 * @return */SeckillExecution executeSeckill(long seckillId, long userPhone, String md5); 之前说过，唯一确定一个用户的方法是seckillId和phone，seckillId加上自定义的盐值，通过MD5加密，一定程度上能够防止用户通过url规则拼出秒杀接口地址，因为Exposer方法先被调用，里面有MD5的值，传递进来的MD5的值要和内部生成的一个MD5规则进行比较，如果不吻合，说明用户的url被篡改了，不执行秒杀操作，返回的类型还要再封装一个DTO接口，用来封装秒杀执行后的结果，那么秒杀执行后的结果需要什么数据呢？秒杀成功了还是失败了？如果失败了，还要知道为什么失败了 在dto包下新建一个SeckillExecution类1234567891011121314151617181920212223public class SeckillExecution &#123; private long seckillId; //秒杀结果执行后的状态 private int state; //状态信息 private String stateInfo; //秒杀成功对象 private SuccessKilled successKilled; @Override public String toString() &#123; return &quot;SeckillExecution [seckillId=&quot; + &quot;&quot; + seckillId + &quot;, state=&quot; + state + &quot;, stateInfo=&quot; + stateInfo+ &quot;, successKilled=&quot; + successKilled + &quot;]&quot;; &#125;&#125; 这里需要实例化SuccessKilled对象，如果秒杀成功，要能获得成功秒杀商品的用户信息，接着直接生成get和set方法，还要初始化几个构造方法1234567public SeckillExecution(long seckillId, SeckillStateEnum stateEnum, SuccessKilled successKilled) &#123; super(); this.seckillId = seckillId; this.state = stateEnum.getState(); this.stateInfo = stateEnum.getStateString(); this.successKilled = successKilled;&#125; 秒杀成功后，返回所有的属性值 在数据库success_killed表中，有state作为状态标识，不同的数字表示不同的状态，在接下来的代码中，也经常用到这些状态标识，但是这些状态标识和状态信息，应该是输出给前端的，这个是属于数据字典中的，没必要在代码中频繁出现，像这种常量，建议使用枚举表示，所以在org.seckill包下新建一个枚举包enums，新建一个枚举类型的文件SeckillStateEnum1234567891011121314151617public enum SeckillStateEnum &#123; SUCCESS(1, &quot;秒杀成功&quot;), END(0, &quot;秒杀结束&quot;), REPEAT_KILL(-1, &quot;重复秒杀&quot;), INNER_ERROR(-2, &quot;系统异常&quot;), DATA_REWRITE(-2, &quot;数据篡改&quot;); private int state; private String stateString; private SeckillStateEnum(int state, String stateString) &#123; this.state = state; this.stateString = stateString; &#125;&#125; 初始化一个构造方法，并生成get方法 接着创建一个方法12345678public static SeckillStateEnum stateOf(int index)&#123; for(SeckillStateEnum state : values())&#123; if(state.getState() == index)&#123; return state; &#125; &#125; return null;&#125; 返回state状态标识，可以通过状态标识获得相应的状态信息，本项目的数据字典已经完成了 在dto包下的SeckillExecution类还要再初始化一个构造方法123456public SeckillExecution(long seckillId, SeckillStateEnum stateEnum) &#123; super(); this.seckillId = seckillId; this.state = stateEnum.getState(); this.stateInfo = stateEnum.getStateString();&#125; 秒杀失败后返回相应的状态信息 这时还有个小问题，就是当执行异常的时候，要告知接口使用方这个方法可能会输出什么样的异常，因为跟业务相关的异常可以利用起来 在存放异常的exception包下新建一个SeckillException类，异常一般是作为通用的接口或类，解决某一层面的问题123456789101112131415161718/** * 秒杀业务相关异常 * @author Fzero * */public class SeckillException extends RuntimeException &#123; public SeckillException(String message, Throwable cause) &#123; super(message, cause); // TODO Auto-generated constructor stub &#125; public SeckillException(String message) &#123; super(message); // TODO Auto-generated constructor stub &#125;&#125; 继承与RuntimeException，初始化两个构造方法 这个异常本质上是一个运行期异常，运行期异常不需要手动的try/catch，使用运行期异常还有个重要的原因，就是 Spring的声明式事务，它只接收运行期异常回滚策略，也就是当抛出一个非运行期异常，Spring的声明式事务不会帮我们做回滚的 接着可以定义一些业务中比较常见的异常，可以单独捕捉或处理 新建一个RepeatKillException类，从名字可以看出，处理的是重复秒杀的异常123456789101112131415161718/** * 重复秒杀异常（运行期异常） * @author Fzero * */public class RepeatKillException extends SeckillException &#123; public RepeatKillException(String message, Throwable cause) &#123; super(message, cause); // TODO Auto-generated constructor stub &#125; public RepeatKillException(String message) &#123; super(message); // TODO Auto-generated constructor stub &#125;&#125; 再新建一个SeckillCloseException类，秒杀关闭异常123456789101112131415161718/** * 秒杀关闭异常 * @author Fzero * */public class SeckillCloseException extends SeckillException &#123; public SeckillCloseException(String message, Throwable cause) &#123; super(message, cause); // TODO Auto-generated constructor stub &#125; public SeckillCloseException(String message) &#123; super(message); // TODO Auto-generated constructor stub &#125;&#125; 秒杀活动关闭后，秒杀的执行不能被允许，比如时间到了，或者库存消耗光了 秒杀接口实现在service包下新建一个impl包，用于存放实现Service接口的实现类，新建一个SeckillService接口的实现类SeckillServiceImpl，然后复写SeckillService的四个方法12345678910111213141516171819public class SeckillServiceImpl implements SeckillService &#123; private Logger logger = LoggerFactory.getLogger(this.getClass()); private SeckillDao seckillDao; private SuccessKilledDao successKilledDao; //MD5盐值字符串，用户混淆MD5 private final String slat = &quot;sldjflsjdfwiejfwjefi$&amp;**(&amp;*&amp;&quot;; public List&lt;Seckill&gt; getSeckillList() &#123; return seckillDao.queryAll(0, 4); &#125; public Seckill getById(long seckillId) &#123; return seckillDao.queryById(seckillId); &#125;&#125; 这里要用DAO中的接口，把之前设计的两个接口实例化并生成get方法，但不初始化，因为所有DAO接口的实现类都在Spring容器当中，然后是实例化日志对象，导入org.slf4j包，接着修改复写的方法 1234567891011121314public Exposer exportSeckillUrl(long seckillId) &#123; Seckill seckill = seckillDao.queryById(seckillId); if(seckill == null)&#123; return new Exposer(false, seckillId); &#125; Date startTime = seckill.getStartTime(); Date endTime = seckill.getEndTime(); Date nowTime = new Date();//系统当前时间 if(nowTime.getTime() &lt; startTime.getTime() || nowTime.getTime() &gt; endTime.getTime())&#123; return new Exposer(false, seckillId, nowTime.getTime(), startTime.getTime(), endTime.getTime()); &#125; String md5 = getMD5(seckillId); return new Exposer(true, md5, seckillId);&#125; 这个方法就是用于显示秒杀接口的地址，首先要进行一个判断，如果seckill为空，就返回一个Exposer，使用Exposer中的构造方法，如果不为空，但是不在秒杀活动期内，就返回秒杀活动的开始时间、结束时间和系统时间，最后既然都判断完了，时间在秒杀活动内，就要返回秒杀开启的一些信息，通过返回的MD5才能与用户输入的地址是否正确 为了不让用户猜到返回值，前面已经定义了一个用于混淆的值slat，越复杂越好，然后创建一个方法，生成MD512345private String getMD5(long seckillId)&#123; String base = seckillId + &quot;/&quot; + slat; String md5 = DigestUtils.md5DigestAsHex(base.getBytes()); return md5;&#125; 如果只使用id进行MD5加密的话，实际上用户是可以通过算法跑出来的，如果加上混淆的字符串，几乎是不可能的 最后要完成的是执行秒杀方法的实现12345678910111213141516171819202122232425262728293031323334public SeckillExecution executeSeckill(long seckillId, long userPhone, String md5) &#123; if(md5 == null || !md5.equals(getMD5(seckillId)))&#123; throw new SeckillException(&quot;seckill data rewrite&quot;); &#125; //执行秒杀逻辑：减库存 + 记录购买行为 Date nowTime = new Date(); try &#123; //减库存 int updateCount = seckillDao.reduceNumber(seckillId, nowTime); if(updateCount &lt;= 0)&#123; //没有更新记录，即秒杀活动结束 throw new SeckillCloseException(&quot;seckill is closed&quot;); &#125; else &#123; //记录购买行为 int insertCount = successKilledDao.insertSuccessKilled(seckillId, userPhone); if(insertCount &lt;= 0)&#123; //重复秒杀 throw new RepeatKillException(&quot;seckill repeated&quot;); &#125; else &#123; //秒杀成功 SuccessKilled successKilled = successKilledDao.queryByIdWithSeckill(seckillId, userPhone); return new SeckillExecution(seckillId, SeckillStateEnum.SUCCESS, successKilled); &#125; &#125; &#125; catch(SeckillCloseException e1) &#123; throw e1; &#125; catch(RepeatKillException e2)&#123; throw e2; &#125; catch (Exception e) &#123; logger.error(e.getMessage(), e); //所有编译期异常转化为运行期异常 throw new SeckillException(&quot;seckill inner error: &quot; + e.getMessage()); &#125;&#125; 首先要判断用户传递过来的MD5是否和我们设置的MD5的值是否相同，不相同或是空的话，抛出一个SeckillException异常 成功秒杀后，就要执行秒杀逻辑，即减库存+记录购买行为，以系统当前时间为秒杀时间，reduceNumber方法还能判断秒杀时间是否在活动时间内，如果返回的值小于等于0，说明没有更新记录，即秒杀活动结束了 成功减库存后，就要记录购买行为了，同样进行判断，如果返回值小于等于0 说明重复秒杀，insert语句不执行，如果秒杀成功，返回SuccessKilled对象 最后，整个逻辑要try/catch，因为可能会有其他的异常，比如超时、链接断开等，并抛出业务异常，因为SeckillException继承自RuntimeException，所以这里就把编译期异常，转化为运行期异常，这样Spring的声明式事务可以帮我们做回滚操作，因为之前方法中会可能有指定的异常，比如重复秒杀，秒杀关闭等，所以在SeckillException父类异常之前catch住，然后抛出 至此，Service层接口的实现类完成了 基于Spring管理Service依赖管理Service，本质上是通过Spring IOC功能，即依赖注入对于Spring IOC，首先会有一个创建对象的过程，也就是对象工厂，这个工厂可以创建SeckillService的实现 而SeckillService也需要众多依赖，比如DAO层的依赖，所以Spring IOC不但帮我们创建SeckillDAO和SuccessKilledDAO的实现，还要创建Service层的实现，并且把这些实现组成依赖，最终提供一个一直的访问接口，通过这个接口，我们可以访问工厂当中任意的实例 SeckillService依赖DAO层的两个接口，DAO的接口依赖于SqlSessionFactory，而SqlSessionFactory也需要数据源等一些依赖，整个这个初始化过程，都是由Spring自动组装好，最后给我们的是一个SeckillService，一个完整的实例 在resources/spring包下新建一个spring-service.xml，可以把spring-dao.xml中beans标签中的内容复制过来，当然，在这基础场在添加三行内容，关于tx的命名空间12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt;&lt;beans&gt; 首先配置的是扫描service包下所有使用注解的类型12&lt;!-- 扫描service包下所有使用注解的依赖 --&gt;&lt;context:component-scan base-package=&quot;org.seckill.service&quot;/&gt; 扫描后会初始化这些类型，然后放到Spring容器当中，如果这些类型中有其他的依赖，比如SeckillServiceImpl类中有SeckillDao和SuccessKilledDao的依赖，这个配置也会初始化这些依赖 那么是哪些注解？首先是@Component，代表所有的组件，当不清楚这个类或者属性是属于DAO或者是Service的时候，可以使用这个,当然还有@Service、@Dao、@Conroller等 对于SeckillServiceImpl，很明显，在类上添加@Service注解12@Servicepublic class SeckillServiceImpl implements SeckillService 同样，在SeckillServiceImpl方法中，对于seckillDao属性和successKillDao属性123456//注入Service依赖@Autowiredprivate SeckillDao seckillDao;@Autowiredprivate SuccessKilledDao successKilledDao; MyBatis和Spring整合之后，MyBatis下所有的DAO接口都会使用mapper的方式初始化好，然后放到Spring容器当中，要在Spring容器中获取DAO的实例，并注入到Service中，可以使用Spring提供的注解@Autowired，使用之后，它就会在Spring容器中查找SeckillDao的实例，因为之前MyBatis的mapper已经初始化好并放在Spring容器中，所以就会注入到Service的属性中，不需要手动的new一个 Spring声明式事务声明式事务的基本流程，先是开启事务，然后修改SQL语句，最后再提交或回滚事务 由于 Spring只有在抛出运行期异常（RuntimeException)时才会执行回滚操作 ，所以在代码中要小心使用try/catch，当异常被捕捉到的时候，Spring接收不到异常，就不会执行回滚操作 打开spring-service.xml，开始配置Spring声明式事务12345&lt;!-- 配置事务管理器 --&gt;&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;!-- 注入数据库连接池 --&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;&lt;/bean&gt; 只要用到事务，首先配置的就是事务管理器，MyBatis默认的是jdbc的事务管理器，接着注入数据库连接池 然后配置基于注解的声明式事务，这个配置的作用就是默认使用注解来管理事务行为12&lt;!-- 配置基于注解的声明式事务:默认使用注解来管理事务行为 --&gt;&lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&gt; 打开SeckillServiceImpl类，在executeSeckill方法上添加@Transactional注解12@Transactionalpublic SeckillExecution executeSeckill(long seckillId, long userPhone, String md5) 不是所有的方法都要在事务的控制之下，比如只读，所以只在会对数据库进行更新操作的方法上添加Spring的声明式事务注解，这样就可以保证该方法运行在事务的控制之下，防止数据被错误的修改 五、Service层集成测试对SeckillService类生成相应的测试类，选中所有的方法，同样在类上加上@RunWith和@ContextConfiguration注解123456@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(&#123; &quot;classpath:spring/spring-dao.xml&quot;, &quot;classpath:spring/spring-service.xml&quot;&#125;)public class SeckillServiceTest 然后通过Spring依赖注入的方式，将测试类的属性注入到当前测试类下,在测试之前，先把日志的输出定义一下，导入org.slf4j包1234private final Logger logger = LoggerFactory.getLogger(this.getClass());@Autowiredprivate SeckillService seckillService; 不过slf4j只是接口，要实现日志需要logback，在resources目录下新建一个logback.xml文件，然后打开logback官网，找到相关配置示例，复制过来 先测试两个获取Seckill数据的方法123456789101112@Testpublic void testGetSeckillList() &#123; List&lt;Seckill&gt; list = seckillService.getSeckillList(); logger.info(&quot;list=&#123;&#125;&quot;, list);&#125;@Testpublic void testGetById() &#123; long id = 1000; Seckill seckill = seckillService.getById(id); logger.info(&quot;seckill=&#123;&#125;&quot;, seckill);&#125; 可以看到最下面拿到了List 接着测试exportSeckillUrl方法，用于显示秒杀接口地址或者是日期123456@Testpublic void testExportSeckillUrl() &#123; long id = 1000; Exposer exposer = seckillService.exportSeckillUrl(id); logger.info(&quot;exposer=&#123;&#125;&quot;, exposer);&#125; 最下面显示了MD5的值，如果返回的MD5为null，说明不在秒杀活动期内，想看到MD5的话，在控制台进入MySQL，把seckill表中的start_time/end_time改一下 最后是executeSeckill方法1234567891011121314@Testpublic void testExecuteSeckill() &#123; long id = 1000; long userPhone = 13587456321L; String md5 = &quot;f540e8a6bf6016cea1d929ca265dfed3&quot;; try &#123; SeckillExecution execution = seckillService.executeSeckill(id, userPhone, md5); logger.info(&quot;result=&#123;&#125;&quot;, execution); &#125; catch (RepeatKillException e) &#123; logger.error(e.getMessage()); &#125; catch (SeckillCloseException e) &#123; logger.error(e.getMessage()); &#125;&#125; 第一条是之前测试的数据 方法中的MD5的值是上个方法测试后日志输出时的数据 当然，最后两个方法可以放在一个测试方法中，免得要手动复制MD51234567891011121314151617181920@Testpublic void testSeckillLogic() &#123; long id = 1001; Exposer exposer = seckillService.exportSeckillUrl(id); if(exposer.isExposed())&#123; logger.info(&quot;exposer=&#123;&#125;&quot;, exposer); long userPhone = 13587456321L; String md5 = exposer.getMd5(); try &#123; SeckillExecution execution = seckillService.executeSeckill(id, userPhone, md5); logger.info(&quot;result=&#123;&#125;&quot;, execution); &#125; catch (RepeatKillException e) &#123; logger.error(e.getMessage()); &#125; catch (SeckillCloseException e) &#123; logger.error(e.getMessage()); &#125; &#125; else &#123; //秒杀未开启 logger.warn(&quot;exposer=&#123;&#125;&quot;, exposer); &#125; 这里的try/catch其实是为了保证测试类的通过，因为像重复秒杀异常(RepeatKillException)、秒杀关闭异常(SeckillCloseException)都是自定义的异常，这些异常报错，也说明测试通过了，所以为了统一，把这些用于测试的异常也catch住并打印 至此，Service层接口的设计与实现完成了]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java笔记之高并发秒杀API(二)]]></title>
      <url>%2F2017%2F01%2F05%2FJava%E7%AC%94%E8%AE%B0%E4%B9%8B%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A7%92%E6%9D%80API-%E4%BA%8C%2F</url>
      <content type="text"><![CDATA[本篇将完成DAO层的设计与开发，包括： 数据库、DAO实体与接口设计与编码 基于MyBatis实现DAO编程 MyBatis与Spring整合 DAO层单元测试 数据库设计与编码打开Eclipse，在src\main下建立一个文件夹sql，用于存放建表语句，新建一个SQL文件schema.sql，先创建一个秒杀商品的库存表 123456789101112131415161718192021-- 数据库初始化脚本-- 创建数据库CREATE DATABASE seckill;-- 使用数据库USE seckill;--创建秒杀库存表CREATE TABLE seckill(`seckill_id` bigint NOT NULL AUTO_INCREMENT COMMENT &apos;商品库存id&apos;,`name` varchar(120) NOT NULL COMMENT &apos;商品名称&apos;,`number` int NOT NULL COMMENT &apos;库存数量&apos;,`start_time` timestamp NOT NULL COMMENT &apos;秒杀开始时间&apos;,`end_time` timestamp NOT NULL COMMENT &apos;秒杀结束时间&apos;,`create_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &apos;创建时间&apos;,PRIMARY KEY (seckill_id),key idx_start_time(start_time),key idx_end_time(end_time),key idx_create_time(create_time))ENGINE=InnoDB AUTO_INCREMENT=1000 DEFAULT CHARSET=utf8 COMMENT=&apos;秒杀库存表&apos;; 主键为seckill_id，再单独对start_time、end_time、create_time三列单独建立索引，最后显式的设置MySQL引擎为InnoDB、自增主键初始值设置为1000、编码方式为utf8，并添加注释 MySQL默认的有很多引擎，只有InnoDB支持事务 可以插入几条数据12345678-- 初始化数据INSERT INTO seckill(name,number,start_time,end_time)VALUES (&apos;1000秒杀iPhone6S&apos;,100,&apos;2017-01-01 00:00:00&apos;,&apos;2017-01-02 00:00:00&apos;), (&apos;500秒杀MBP&apos;,200,&apos;2017-01-01 00:00:00&apos;,&apos;2017-01-02 00:00:00&apos;), (&apos;300秒杀iPad&apos;,100,&apos;2017-01-01 00:00:00&apos;,&apos;2017-01-02 00:00:00&apos;), (&apos;200秒杀小米MIX&apos;,300,&apos;2017-01-01 00:00:00&apos;,&apos;2017-01-02 00:00:00&apos;); 建立秒杀成功明细表，记录秒杀成功的用户信息和商品信息12345678910-- 秒杀成功明细表-- 用户登录认证相关的信息CREATE TABLE success_killed(`seckill_id` bigint NOT NULL COMMENT &apos;秒杀商品id&apos;,`user_phone` bigint NOT NULL COMMENT &apos;用户手机号&apos;,`state` tinyint NOT NULL DEFAULT -1 COMMENT &apos;状态标识: -1:无效 0:成功 1:已付款 2:已发货&apos;,`create_time` timestamp NOT NULL COMMENT &apos;创建时间&apos;,PRIMARY KEY(seckill_id,user_phone),/*联合主键 防止用户重复秒杀*/key idx_create_time(create_time))ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT=&apos;秒杀成功明细表&apos;; create_time就是秒杀成功的时间 因为id和phone可以唯一确定一个用户，所以这里要用到联合主键，防止用户重复秒杀一个商品，当然以后也可以为此做过滤 数据库的设计完成了，可以在控制台或者数据库管理工具输入上述SQL语句 DAO层相关接口编码先在java目录下建立两个包： org.seckill.entity：数据库对应的实体包 org.seckill.dao：DAO层接口包 在org.seckill.entity包下新建实体类Seckill，对应数据库中的seckill表12345678910111213141516171819202122232425public class Seckill &#123; private long seckillId; private String name; private int number; private Date startTime; private Date endTime; private Date createTime;@Override public String toString() &#123; return &quot;Seckill [seckillId=&quot; + seckillId + &quot;, name=&quot; + name + &quot;, number=&quot; + number + &quot;, startTime=&quot; + startTime+ &quot;, endTime=&quot; + endTime + &quot;, createTime=&quot; + createTime + &quot;]&quot;; &#125;&#125; 然后直接生成getter和setter方法，并复写toString方法 同样在org.seckill.entity包下新建实体类SuccessKilled，对应数据库中的success_killed表123456789101112131415161718192021public class SuccessKilled &#123; private long seckillId; private long userPhone; private short state; private Date createTime; private Seckill seckill;@Override public String toString() &#123; return &quot;SuccessKilled [seckillId=&quot; + seckillId + &quot;, userPhone=&quot; + userPhone + &quot;, state=&quot; + state + &quot;, createTime=&quot; + createTime + &quot;]&quot;; &#125;&#125; 直接生成getter和setter方法，并复写toString方法1private Seckill seckill; 这里实例化了一个Seckill类的对象，因为当用户成功秒杀一个商品时，可能需要完全拿到Seckill的实体 接着在org.seckill.dao包下新建接口SeckillDao，因为在数据库中seckill表记录的是秒杀商品的库存，所以当用户秒杀成功时，应该对数据库进行操作，也就是减库存1234567 /** * 减库存 * @param seckillId * @param killTime * @return 返回受影响的行数 */int reduceNumber(long seckillId, Date killTime); 还可以查询秒杀库存表的信息1234567891011121314 /** * 根据id查询秒杀对象 * @param seckillId 秒杀商品id * @return */Seckill queryById(long seckillId);/** * 根据偏移量查询秒杀商品列表 * @param offset 初始位置 * @param limit 查询个数 * @return */List&lt;Seckill&gt; queryAll(int offset, int limit); 偏移量就是用户可以设置初始位置offset，查询limit个数据 在org.seckill.dao包下新建接口SuccessKilledDao，当有一个用户在规定时间内成功秒杀一个商品时，进行记录，并且可以根据id查询相应的信息1234567891011121314/** * 插入购买明细，可过滤重复 * @param seckillId * @param userPhone * @return 返回受影响的行数，返回0表示没有插入数据 */int insertSuccessKilled(long seckillId, long userPhone);/** * 根据id查询SuccessKilled并携带Seckill实体 * @param seckill * @return */SuccessKilled queryByIdWithSeckill(long seckillId); 对于insertSuccessKilled方法，因为id和phone能唯一确定一个用户，所以当有重复出现时，不满足条件，insert语句不执行，返回0 如何设置条件，体现在SQL语句的书写，SQL语句写在下面要用到的MyBatis的xml文件中 至此，数据库对应的实体类以及DAO层的接口完成了，而且不用写接口的实现类，因为MyBatis把这些工作都承担了 那么这里就可以对DAO层有个初步的了解： DAO层提供了一些接口，这些接口是数据库对应的实体类(即Seckill类和SuccessKilled类)对数据库各种操作(例如:减库存、记录用户信息等)而封装的接口 基于MyBatis实现DAO层接口数据库与项目之间的映射之前已经实现了，数据库中的表对应org.seckill.entity包下的实体类，数据库中的列对应这些类中的属性，而这些对象要操作数据库，需要中间的映射过程，jdbc、MyBatis、Hibernate等都是工作在这一层，把数据库中的数据映射到对象中，并通过方法，操作数据库 在DAO层，我们已经写好了接口和方法，但是没有实现类，如果使用jdbc，就要手动的拿到数据库的连接，也要有实现接口的实现类，所以使用成熟的框架可以减少工作量，后期容易维护等许多好处 这里使用MyBatis，MyBatis对实现DAO层接口提供了两种方法： MyBatis内部有一个Mapper机制来自动实现DAO层接口 通过API编程的方式，MyBatis提供了很多API 显而易见，大部分都是选择自动实现DAO层接口，这种方法只需设计接口，不需要写实现类，通过配置MyBatis的xml文件，写好SQL语句，其他的工作MyBatis都会自动完成 MyBatis全局配置先在src\main\resources下建立一个MyBatis全局的配置文件mybatis-conf.xml，再新建一个mapper目录，用于存放MyBatis的SQL映射 打开MyBatis全局配置文件mybatis-conf.xml123&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt; 将这些内容复制到xml文件中，这些示例都可以在MyBatis官网上的参考文档中找到 然后配置一些属性123456789101112131415&lt;configuration&gt; &lt;!-- 配置全局属性 --&gt; &lt;settings&gt; &lt;!-- 使用jdbc的getGenerateKeys获取数据库自增主键值 --&gt; &lt;setting name=&quot;useGeneratedKeys&quot; value=&quot;true&quot;/&gt; &lt;!-- 使用列别名替换列名 默认为true --&gt; &lt;setting name=&quot;useColumnLabel&quot; value=&quot;true&quot;/&gt; &lt;!-- 开启驼峰命名转换:Table(create_time) -&gt; Entity(createTime) --&gt; &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt; &lt;/settings&gt;&lt;/configuration&gt; 使用列别名替换列名，MyBatis默认为true，MyBatis会自动的识别出列别名对应哪个列名，并赋值到entity实体属性中 前面提到，要实现DAO层的接口可以使用MyBatis的mapper机制，为DAO接口方法提供SQL语句配置，所以在mapper文件夹下创建相应接口的配置文件SeckillDao.xml和SuccessKilledDao.xml123&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt; 同样，这些内容都要添加到xml文件中 SeckillDao接口SQL语句配置打开SeckillDao.xml12345678910111213141516171819202122232425262728&lt;!-- 目的:为DAO接口方法提供SQL语句配置 --&gt;&lt;mapper namespace=&quot;org.seckill.dao.SeckillDao&quot;&gt; &lt;update id=&quot;reduceNumber&quot; &gt; update seckill set number = number - 1 where seckill_id = #&#123;seckillId&#125; and start_time &lt;![CDATA[ &lt;= ]]&gt; #&#123;startTime&#125; and end_time &gt;= #&#123;endTime&#125; and number &gt; 0; &lt;/update&gt; &lt;select id=&quot;queryById&quot; parameterType=&quot;long&quot; resultType=&quot;Seckill&quot;&gt; select seckill_id,name,number,start_time,end_time,create_time from seckill where seckill_id = #&#123;seckillId&#125; &lt;/select&gt; &lt;select id=&quot;queryAll&quot; resultType=&quot;Seckill&quot;&gt; select seckill_id,name,number,start_time,end_time,create_time from seckill order by create_time desc limit #&#123;offset&#125;,#&#123;limit&#125; &lt;/select&gt; &lt;/mapper&gt; 首先是mapper标签中的属性，namespace是对这个mapper的命名，也就是对这个xml文件的命名，这个命名必须在mapper目录下唯一，因为真正的项目中，mapper下的xml文件有很多，如果命名不唯一，MyBatis就不知道要调用哪个xml文件了，一般都是包名.接口名 接着逐个分析SQL语句12345678910 &lt;update id=&quot;reduceNumber&quot; &gt; update seckill set number = number - 1 where seckill_id = #&#123;seckillId&#125; and start_time &lt;![CDATA[ &lt;= ]]&gt; #&#123;killTime&#125; and end_time &gt;= #&#123;killTime&#125; and number &gt; 0;&lt;/update&gt; 因为要实现SeckillDao接口中的减库存的方法，所以使用update语句，id必须在该xml文件下唯一，一般为方法名1int reduceNumber(long seckillId, Date killTime);//SeckillDao接口中定义的方法 update标签中还有parameterType属性，这里可以不用写，MyBatis可以自动识别where后面有些限制条件，秒杀成功的时间要在规定时间内，要晚于开始时间，早于结束时间，否则update语句不会执行，当库存小于等于0时，也不执行update语句，数据返回类型为int，表示受影响的行数 至于下面这句1and start_time &lt;![CDATA[ &lt;= ]]&gt; #&#123;killTime&#125; 在w3school上有详细介绍： 术语 CDATA 指的是不应由 XML 解析器进行解析的文本数据（Unparsed Character Data）。在 XML 元素中，”&lt;” 和 “&amp;” 是非法的。“&lt;” 会产生错误，因为解析器会把该字符解释为新元素的开始。“&amp;” 也会产生错误，因为解析器会把该字符解释为字符实体的开始。某些文本，比如 JavaScript 代码，包含大量 “&lt;” 或 “&amp;” 字符。为了避免错误，可以将脚本代码定义为 CDATA。CDATA 部分中的所有内容都会被解析器忽略。CDATA 部分由 “&lt;![CDATA[“ 开始，由 “]]&gt;” 结束： 如果xml文件中仅有”&lt;”和”&amp;”，还是建议把它们替换为实体引用 接着写完实现其他方法的SQL语句12345&lt;select id=&quot;queryById&quot; parameterType=&quot;long&quot; resultType=&quot;Seckill&quot;&gt; select seckill_id,name,number,start_time,end_time,create_time from seckill where seckill_id = #&#123;seckillId&#125;&lt;/select&gt; queryById方法实质上是select查询语句，resultType返回的类型是Seckill类，因为自定义的类不在java.lang包下，所以一般是包名.类名，但是后面有方法可以省略包名，这里就只写类名 1Seckill queryById(long seckillId);//SeckillDao接口中定义的方法 parameterType为long类型，因为已经开启了驼峰转换，所以可以不适用as进行列名转换 最后是queryAll方法123456&lt;select id=&quot;queryAll&quot; resultType=&quot;Seckill&quot;&gt; select seckill_id,name,number,start_time,end_time,create_time from seckill order by create_time desc limit #&#123;offset&#125;,#&#123;limit&#125;&lt;/select&gt; 多个参数的话，可以不用给parameterType，结果按降序排列 1List&lt;Seckill&gt; queryAll(int offset, int limit);//SeckillDao接口中定义的方法 对于resultType，无论返回的是List还是Map，只要给出里面的类型就可以 SuccessKilledDao接口SQL语句配置打开SuccessKilledDao.xml123456789101112131415161718192021222324252627&lt;mapper namespace=&quot;org.seckill.dao.SuccessKilledDao&quot;&gt; &lt;insert id=&quot;insertSuccessKilled&quot;&gt; &lt;!-- 主键冲突:使用ignore忽略报错 insert不执行 返回0 --&gt; insert ignore into success_killed(seckill_id,user_phone) values (#&#123;seckillId&#125;,#&#123;userPhone&#125;) &lt;/insert&gt; &lt;select id=&quot;queryByIdWithSeckill&quot; resultType=&quot;SuccessKilled&quot;&gt; &lt;!-- 根据id查询SuccessKilled并携带Seckill实体 --&gt; &lt;!-- 如何告诉Mybatis把结果映射到SuccessKilled同时映射Seckill属性 --&gt; select sk.seckill_id, sk.user_phone, sk.create_time, sk.state, s.seckill_id &quot;seckill.seckill_id&quot;, s.name &quot;seckill.name&quot;, s.start_time &quot;seckill.start_time&quot;, s.end_time &quot;seckill.end_time&quot;, s.create_time &quot;seckill.create_time&quot; from success_killed sk inner join seckill s on sk.seckill_id = s.seckill_id where sk.seckill_id = #&#123;seckillId&#125; &lt;/select&gt; &lt;/mapper&gt; 简单说下insertSuccessKilled方法，在src\main\sql目录下有个schema.sql文件，里面是建表语句，在建立success_killed表的时候设置了一个联合主键，是防止用户重复秒杀的1PRIMARY KEY(seckill_id,user_phone) 所以id和phone只要有一个重复，insert语句就会报错，对于这种错误，其实只要不执行insert即可，不需要每次都报错，所以使用ignore关键字，当有主键冲突时，忽略报错，insert语句不会执行，结果返回0，说明没有插入数据 对于queryByIdWithSeckill方法1234567891011121314151617&lt;select id=&quot;queryByIdWithSeckill&quot; resultType=&quot;SuccessKilled&quot;&gt; &lt;!-- 根据id查询SuccessKilled并携带Seckill实体 --&gt; &lt;!-- 如何告诉Mybatis把结果映射到SuccessKilled同时映射Seckill属性 --&gt; select sk.seckill_id, sk.user_phone, sk.create_time, sk.state, s.seckill_id &quot;seckill.seckill_id&quot;, s.name &quot;seckill.name&quot;, s.start_time &quot;seckill.start_time&quot;, s.end_time &quot;seckill.end_time&quot;, s.create_time &quot;seckill.create_time&quot; from success_killed sk inner join seckill s on sk.seckill_id = s.seckill_id where sk.seckill_id = #&#123;seckillId&#125;&lt;/select&gt; 首先要明确的是这个方法的作用，是根据id查询SuccessKilled并携带Seckill实体 1SuccessKilled queryByIdWithSeckill(long seckillId);//SuccessKilledDao接口中定义的方法 返回SuccessKilled类型，在这个类中，实例化了Seckill类 123from success_killed skinner join seckill s on sk.seckill_id = s.seckill_idwhere sk.seckill_id = #&#123;seckillId&#125; from success_killed表，再使用内连接的方式使seckill表加入进来，on后面表示两个表通过相同的id进行连接，id的值为传进来的参数seckillId的值在MyBatis中可以忽略as关键字 那么如何告诉Mybatis把结果映射到SuccessKilled同时映射Seckill属性，首先可以得到sk表即success_killed表中的内容1234sk.seckill_id,sk.user_phone,sk.create_time,sk.state, sk.seckill_id虽然使用了别名， 但是MyBatis会忽略别名 ，所以MyBatis视为从sk表中的seckill_id列取数据，再返回数据到Java， 因为在MyBatis全局配置文件中开启了驼峰命名转换 ，所以seckill_id就变成了seckillId，赋值给相应的变量，这就是使用框架的好处 取到了数据，映射到了SuccessKilled中，又怎么同时映射Seckill属性呢？在SuccessKilled类中， 直接实例化了Seckill类 ，并生成了getter和setter方法success_killed和seckill两个表又通过内连接的方式进行了连接，所以可以直接在select后面这样写12345s.seckill_id &quot;seckill.seckill_id&quot;,s.name &quot;seckill.name&quot;,s.start_time &quot;seckill.start_time&quot;,s.end_time &quot;seckill.end_time&quot;,s.create_time &quot;seckill.create_time&quot; 前面说过，MyBatis会忽略别名，所以这里要在后面表明，这些列是来自哪个表的，这种写法实际是OGNL表达式，据说在Struts上很常见，但是在MyBatis的xml文件中也经常用到，所以还是要多了解下 到这里，MyBatis实现DAO层接口完成了 MyBatis与Spring整合在src\main\resources\spring\下新建一个xml文件spring-dao.xml，所有的DAO层配置都放在该文件中，关于配置文件的一些信息 在Spring官网上可以找在Spring Projects下面可以找到Spring Framework，选择版本，我在pom.xml文件中配置的MyBatis是4.3.5， 点击Reference，使用Ctrl+F搜索容器相关的点击7.2.Container overview，找到相关配置文件的示例，把beans标签内的所有内容复制到项目的spring-dao.xml中 然后开始配置整合Mybatis 配置数据库相关参数在src\main\resources\新建一个jdbc的配置文件jdbc.properties1234db.driver=com.mysql.jdbc.Driverdb.url=jdbc:mysql:///seckill?useUnicode=true&amp;characterEncoding=utf8db.user=rootdb.password= 在练习的项目中可以使用数据库的root用户，实际工作中不建议使用，我的数据库没有设置密码，所以password为空 这是获取数据库的一些配置，在url中1jdbc:mysql:///seckill 等价于 jdbc:mysql://127.0.0.1:3306/seckill 数据库默认的端口是3306，可写可不写，最后跟的是数据库的名字 至于后面的一些参数1useUnicode=true&amp;characterEncoding=utf8 使用Unicode编码，编码方式为utf8 有些版本的MySQL需要加密数据通道，同时需要检查服务器认证证书，在实际的工作中，这些根据实际情况配置，为了数据安全应该是尽可能的开启，作为练习的项目，就可以不用了1234Establishing SSL connection without server&apos;s identity verification is not recommended. According to MySQL 5.5.45+, 5.6.26+ and 5.7.6+ requirements SSL connection must be established by default if explicit option isn&apos;t set. For compliance with existing applications not using SSL the verifyServerCertificate property is set to &apos;false&apos;. You need either to explicitly disable SSL by setting useSSL=false, or set useSSL=true and provide truststore for server certificate verification. 如果有关于数据通道的加密和认证证书的问题，可以把下面的参数添加到jdbc的url后面12useSSL=true&amp;verifyServerCertificate=false在xml配置文件中配置数据库url时，要使用&amp;的转义字符也就是&amp; 然后打开spring-dao.xml文件，添加下面一行12&lt;!-- 配置数据库相关参数 --&gt;&lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt; 这时，如果你的IDE跟我的Eclipse一样不靠谱的话，还要自己手动添加几行内容，从Spring上找的xml配置只是最基本的，这次用到了context标签的内容，就要把下面的内容添加到beans的标签内12345678&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; 最终的内容就是这些，跟从Spring官网上复制的相比，这次多了三条关于context的配置 配置数据库连接池123456789101112131415161718&lt;!-- 配置数据库连接池 --&gt;&lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;!-- 配置连接池属性 --&gt; &lt;property name=&quot;driverClass&quot; value=&quot;$&#123;db.driver&#125;&quot;/&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;$&#123;db.url&#125;&quot;/&gt; &lt;property name=&quot;user&quot; value=&quot;$&#123;db.user&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;db.password&#125;&quot;/&gt; &lt;!-- 配置c3p0连接池的私有属性 --&gt; &lt;property name=&quot;maxPoolSize&quot; value=&quot;30&quot;/&gt; &lt;property name=&quot;minPoolSize&quot; value=&quot;10&quot;/&gt; &lt;!-- 关闭连接后不自动commit --&gt; &lt;property name=&quot;autoCommitOnClose&quot; value=&quot;false&quot;/&gt; &lt;!-- 获取连接超时时间 --&gt; &lt;property name=&quot;checkoutTimeout&quot; value=&quot;1000&quot;/&gt; &lt;!-- 获取连接失败重试次数 --&gt; &lt;property name=&quot;acquireRetryAttempts&quot; value=&quot;2&quot;/&gt;&lt;/bean&gt; 配置连接池的属性，结合jdbc.properties来写关于#{}与${}的区别，#{}在MyBatis的SQL语句配置中有着预编译的效果MyBatis会先把#{}视为“？”，等到执行预编译语句的时候就会换成对应的参数，这些MyBatis都自动实现了，而${}是没有预编译效果，在spring-dao的配置中参数要拿来就能用，不需要预编译，所以这里用${} 关于c3p0的私有属性，这就是根据实际情况设置的，还有很多，这里就简单的设置几条 12&lt;property name=&quot;maxPoolSize&quot; value=&quot;30&quot;/&gt;&lt;property name=&quot;minPoolSize&quot; value=&quot;10&quot;/&gt; 这是设置连接池中连接个数的最大值和最小值，默认最大值为15、最小值为3 12&lt;!-- 关闭连接后不自动commit --&gt; &lt;property name=&quot;autoCommitOnClose&quot; value=&quot;false&quot;/&gt; 对于autoCommitOnClose这个属性，就是当连接池的connection变为close的时候，实际是把连接对象放到池子当中，这个过程当中连接池会做相应的清理工作，如果把autoCommitOnClose设置为true，当我们调用close的时候会连接池会自动commit，不过本来这个属性c3p0默认为false，这里只是强调一下 1234&lt;!-- 获取连接超时时间 --&gt; &lt;property name=&quot;checkoutTimeout&quot; value=&quot;1000&quot;/&gt; &lt;!-- 获取连接失败重试次数 --&gt;&lt;property name=&quot;acquireRetryAttempts&quot; value=&quot;2&quot;/&gt; 对于连接超时的设置，在实际项目中很有必要，但是自己练习的时候可有可无，后面单元测试的时候，如果长时间都拿不到数据，每次都超时的时候，可以把这个属性注释掉，先测试程序能否正常运行 配置SqlSessionFactory对象1234567891011&lt;!-- 配置SqlSessionFactory对象 --&gt;&lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;!-- 注入数据库连接池 --&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;!-- 配置Mybatis全局配置文件 即mybatis-config.xml --&gt; &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;/&gt; &lt;!-- 扫描entity包 使用别名 省略包名 --&gt; &lt;property name=&quot;typeAliasesPackage&quot; value=&quot;org.seckill.entity&quot;/&gt; &lt;!-- 扫描SQL配置文件 即mapper目录下的xml文件 --&gt; &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:mapper/*.xml&quot;/&gt;&lt;/bean&gt; 前面两步，基本上每个项目都一样，从这开始，是MyBatis的配置，或者使用别的框架，对框架相应的配置使用typeAliasesPackage可以扫描指定的包，之前说到的resultType可以直接使用类名，就是因为这个属性，如果有多个包要扫描的话，使用分号隔开 对于使用classpath引入配置文件在java和resources目录下都是classpath的范围 配置扫描DAO接口包1234567&lt;!-- 配置扫描DAO接口包 动态实现DAO接口并注入到Spring容器中 --&gt;&lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt; &lt;!-- 注入sqlSessionFactory --&gt; &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot;/&gt; &lt;!-- 扫描DAO层下的接口 --&gt; &lt;property name=&quot;basePackage&quot; value=&quot;org.seckill.dao&quot;/&gt;&lt;/bean&gt; 在这个bean中，没有id，因为其他配置不会调用这个bean 对于注入sqlSessionFactory12&lt;!-- 注入sqlSessionFactory --&gt; &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot;/&gt; 为什么使用BeanName的方法？当MapperScannerConfigurer启动的时候，如果还没有加载jdbc.properties配置文件，这样拿到的dataSource就是错误的，因为#{}中的属性值还没有被替换，所以通过BeanName后处理的方式，当使用MyBatis的时候，才回去找对应的SQLSessionFactory对象，为了防止MapperScannerConfigurer提前初始化SQLSessionFactory 至此，所有的Mybatis和Spring整合的过程完成了 DAO层单元测试SeckillDao接口测试不同的IDE建立测试类的方式大同小异，下面是Eclipse的过程在项目列表中，右键SeckillDao.java文件，选择New-&gt;Other，搜索junit，选择JUnit Test Case，点击Next 最上面可以选择junit版本，这里使用junit4 紧接着改动的是Source folder，点击右边的按钮默认的是在sec/main/java目录下，应该改为src/test/java目录下，之前说过，单元测试的内容都在test目录下，点击Ok 先不要着急点Finish，点击Next，要测试所有的方法，点击Select All-&gt;Finish点击OK此时可以看到，单元测试已经添加成功 测试类建好后，先要配置Spring和junit整合，为了是junit启动时加载SpringIOC容器1234//Spring与junit整合@RunWith(SpringJUnit4ClassRunner.class)//告诉junit Spring配置文件的位置@ContextConfiguration(&#123;&quot;classpath:spring/spring-dao.xml&quot;&#125;) 在SeckillDaoTest方法上添加两个注解，Spring提供了一个RunWith接口 是在runner下面的，使用RunWith就实现了junit启动时加载SpringIOC容器还要告诉junit Spring配置文件的位置，使用ContextConfiguration注解，在加载SpringIOC容器的时候同时加载spring-dao.xml文件，验证Spring与MyBatis整合，数据库连接池是否OK等配置 要测试SeckillDao接口，就要先注入SeckillDao，直接实例化12//注入DAO实现类依赖@Autowiredprivate SeckillDao seckillDao; 视频上使用的是@Resource注解，会报错，找不到这个类，我也折腾了半天，索性直接用@Autowired注解 先测试queryById方法1234567891011121314151617181920212223242526272829//Spring与junit整合@RunWith(SpringJUnit4ClassRunner.class)//告诉junit Spring配置文件的位置@ContextConfiguration(&#123;&quot;classpath:spring/spring-dao.xml&quot;&#125;)public class SeckillDaoTest &#123; //注入DAO实现类依赖 @Autowired private SeckillDao seckillDao; @Test public void testReduceNumber() throws Exception &#123; fail(&quot;Not yet implemented&quot;); &#125; @Test public void testQueryById() throws Exception &#123; long id = 1000; Seckill seckill = seckillDao.queryById(id); System.out.println(seckill.getName()); System.out.println(seckill); &#125; @Test public void testQueryAll() throws Exception &#123; fail(&quot;Not yet implemented&quot;); &#125;&#125; 刚开始因为@Resource注解的问题一直找不到解决的方法，同时还有别的报错信息 12Class not found org.seckill.dao.SeckillDaoTestjava.lang.ClassNotFoundException: org.seckill.dao.SeckillDaoTest 一时间找不到头绪，看到有人说可能是maven的配置问题，有些依赖没配置上，我就按照给出的信息显示哪个jar包有问题，就删哪个，然后让maven自己下载，但是删了一个又报错另一个，加上下载速度慢，又是大半天浪费了 然后脑子一抽，索性把apache-maven-3.3.9.m2\repository目录下的依赖全删了，就这样删了又下，改版本，下了又删，两天时间就这样过去了 最后快崩溃了，决定还是按照视频中的版本来，毕竟对新版本的特性不熟悉，万一再出些幺蛾子，就该摔电脑了 然后一切又恢复到两天前的样子，@Resource依旧报错，把@Resource替换成@Autowired就没有报错，然后开始测试12345678严重: Caught exception while allowing TestExecutionListener [org.springframework.test.context.support.DependencyInjectionTestExecutionListener@105fece7] to prepare test instance [org.seckill.dao.SeckillDaoTest@52045dbe]java.lang.IllegalStateException: Failed to load ApplicationContextCaused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name &apos;sqlSessionFactory&apos; defined in class path resource [spring/spring-dao.xml]: Error setting property values; nested exception is org.springframework.beans.PropertyBatchUpdateException; nested PropertyAccessExceptions (1) are:PropertyAccessException 1: org.springframework.beans.MethodInvocationException: Property &apos;dataSource&apos; threw exception; nested exception is java.lang.NoClassDefFoundError: org/springframework/jdbc/datasource/TransactionAwareDataSourceProxyCaused by: org.springframework.beans.PropertyBatchUpdateException; nested PropertyAccessExceptions (1) are:PropertyAccessException 1: org.springframework.beans.MethodInvocationException: Property &apos;dataSource&apos; threw exception; nested exception is java.lang.NoClassDefFoundError: org/springframework/jdbc/datasource/TransactionAwareDataSourceProxy 眼看着文件中没有红叉，但就是测试不通过，打断点都不行，显然是加载的时候就有问题，这里面不断提到找不到一个类1java.lang.NoClassDefFoundError: org/springframework/jdbc/datasource/TransactionAwareDataSourceProxy 上网找了半天，都说在pom.xml中没有引入spring-jdbc的依赖，要是错误都这么显而易见，都皆大欢喜了，于是针对spring-jdbc，又是循环上面的过程，删了又下，下了又删，因为要和其他Spring配置版本相同，就没改版本，查了半天，下载了半天，依旧是找不到这个类 然后脑子又一抽，既然这个版本找不到，换个版本试试，也不能一下子就跳到新版本，万一与其他依赖不兼容就崩溃了，所以选择了4.1.7.RELEASE下个版本的最新版本4.2.9.RELEASE 结果就看到 快速的点开控制台看到id为1000的数据输出了，两天半的时间，快被玩的就要砸电脑了… 接下来测试queryAll方法1234567@Testpublic void testQueryAll() throws Exception &#123; List&lt;Seckill&gt; seckills = seckillDao.queryAll(0, 100); for(Seckill seckill : seckills)&#123; System.out.println(seckill); System.out.println();&#125; 然后就看到熟悉的junit红色进度条和错误信息1Caused by: org.apache.ibatis.binding.BindingException: Parameter &apos;offset&apos; not found. Available parameters are [0, 1, param1, param2] 参数到SQL语句绑定的时候出了问题，找不到参数offset，可以回顾下在mapper目录下的SQL语句配置文件SeckillDao.xml中的SQL是怎么写的123456&lt;select id=&quot;queryAll&quot; resultType=&quot;Seckill&quot;&gt; select seckill_id,name,number,start_time,end_time,create_time from seckill order by create_time desc limit #&#123;offset&#125;,#&#123;limit&#125;&lt;/select&gt; 对比着接口中的方法定义1List&lt;Seckill&gt; queryAll(int offset, int limit);//SeckillDao接口中方法的定义 既然接口中和SQL语句中都写的和明确，但是为什么绑定不了参数？原因就是 Java没有保存形参的记录 ，意味着在Java运行过程中1queryAll(int offset, int limit);等价于queryAll(arg0, arg1); 如果方法只有一个参数的话，就没关系，比如上面的queryById方法，所以当有多个参数的时候，就要告诉MyBatis，哪个参数对应在哪个位置，这时就要对接口中的方法做些改动，MyBatis提供了一个注解@Param1List&lt;Seckill&gt; queryAll(@Param(&quot;offset&quot;) int offset, @Param(&quot;limit&quot;) int limit); 使用注解的方式，告诉MyBatis，第一个参数叫offset，对应SQL语句中#{offset}，然后再测试queryAll方法 接着测试最后一个方法reduceNumber，先看一下接口中方法的定义1int reduceNumber(long seckillId, Date killTime); 传递两个参数，一个是long类型，一个是Date类型，返回int123456@Testpublic void testReduceNumber() throws Exception &#123; Date killTime = new Date(); int updateCount = seckillDao.reduceNumber(1000L, killTime); System.out.println(&quot;updateCount = &quot; + updateCount);&#125; 右键测试依然是上面的错误，修改接口中的方法即可可以看看控制台的输出，有利于理解整个运行过程1234DEBUG o.m.s.t.SpringManagedTransaction - JDBC Connection [com.mchange.v2.c3p0.impl.NewProxyConnection@75201592] will not be managed by SpringDEBUG o.s.dao.SeckillDao.reduceNumber - ==&gt; Preparing: update seckill set number = number - 1 where seckill_id = ? and start_time &lt;= ? and end_time &gt;= ? and number &gt; 0; DEBUG o.s.dao.SeckillDao.reduceNumber - ==&gt; Parameters: 1000(Long), 2017-01-06 21:12:04.444(Timestamp), 2017-01-06 21:12:04.444(Timestamp)DEBUG o.s.dao.SeckillDao.reduceNumber - &lt;== Updates: 0 首先是jdbc通过c3p0连接池拿到了数据库的连接，但是这个jdbc连接没有被Spring所托管，是从c3p0拿到的 然后控制台还输出了SQL语句1update seckill set number = number - 1 where seckill_id = ? and start_time &lt;= ? and end_time &gt;= ? and number &gt; 0; 之前写的#{}都被MyBatis视为占位符“？”，这就是因为#{}具有预编译的功能接着显示的是传递过去的参数，最后输出结果是0，为什么没有进行减库存的操作呢？因为早在创建数据库，插入数据的时候，就已经设置了秒杀时间段12345678-- 初始化数据INSERT INTO seckill(name,number,start_time,end_time)VALUES (&apos;1000秒杀iPhone6S&apos;,100,&apos;2017-01-01 00:00:00&apos;,&apos;2017-01-02 00:00:00&apos;), (&apos;500秒杀MBP&apos;,200,&apos;2017-01-01 00:00:00&apos;,&apos;2017-01-02 00:00:00&apos;), (&apos;300秒杀iPad&apos;,100,&apos;2017-01-01 00:00:00&apos;,&apos;2017-01-02 00:00:00&apos;), (&apos;200秒杀小米MIX&apos;,300,&apos;2017-01-01 00:00:00&apos;,&apos;2017-01-02 00:00:00&apos;); 秒杀活动从1号开始，2号结束，被maven的依赖折腾后，已经是6号了，所以不在秒杀时间段内，没有执行update语句 SeckillDao接口的测试就完成了 SuccessKilledDao接口测试使用Eclipse，根据上面的步骤，建立SuccessKilledDao接口的测试类123@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(&#123;&quot;classpath:spring/spring-dao.xml&quot;&#125;)public class SuccessKilledDaoTest 同样在类上面添加两个注解，Spring和junit整合的注解，然后是告诉Spring配置文件的位置 给这个测试类注入SuccessKilledDao12@Autowiredprivate SuccessKilledDao successKilledDao; 首先是insertSuccessKilled方法，先看看接口中方法的定义1int insertSuccessKilled(@Param(&quot;seckillId&quot;) long seckillId, @Param(&quot;userPhone&quot;) long userPhone); 传递的是多个参数，所以依旧需要改动，使用MyBatis的@Param注解 根据方法的定义，就可以写测试类了1234567@Testpublic void testInsertSuccessKilled() &#123; long id = 1000L; long phone = 13512345678L; int insertCount = successKilledDao.insertSuccessKilled(id, phone); System.out.println(&quot;insertCount = &quot; + insertCount);&#125; 返回1，说明成功插入信息之前说过，这个方法可以防止用户重复秒杀，所以可以不改变参数，再执行一次可以看到返回值是0，说明没有执行insert语句 这里还有点小问题1`state` tinyint NOT NULL DEFAULT -1 COMMENT &apos;状态标识: -1:无效 0:成功 1:已付款 2:已发货&apos;, 在开始的建表语句的时候，定义了state属性，是状态标识，既然能成功执行insertSuccessKilled方法，说明可以插入数据，那么state应该是0，所以要改动一下SQL语句12345&lt;insert id=&quot;insertSuccessKilled&quot;&gt; &lt;!-- 主键冲突:使用ignore忽略报错 insert不执行 返回0 --&gt; insert ignore into success_killed(seckill_id,user_phone,state) values (#&#123;seckillId&#125;,#&#123;userPhone&#125;,0)&lt;/insert&gt; 这样，再插入的数据的state就是0了 然后是queryByIdWithSeckill方法，先看方法的定义1SuccessKilled queryByIdWithSeckill(long seckillId); 由于之前考虑的不周到，这条语句还要有些改动 因为Seckill与SuccessKilled是一对多的关系，一个秒杀商品对应多个成功秒杀记录，那么想要查询某个人的秒杀记录的时候，上面的语句就行不通了，所以要添加一个参数1SuccessKilled queryByIdWithSeckill(@Param(&quot;seckillId&quot;) long seckillId, @Param(&quot;userPhone&quot;) long userPhone); 多了一个参数，所以还要加上@Param注解，同时，还要改动的地方是mapper目录下SuccessKilledDao.xml文件，找到与方法名相同的id1where sk.seckill_id = #&#123;seckillId&#125; and sk.user_phone = #&#123;userPhone&#125; 前面已经插入过一条成功秒杀的信息，所以还是用前面的数据12345678@Testpublic void testQueryByIdWithSeckill() &#123; long id = 1000L; long phone = 13512345678L; SuccessKilled successKilled = successKilledDao.queryByIdWithSeckill(id, phone); System.out.println(successKilled); System.out.println(successKilled.getSeckillId());&#125; 因为在SuccessKilled类中已经实例化了Seckill类，并生成了getter和setter方法，所以这里也可以取到Seckill对象 终于，所有的DAO层的工作已经完成了 DAO层编码后的一些思考回顾从最初的创建数据库开始，到设计接口、编写SQL语句、各种配置文件，中间没有写一行逻辑代码，DAO层的工作实际上演变为了 接口设计+SQL编写+配置文件 ，好处就是源代码和SQL进行了分离，方便Review，而DAO拼接等逻辑在Service层完成]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java笔记之高并发秒杀API(一)]]></title>
      <url>%2F2017%2F01%2F01%2FJava%E7%AC%94%E8%AE%B0%E4%B9%8B%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A7%92%E6%9D%80API-%E4%B8%80%2F</url>
      <content type="text"><![CDATA[本次系列的Java笔记是通过学习慕课网上的高并发秒杀API的视频而总结的，只是想通过写博客的过程能让自己梳理学习的过程，顺便时刻提醒自己。 本次秒杀API的项目的整体框架是Spring+Spring MVC+Mybatis，数据库为MySQL。 创建项目使用maven构建项目，因为使用命令行下载太慢，直接在Eclipse上使用maven来创建项目 如图： archetypeArtifactId: maven-archetype-webapp gtoupId: org.seckill artifactId: seckill 打开src\main\webapp\WEB-INF\web.xml 默认的Servlet版本是2.3，但是该版本下JSP的EL表达式是不工作的，这里需要更改版本 打开apache-tomcat-8.5.9\webapps\examples\WEB-INF\web.xml， 这是Tomcat的示例配置文件，将web-app标签内的内容覆盖到项目中的web.xml的web-app标签 Tomcat8.5.9给的示例文件显示使用的Servlet版本是3.1 依赖配置首先是补全文件，在src/main下添加两个文件夹java、test java： 存放java的源文件 test： 用于单元测试 也可以直接在Eclipse中右键项目名，点击Build Path-&gt;Order and Export 把需要的都选上，然后点击Apply，引入相关文件 接着打开pom.xml，配置依赖首先的改动是junit的版本，Eclipse自动生成的pom.xml的junit版本是3.8.1，这里改为4.11 因为junit3.0的版本是默认使用编程的方式运行的， 而4.0的版本是默认通过注解的方式来运行junit的接着就是补全项目的依赖 日志相关依赖本次项目采用slf4j+logback的组合 123456789101112131415161718&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;1.7.12&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-core&lt;/artifactId&gt; &lt;version&gt;1.1.1&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 实现slf4j接口并整合 --&gt;&lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.1.1&lt;/version&gt;&lt;/dependency&gt; logback的依赖有两个： logback-core、logback-classic logback-core： 实现logback核心的功能 logback-calssic： 实现slf4j接口并整合 数据库相关依赖包括数据库驱动，数据库连接池c3p0 12345678910111213&lt;!-- 数据库相关依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.35&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;c3p0&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.1.2&lt;/version&gt;&lt;/dependency&gt; DAO框架相关依赖——即Mybatis依赖Mybatis依赖主要有两个，一个是Mybatis自身的依赖，二是Mybatis和Spring整合的依赖 12345678910111213&lt;!-- DAO框架:Mybatis相关依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.3.0&lt;/version&gt;&lt;/dependency&gt;&lt;!-- Mybatis自身实现Spring的整合依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt;&lt;/dependency&gt; Servlet WEB相关依赖一些相关的标签、jstl、jackson等 123456789101112131415161718192021222324&lt;!-- Servlet Web相关依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;taglibs&lt;/groupId&gt; &lt;artifactId&gt;standard&lt;/artifactId&gt; &lt;version&gt;1.1.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.5.4&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt;&lt;/dependency&gt; Spring相关依赖Spring核心依赖包括spring-beans相关的依赖， 一些spring扩展依赖如:spring-context 123456789101112131415161718&lt;!-- Spring核心依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;4.1.7.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;4.1.7.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;4.1.7.RELEASE&lt;/version&gt;&lt;/dependency&gt; Spring Dao层的依赖 spring-jdbc： jdbc提供数据库相关的事务管理器 spring-tx： Spring的声明式事务 123456789101112&lt;!-- Spring Dao层的依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;4.1.7.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;4.1.7.RELEASE&lt;/version&gt;&lt;/dependency&gt; Spring WEB相关的依赖包括与Spring MVC相关的依赖 123456789101112&lt;!-- Spring WEB相关的依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;4.1.7.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;4.1.7.RELEASE&lt;/version&gt;&lt;/dependency&gt; Spring test相关的依赖123456789101112&lt;!-- Spring WEB相关的依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;4.1.7.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;4.1.7.RELEASE&lt;/version&gt;&lt;/dependency&gt; 虽然以上有些依赖版本相对有些老旧，但毕竟是练习，在不是特别熟悉这些框架和服务时，尽量按照视频中的版本来，不然等到测试时，会有各种玄学的问题，比较麻烦。在实际工作中应该前期就把要采用的服务的版本特性了解清楚。 业务分析 秒杀业务的核心就是对库存的处理，而难点主要是竞争 当n个用户同时竞争一个秒杀商品时，为了保证数据准确，没有出现数据的脏读、幻读等；保证商家没有出现超卖或者少卖的现象，就必然会用到事务+行级锁 至此，准备工作完成]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2016%2F12%2F30%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
  
  
</search>
